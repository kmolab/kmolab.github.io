{"pages":[{"title":"About","text":"機械設計工程系 KMOLab 倉儲 KMOLab 倉儲: https://github.com/kmolab/kmolab.github.io KMOLab 投影片: https://kmolab.github.io KMOLab 網誌: https://kmolab.github.io/blog Contact: kmolab At mde dot tw KMOLab 信念 二十一世紀的科技大學, 在培育具世界觀與在地文化素養, 能適應環境並成功面對挑戰之專業人才. 所謂專業, 即具有專長, 能夠就業之謂. 所謂文化者, 因思考及概念而有之教化. 所謂素養, 即平日的涵養. Excellence is an art won by training and habituation. We do not act rightly because we have virtue or excellence, but we rather have those because we have acted rightly. We are what we repeatedly do. Excellence, then, is not an act but a habit. — Aristotle (384 BC – March 7, 322 BC) 卓越須經由訓練與習慣養成才能獲得。並非具備品德或卓越能讓人舉止得宜，反而是舉止得宜能讓人卓越。經過切身重複實作，才可體會，卓越並非一種作為，而是習慣。 — 亞理士多德 (西元前 384 年 – 西元前 322 年 3 月 7 日) 體魄康強, 精神活潑, 舉止端莊, 人格健全, 便是大學生的風度. 不倦的追求真理, 熱烈的愛護國家, 積極的造福人類, 才是大學生的職志. — 羅家倫 (1928) KMOLab 標誌","tags":"misc","url":"https://kmolab.github.io/blog/pages/about/"},{"title":"BIND 伺服器","text":"為了取得 your.domain.name.tw 符號名稱的管理權, 必須要向 domain.name.tw DNS 伺服器管理者要求將 dns.your.domain.name.tw 與 dns2.your.domain.name.tw 設為 your.domain.name.tw 網域的管理者, 其中假設 dns.your.domain.name.tw 的 IPv4 位址為 192.168.17.3, 而 dns1.your.domain.name.tw IPv4 位址為 192.168.17.2, 且對應的 IPv6 位址則分別為 fe80:288:6004:17::3 與 fe80:288:6004:17::2. 安裝 BIND sudo apt install bind9 bind9-doc dnsutils 編輯設定檔 Master DNS Server: /etc/bind/named.conf for Master DNS Server: // This is the primary configuration file for the BIND DNS server named. // // Please read /usr/share/doc/bind9/README.Debian.gz for information on the // structure of BIND configuration files in Debian, *BEFORE* you customize // this configuration file. // // If you are just adding zones, please do that in /etc/bind/named.conf.local include \"/etc/bind/named.conf.options\"; include \"/etc/bind/named.conf.local\"; include \"/etc/bind/named.conf.default-zones\"; /etc/bind/named.conf.options options { directory \"/var/cache/bind\"; dump-file \"/var/cache/bind/data/cache_dump.db\"; statistics-file \"/var/cache/bind/data/named_stats.txt\"; query-source address * port 53; allow-recursion { any; }; allow-recursion-on { any; }; allow-query-cache { 192.168.17.0/24; 192.168.1.0/24; }; allow-query { 192.168.17.0/24; 192.168.1.0/24; }; // secondary server allow-transfer { none; }; allow-transfer { localhost; 192.168.17.2; }; version \"version\"; // If there is a firewall between you and nameservers you want // to talk to, you may need to fix the firewall to allow multiple // ports to talk. See http://www.kb.cert.org/vuls/id/800113 // If your ISP provided one or more IP addresses for stable // nameservers, you probably want to use them as forwarders. // Uncomment the following block, and insert the addresses replacing // the all-0's placeholder. forwarders { 192.168.1.2; 168.95.1.1; }; //======================================================================== // If BIND logs error messages about the root key being expired, // you will need to update your keys. See https://www.isc.org/bind-keys //======================================================================== dnssec-validation auto; auth-nxdomain no; # conform to RFC1035 }; /etc/bind/named.conf.local for Master DNS Server: // // Do any local configuration here // // Consider adding the 1918 zones here, if they are not used in your // organization //include \"/etc/bind/zones.rfc1918\"; zone \"your.domain.name.tw\" { type master; file \"/etc/bind/db.mde\"; also-notify { 192.168.17.2; }; allow-transfer { 192.168.17.2; }; allow-update { none; }; }; zone \"17.168.192.in-addr.arpa\" { type master; file \"/etc/bind/db.17\"; also-notify { 192.168.17.2; }; allow-transfer { 192.168.17.2; }; allow-update { none; }; }; /etc/bind/db.17 for Master DNS Server: ; ; BIND reverse data file for local loopback interface ; $TTL 3600 @ IN SOA dns.your.domain.name.tw. root.your.domain.name.tw. ( 2018102406 ; Serial 10800 ; Refresh 900 ; Retry 604800 ; Expire 86400 ) ; Negative Cache TTL ; @ IN NS dns.your.domain.name.tw. @ IN NS dns2.your.domain.name.tw. 3 IN PTR dns.your.domain.name.tw. 2 IN PTR dns2.your.domain.name.tw. /etc/bind/db.mde for Master DNS Server: $TTL 3600 @ IN SOA dns.your.domain.name.tw. root.your.domain.name.tw. ( 2018102406 ; Serial 10800 ; Refresh 900 ; Retry 604800 ; Expire 86400 ) ; Negative Cache TTL ; name servers -NS records @ IN NS dns.your.domain.name.tw. @ IN NS dns2.your.domain.name.tw. @ IN A 192.168.17.3 @ IN AAAA fe80:288:6004:17::3 ; name server s -AAAA records dns IN A 192.168.17.3 dns2 IN A 192.168.17.2 dns IN AAAA fe80:288:6004:17::3 dns2 IN AAAA fe80:288:6004:17::2 ; MX records @ 3600 IN MX 1 ASPMX.L.GOOGLE.COM. IN MX 5 ALT1.ASPMX.L.GOOGLE.COM. IN MX 5 ALT2.ASPMX.L.GOOGLE.COM. IN MX 10 ALT3.ASPMX.L.GOOGLE.COM. IN MX 10 ALT4.ASPMX.L.GOOGLE.COM. Slave DNS Server: /etc/bind/named.conf for Slave DNS Server: // This is the primary configuration file for the BIND DNS server named. // // Please read /usr/share/doc/bind9/README.Debian.gz for information on the // structure of BIND configuration files in Debian, *BEFORE* you customize // this configuration file. // // If you are just adding zones, please do that in /etc/bind/named.conf.local include \"/etc/bind/named.conf.options\"; include \"/etc/bind/named.conf.local\"; include \"/etc/bind/named.conf.default-zones\"; /etc/bind/named.conf.options for Slave DNS Server: options { directory \"/var/cache/bind\"; dump-file \"/var/cache/bind/data/cache_dump.db\"; statistics-file \"/var/cache/bind/data/named_stats.txt\"; query-source address * port 53; allow-recursion { any; }; allow-recursion-on {any; }; allow-query-cache { 192.168.17.0/24; 192.168.1.0/24; }; allow-query { 192.168.17.0/24; 192.168.1.0/24; }; // slave need the following line allow-transfer { none; }; // If there is a firewall between you and nameservers you want // to talk to, you may need to fix the firewall to allow multiple // ports to talk. See http://www.kb.cert.org/vuls/id/800113 // If your ISP provided one or more IP addresses for stable // nameservers, you probably want to use them as forwarders. // Uncomment the following block, and insert the addresses replacing // the all-0's placeholder. forwarders { 192.168.1.2; 168.95.1.1; }; //======================================================================== // If BIND logs error messages about the root key being expired, // you will need to update your keys. See https://www.isc.org/bind-keys //======================================================================== dnssec-validation auto; auth-nxdomain no; # conform to RFC1035 }; /etc/bind/named.conf.local for Slave DNS Server: // // Do any local configuration here // // Consider adding the 1918 zones here, if they are not used in your // organization //include \"/etc/bind/zones.rfc1918\"; zone \"your.domain.name.tw\" { type slave; file \"/etc/bind/db.mde\"; masters { 192.168.17.3; }; }; zone \"17.168.192.in-addr.arpa\" { type slave; file \"/etc/bind/db.17\"; masters { 192.168.17.3; }; }; /etc/bind/db.17 for Slave DNS Server: ; ; BIND reverse data file for local loopback interface ; $TTL 3600 @ IN SOA dns.your.domain.name.tw. root.your.domain.name.tw. ( 2018102406 ; Serial 10800 ; Refresh 900 ; Retry 604800 ; Expire 86400 ) ; Negative Cache TTL ; @ IN NS dns.your.domain.name.tw. @ IN NS dns2.your.domain.name.tw. 3 IN PTR dns.your.domain.name.tw. 2 IN PTR dns2.your.domain.name.tw. /etc/bind/db.mde for Slave DNS Server: $TTL 3600 @ IN SOA dns.your.domain.name.tw. root.your.domain.name.tw. ( 2018102406 ; Serial 10800 ; Refresh 900 ; Retry 604800 ; Expire 86400 ) ; Negative Cache TTL ; name servers -NS records @ IN NS dns.your.domain.name.tw. @ IN NS dns2.your.domain.name.tw. @ IN A 192.168.17.3 @ IN AAAA fe80:288:6004:17::3 ; name server s -AAAA records dns IN A 192.168.17.3 dns2 IN A 192.168.17.2 dns IN AAAA fe80:288:6004:17::3 dns2 IN AAAA fe80:288:6004:17::2 ; MX records @ 3600 IN MX 1 ASPMX.L.GOOGLE.COM. IN MX 5 ALT1.ASPMX.L.GOOGLE.COM. IN MX 5 ALT2.ASPMX.L.GOOGLE.COM. IN MX 10 ALT3.ASPMX.L.GOOGLE.COM. IN MX 10 ALT4.ASPMX.L.GOOGLE.COM. 修改設定檔案內容後, 要更新 Serial number, 然後以 sudo /etc/init.d/bind9 restart 重新啟動.","tags":"Misc","url":"https://kmolab.github.io/blog/BIND-Server-for-MDE.html"},{"title":"Google 行事曆","text":"Google 行事曆 是在 2009 年推出的服務, 使用者可以在時間軸線上將特定場所安排的活動註記其上, 以便清楚了解過去、現在與未來特定團隊在特定時間於特定場地, 所從事的活動細節. 電腦輔助設計室行事曆 下列為機械設計工程系八樓電腦輔助設計室的行事曆, 其中還包括協同設計室所安排的備課時段, 大家可以清楚看到課程安排的時段, 以及與課程相關的網路資訊. 本次重新啟用 Google 行事曆的目的, 在於讓系上同仁可以透過 場地使用申請 , 將預計使用的時段, 註記在各電腦教室或研討室, 並且利用 Google G Suite Resources 與行事曆整合管理的功能, 在各申請使用時段申請時, 能夠自動進行場所與時段衝突檢查, 一旦通過申請, 各場所的行事曆中便可在各種長期使用或臨時更動的資料登錄中, 清楚呈現各場所的使用情況.","tags":"Misc","url":"https://kmolab.github.io/blog/Goodle-Calendar-for-MDE.html"},{"title":"協同設計室(三)","text":"兩週前, 當安裝設定 Ubuntu 18.04 Server 版時, 就已經從 https://blog.printk.io/2018/04/ubuntu-18-04-lts-bionic-beaver-server-installer-differences/ 中得知, 整體的安裝過程與 16.04 有明顯差異. SFTP 伺服器設定 假如使用 ubuntu-18.04-live-server-amd64.iso 執行安裝, 必須了解新的網路採用 netplan YAML 格式設定 (詳見: netplan.io ). 而且安裝流程自動搭配 一系列套件 . 其中包括 openssh-server/openssh-sftp-server/ssh-import-id. 以 openssh-sftp-server 的設定而言, 在 Ubuntu 16.04 只要手動選擇安裝 openssh-server, 安裝流程就會自動配置, 安裝完成後, sftp client 就可以自動對任何一個使用帳號進行 sftp 傳檔, 但是在 Ubuntu 18.04, 即便自動安裝了 sftp server 所需的套件, 仍必須手動對每一位用戶設定 sftp 連線的許可內容. 設定方法為 sudo vi /etc/ssh/sshd_config, 在設定檔案最後加入: Match group sftp ChrootDirectory /home X11Forwarding no AllowTcpForwarding no ForceCommand internal-sftp 表示只有屬於 sftp 群組的使用者才能夠啟動 sftp 連線, 且以各自的 /home/myuser 當作連線目錄. sshd_config 存檔後, 以 sudo service ssh restart 重新啟動 ssh 服務, 接著要將允許使用 sftp 的帳號納入 sftp 群組, 先建立 sftp 群組: sudo addgroup sftp 然後將 myuser 用戶加入 sftp 群組: sudo usermod -a -G sftp myuser 之後, myuser 就可以使用 filezilla 客戶端以 sftp 協定連線到伺服器, 以 myuser 帳號密碼登入後, 連結到 /home/myuser 目錄. 參考資料: 有關建立 sftp 群組並修改 ssh 伺服設定: https://linuxconfig.org/how-to-setup-sftp-server-on-ubuntu-18-04-bionic-beaver-with-vsftpd 有關將用戶納入 sftp 群組設定: https://askubuntu.com/questions/79565/how-to-add-existing-user-to-an-existing-group BCD 檔案複製 由於協同設計室中的六台電腦採用的群準還原卡版本為 UEFI V8, 若使用還原卡的複製 Windows 10 磁區功能後, 必須使用 WinPE DVD 或 USB 隨身碟開機後, 複製開機磁區的 BCD (Boot Configuration Data) 修復, 因此需要自製一只開機用的 USB WinPE, 加上 BootICE 與 DiskGenius 等工具套件. 製作 WinPE USB 首先必須要在一台能夠正常開機的 Windows 10 中, 安裝適合的 Windows ADK (Windows Assessment and Deployment Kit), 意思是必須配合所複製磁區的 Windows 10 版本, 下載相應的 Windows ADK 套件, 目前最新的版本為 Windows ADK for Windows 10, version 1803 . 在用來製作 WinPE USB 開機隨身碟的 Windows 10 電腦上完成 Windows ADK 的安裝後, 首先執行 Deployment and Imaging Tool environment, 將開機用的 USB WinPE 資料暫時放在 c:\\winpe 目錄中. copype amd64 c:\\winpe 接下來將 boot.wim Mount 進 c:\\winpe\\mount 目錄中: Dism /Mount-Image /ImageFile:\"C:\\WinPE\\media\\sources\\boot.wim\" /index:1 /MountDir:\"C:\\WinPE\\mount\" 接著加入 HTML Application (HTA) 套件: Dism /Add-Package /Image:\"C:\\WinPE\\mount\" /PackagePath:\"C:\\Program Files (x86)\\Windows Kits\\10\\Assessment and Deployment Kit\\Windows Preinstallation Environment\\amd64\\WinPE_OCs\\WinPE-HTA.cab\" 因為之後所要使用的 Diskgenius 需要中文介面, 所以必須再加上中文的支援: Dism /Add-Package /Image:\"C:\\WinPE\\mount\" /PackagePath:\"C:\\Program Files (x86)\\Windows Kits\\10\\Assessment and Deployment Kit\\Windows Preinstallation Environment\\amd64\\WinPE_OCs\\zh-cn\\WinPE-HTA_zh-tw.cab\" Dism /Add-Package /Image:\"C:\\WinPE\\mount\" /PackagePath:\"C:\\Program Files (x86)\\Windows Kits\\10\\Assessment and Deployment Kit\\Windows Preinstallation Environment\\amd64\\WinPE_OCs\\WinPE-FontSupport-ZH-TW.cab\" 然後就可以將 c:\\winpe 目錄中的資料轉進 f: 槽, 讓代號為 f: 的 USB 隨身碟成為 WinPE 開機碟: makewinpemedia /UFD c:\\winpe f: 最後則是下載 BootICE 與 DiskGenius 等兩項工具套件, 然後使用 7zip 工具, 開啟 f:\\sources\\boot.wim 檔案, 將 BootICEx64.exe 放入 f:\\sources\\boot.wim\\Users 目錄中, 並且將 DiskGenius 目錄也納入 f:\\sources\\boot.wim\\Users 目錄中, 就完成 WinPE USB 開機隨身碟的製作. 修復 Windows GPT 啟動區 BCD 檔案 假設使用了群準 UEFI V8 還原卡中的內建磁區複製功能, 將第一開機磁區中的資料複製到第二磁區, 進入開機表單後選擇第二磁區, 將無法進入 Windows 10 的正常開機程序, 原因是複製取得的第二磁區中的 EFI\\MicroSoft\\Boot\\BCD 檔案並非正確的 Boot Configuration Data, 必須從前述製作的 WinPE USB 開機隨身碟中複製. 基本的操作步驟為 (僅適用於 UEFI 磁碟複製, 若使用群準 Pro V8 MBR 分割的磁區複製, 可以直接開機, 不需額外處理 MBR): 從群準 UEFI V8 開機選單中, 以滑鼠選擇第二磁區. 接著按下 Ctrl + i, 表示要 install 操作系統. 接下來 UEFI BIOS 會進入重新開機流程, 這時按下 F8 (在 Asus 主機板表示要選擇 boot 裝置). 選擇以前述所製作的 WinPE USB 開機. WinPE 開機後會出現命令列視窗, 這時可以 cd 到 C:\\Users\\DiskGenius 目錄中, 執行 DiskGenius , 目的是指定第二磁區中的 ESP 分割區磁碟代號. 在 DiskGenius 視窗操作介面左側, 以滑鼠右鍵點選 ESP 分割區, 選擇指派新的磁碟機代號, 例如: 使用內建的磁碟機代號 (假設為 D:). 當第二磁區中的 ESP 分割區有了磁碟代號後 (假設為 D:), 就可以執行 C:\\Users\\BootICEx64.exe, 從目前的開機碟中將 BCD 資料複製給第二磁區. 進入 BootICEx64.exe 視窗操作介面後, 選擇 BCD 編輯, 然後在 BCD 文件中, 指定前述所設定的 D: 槽中的 EFI\\MicroSoft\\Boot\\BCD 檔案, 當作編輯對象. 接ˋ著點選其下的智慧編輯模式, 選擇 Windows 10 的啟動分割 (即 C:), 點擊保存當前設置後, 當出現 BCD 參數修改成功視窗後即完成, 詳細的說明可以參考 https://github.com/mdecourse/wcms2018/files/1947497/Evosys_UEFI_GPT_partition_copy.pdf 將電腦輔助設計室實體磁區轉為虛擬硬碟 目前電腦輔助設計室第二磁區, 主要安裝套件包括: Ansys 18.1 - 25 GB Moldex3D R15 - 1.5 GB Comsol 5.3 - 4 GB AutoDesk AutoCad, Inventor 2016 等 - 7 GB PTC Creo 3.0 M090 - 5 GB Mathematica 9.0 - 4.5 GB Matlab R2017a - 7 GB Abaqus 2017 - 3 GB Recurdy V8R5 - 4 GB 為了方便流通此一原版套件磁區, 特別製作成虛擬硬碟, 方法如下: 首先以第二磁區開機後, 加掛一個 6TB 的 USB 外接硬碟, 準備儲存虛擬硬碟檔案. 利用 https://docs.microsoft.com/en-us/sysinternals/downloads/disk2vhd , 將第二磁區轉為 .vhd 格式, 存入外接硬碟中. 此一檔案容量為 366 GB, 準備利用 Virtualbox 開機, 但是實際製作時, 出現找不到 driver 的錯誤, 無法正常開機. 接下來利用 Windows 開機 iso DVD, 加掛在 Virtualbox 的第二磁區對應虛擬開機區, 並且指定由光碟開機. 開機後選擇修復開機磁區, 完成後, 就可以正常利用 Virtualbox 開啟電腦輔助設計室中的第二磁區. OnShape 與 AutoDesk Fusion 360 才是未來 經過將近兩個月處理電腦輔助設計室中的 366 GB 硬碟的過程中, 發現從 UEFI BIOS 中的各式設定, MBR 與 GPT 硬碟分割, 操作系統安裝設定與維護, 網路使用授權的管理, 再加上各式海量電腦輔助設計分析套件的安裝, 以及每套海量使用手冊的閱讀及各套封閉 API 延伸程式的學習及應用, 所涉及的工作, 對於一群機械設計工程師所造成的負擔, 已經不是三言兩語可以道盡其中辛酸. 因為一般管理人員與助教無法單獨勝任此項工作, 而各套件代理廠商的工程師也只負責安裝各自的套件, 無法提供整體的系統規劃與管理協助, 而各任課教師則通常認為這種低階系統安裝工作, 與教學無關, 結果就難怪有許多教育版的用戶, 雖然購買原版套件, 但卻全面讓師生使用相應的盜版軟體, 因為大多數人都會認為管理並部署合法電腦輔助工程套件, 是一項耗錢費力且難有成就感的工作. 因此當 2015 年初 OnShape 推出免費的教育版使用授權時, 電腦輔助設計實習課程就逐步將教學工具從 PTC Creo Parametric (這是電腦輔助設計室中, 唯一可以安裝為可攜模式的高端 CAD套件), 轉為 OnShape ( https://www.onshape.com/ , https://dev-portal.onshape.com ), 學員不僅無需任何安裝, 也能直接在手機或平板中的 App 中操作, 完全沒有安裝維護與使用的問題與負擔. 更優的是, 配合電腦輔助設計所需的相關分析與製程規劃, 都可以在統一的雲端環境中完成: 當然, AutoDesk Fusion 360 也提供三年一期的 免費教育帳號 , 雖然需要下載安裝近端套件 (容量約佔 2.7 GB), 但也具有雲端整合的優點, 預計 2018 年秋季電腦輔助設計實習課程將搭配 OnShape 使用. 導入 Fusion 360 的著眼在於除了 C++ 的 API 程式介面外, 也同時支援 Python3 程式環境 ( Getting Started with Fusion 360's API , Fusion 360 API user's manual , Fusion 360 API samples ).","tags":"Misc","url":"https://kmolab.github.io/blog/Collaborative-Design-Laboratory-III.html"},{"title":"協同設計室(二)","text":"昨天, 採用 Fossil SCM 與 Stunnel 建置的 https://[2001:288:6004:17:0811::cd06] 虛擬主機網站已經初步完成. 大家從手機中的瀏覽器就可以直接連線 (因為已經都支援 IPv6 協定). 接下來必須將此 IPv6 網址與 cd06.kmol.info 對應之外, 還要取得此一網址的第三方簽署的數位簽章. IPv6 網址與符號名稱的設定, 必須在 DNS 伺服器中指定一組 AAAA 設定, 將兩者綁定, 而網址的數位簽章, 則採用 certbot 完成. Certbot 數位簽章 certbot 數位簽章的取得與設定, 是由 nginx 的一組 Python 延伸程式完成. 由於之前已經將 https 所使用的 443 埠號交給 Stunnel 使用, 但當時所採用的是 self-signed 的數位簽章, 並沒有登錄在公開的 public server 上. certbot 驗證網址的方式是透過 nginx 的連線完成, 因此接下來必須安裝 nginx , 使用的埠號為 http 協定的 port 80. 在 Ubuntu 18.04 中安裝 nginx , 執行: $ sudo apt install nginx 接著, 必須安裝 certbot 延伸程式: $ sudo apt-get update $ sudo apt-get install software-properties-common $ sudo add-apt-repository ppa:certbot/certbot $ sudo apt-get update $ sudo apt-get install python-certbot-nginx 其中, 在 Ubuntu 18.04 執行 sudo add-apt-repository ppa:certbot/certbot 並沒有完成, 但似乎不影響隨後的 python-cerbot-nginx 安裝. 這時為了保留原始 nginx 執行設定 /etc/nginx/sites-available/default, 必須以 sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default_orig 加以保留. 接著透過 $ sudo certbot --nginx 讓 certbot 自動設定所需的 https 連線參數, 即可取得 /etc/letsencrypt/live/cd06.kmol.info/fullchain.pem 與 /etc/letsencrypt/live/cd06.kmol.info/privkey.pem 等兩數位公鑰與私鑰檔案. 完成 certbot 指令後, /etc/nginx/sites-available/default 將會依使用者選擇要從 http 跳轉 https, 或不跳轉, 插入必要的設定修改, 取得數位簽章後, 以 sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/default_cert 儲存 certbot 所修改的 nginx 設定. 接下來則將 /etc/nginx/sites-available/default 恢復為原先的 default_orig 版本, 因為這裡只讓 nginx 佔用 port 80, port 443 仍然必須交還給之前所設定的 Stunnel 服務. nginx 恢復原狀後, 可以利用 /etc/init.d/nginx restart 重新啟動. 而 /etc/stunnel/ 目錄中原有的 localhost.crt 與 localhost.key 改為 localhost_self.crt 與 localhost_self.key, 並從 /etc/letsencrypt/live/cd06.kmol.info/fullchain.pem 與 /etc/letsencrypt/live/cd06.kmol.info/privkey.pem 複製 public signed 的網址數位簽章, 分別複製為 /etc/stunnel/localhost.crt 與 localhost.key 後, 以 /etc/init.d/stunnel4 start 啟動. 假如一切正常, 使用者便可以連線到 https://cd06.kmol.info 與 http://cd06.kmol.info , 前者為 Fossil SCM 加上 Stunnel , 而後者則由 nginx 伺服.","tags":"Misc","url":"https://kmolab.github.io/blog/Collaborative-Design-Laboratory-II.html"},{"title":"協同設計室","text":"2018 年春天, 在電腦輔助設計室旁一間約十坪大小的空間, 成立了所謂的協同設計室, 希望透過多人協力一同, 解決與電腦及網路軟硬體相關問題. Windows 10 的更新之罪 Windows 10 自推出以來, 每一次的更新都掀起論戰, 連最近的 1803 升級, 也不 例外 . 許多網站更教導使用者如何阻止 Windows 10 更新, 因為微軟多多少少藉著更新, 強力放送自家相關產品與服務. 儘管這些置入性行銷不怎麼討喜, 但是從 Windows 7 到目前的 Windows 10, 微軟加諸在這一系列產品的用心, 令人印象深刻, 因此在這個階段, 協同設計室反而建議大家照單全收 Windows 10 的各項網路服務, 再過一段時間, 當大家都明確感受到 AI 人工智慧組態設定的貼心之後, 應該對於 Windows 10 緊密透過網路提供的各項置入性行銷, 就不會再有排拒之想了. 如何與還原卡共存 一旦決定與 Windows 10 的密集更新政策和好, 接下來電腦輔助設計室所面臨的問題是: 該如何與還原卡共存? 理論上, 作為每一學年有將近千人入學的機械工程群, 在新生報到時直接發給一台完整裝載合法套件, 並且至少保用四年的 17 吋筆電, 應該是最理想的規劃, 因為如此, 每一門課都可以沉浸在數位整合環境之中 (意思是學生除了上課滑手機之餘, 還可以滑筆電:-), 只是事與願違, 這個理想與貼在四週牆上的\"禁止使用非法軟體\"標語一樣, 超級與現實脫節 (這一定是玩笑話了). 在無法每位學員人手一台筆電的情況下, 幾乎每一時段都有兩門至四門的必修電腦課程時, 一個系所就必須維護大約 180 台 Windows 10, 總共四間 電腦教室, 而這些電腦都分別使用群準 EVOsys Pro v6 與 UEFI v8 還原卡, 因此接下來的議題是, 為數不少的 Windows 10 電腦該如何與還原卡共存? 除了勤作網路拷貝之外, 目前還找不到答案, 大家不要忘記: 我們已經決定舉雙手, 完全接受微軟 Windows 10 操作系統的各種密集更新! 電腦分類 目前電腦輔助設計室所使用的還原卡為 Evo Pro v6, 採 MBR (Master Boot Record) 分割硬碟, 而協同設計室則使用 Evo UEFI v8, 採用 GPT (GUID Partition Table) 格式分割硬碟. 其中, 電腦輔助設計室的電腦皆為 client, 而協同設計室則有 client 與 Virtualbox 上的 Ubuntu 18.04 LTS (Long Term Support) Server + ubuntu-desktop. 電腦輔助設計室共 65 台電腦的規格為: 華碩 Skylake MD790/I7-6700, Intel 第六代 Core i7/3.4GHz/8M CPU, 採用 Intel Q170 晶片組, 搭載 16GB DDR4/2133/288 Pin 記憶體 (8 GBx2), 2 TB-SATA3 硬碟, Asus MINI-GTX950-2G 顯示卡 (支援 PCIE 3.0, OpenGL 4.5, 768 個CUDA 核心數), 500瓦電源供應器, USB 3.1x2 (10GB/s) , USB 3.0x6 (5GB/s), USB 2.0x2 (480MB/s), 以及 群準的 EVOsys PRO v6 還原卡, 可同時支援 D-sub、HDMI 及 DisplayPort 三台獨立顯示器多工作業. 這批華碩電腦在安裝群準的 EVOsys PRO v6 還原卡之前, 必須先將 Asus UEFI BIOS Utility 中 Boot 功能表下的 secure boot 中的 OS Type, 由內建的 Windows UTFI OS 改為 Other OS, 否則無法在開機後導引到 EVOsys PRO v6 還原卡功能選項. 進入 EVOsys PRO v6 還原卡選項後, 以全新安裝分割硬碟, 一般 Windows 7 與 10 操作系統的資料類別為 A, Ubuntu 選 B, 而 swap 磁區則選擇 P, 分割完成後, 透過 EVOsys 所規劃的開機表單, 選擇 Windows 10 後按下 Enter, 可以進入該硬碟分隔磁區, 但是尚未安裝操作系統, 因此會出現無法開機提示, 這時以 Ctrl+Alt+Del 重新開機後, 可以透過 F8 導引到光碟機開機後進行 Windows 10 操作系統安裝, 這點與 EVOsys UEFI v8 版本功能有明顯差異, 因為 EVOsys UEFI v8 版本提供選擇開機表單中的操作系統選項後, 可以透過 Ctrl+i 執行操作系統安裝, 系統會直接導引到光碟機或 USB 開機選項. 至於協同設計室中的 CD06 電腦充作伺服器使用, 實體操作系統為 Windows 10, 內部則有兩台 Virtualbox 虛擬 Ubuntu 18.04 server + ubuntu-desktop, 虛擬主機與 Windows 10 同步啟動服務採用 vboxvmservice , /etc/netplan 中 IPv6 固定 IP YAML 檔案設定如下: network: ethernets: enp0s3: addresses: - 2001:288:6004:17:0811::cd06/64 gateway6: 2001:288:6004:17::254 nameservers: addresses: - 2001:b000:168::1 version: 2 虛擬 Ubuntu 18.04 中的 Fossil SCM Stunnel 與 Fossil SCM 安裝 sudo apt update sudo apt install stunnel4 -y sudo apt install fossil 環境變數與開機啟動設定 /etc/environment 設定: HTTPS=on /etc/default/stunnel4 檔案設定: ENABLED=1 Stunnel 設定並執行 fossil http 指令 首先在 /etc/stunnel 目錄中建立 localhost.key 與 localhost.crt: sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt /etc/stunnel/stunnel.conf 設定檔案, 可同時支援 IPv4 與 IPv6 協定: [https] accept = your_IPv4_ip:443 accept = :::443 cert = /etc/stunnel/localhost.crt key = /etc/stunnel/localhost.key exec = /usr/bin/fossil execargs = /usr/bin/fossil http /home/cdlab/repository/cdlab.fossil --https --nojail 其中 --nojail 目的在 drop the root privilege but do not enter the chroot jail 重新啟動 stunnel4 則使用 /etc/init.d/stunnel4 restart 建立 cdlab.fossil 則進入 /home/cdlab/repository 目錄後, 執行 fossil init cdlab.fossil 上述設定完成後, 重新開機即可以 https://[2001:288:6004:17:0811::cd06] 連結至 cdlab.fossil 網際管理介面.","tags":"Misc","url":"https://kmolab.github.io/blog/Collaborative-Design-Laboratory.html"},{"title":"編譯 Fossil SCM","text":"在此利用 Msys2 編譯適用於 Windows 10 64 位元環境中的 Fossil SCM. 編譯流程 首先從 Gnuwin32 coreutils 取得視窗環境下執行的 cat 與 grep, 並且確定 sh.exe 位於指令搜尋路徑 (例如, 透過 git/bin 目錄中的 sh.exe), 先編譯 Fossil SCM 附帶的 zlib 後, 再設定 PREFIX = x86_64-w64-mingw32-, 就可順利完成 fossil.exe 的編譯. 在不修改 win/Makefile.mingw 的情況下, 必須與 zlib1.dll 配合才能執行. 若開啟 LIB = -static 設定, 則可以將程式庫納入 fossil.exe 中執行。 取得 fossil clone 原始碼 從 Fossil SCM 倉儲取得原始碼壓縮檔後, 在 wd/fossil 目錄中解開 trunk 最新版本的原始碼, 目前為 Fossil SCM 2.5 版. fossil clone https://www.fossil-scm.org fossil.fossil cd wd mkdir fossil cd fossil fossil open ./../../fossil.fossil 編譯 zlib 在 MSYS2 環境中編譯 Fossil SCM 時, 必須先編譯 compat/zlib cd compat/zlib mingw32-make -f win32/Makefile.gcc 編譯 fossil.exe 之後, 再退出 compat/zlib 目錄, 回到 wd/fossil 目錄中, 編輯 win/Makefile.mingw, 設定 PREFIX = x86_64-w64-mingw32- LIB = -static 接著以 mingw32-make -f win/Makefile.mingw 編譯 fossil.exe 根據以上說明所建立的教學用倉儲位於: https://github.com/kmolab/fossil-scm_25","tags":"Misc","url":"https://kmolab.github.io/blog/msys2_compile_fossil_scm.html"},{"title":"更新 Let's Encrypt 數位簽章","text":"制式的 Let's Encrypt 以安裝 python-certbot-nginx 程式從 certbot 網站取得正式的數位簽章, 然後自動修改原先只有 http 設定的 nginx 網站, 重新啟動後, 就可以讓該網站以 https 連結. 90 天有效期 雖然每次從 certbot 取得的數位簽章只有 90 天效期, 但是 python-certbot-nginx 程式提供了 autorenew 的功能, 使用者可以持續透過自動更新使用由 certbot 提供的數位簽章. 只不過目前在 KMOLab 所使用的網站, 幾乎都以安裝 Fossil SCM 為主, nginx 的功能在於從 http 跳轉到以 Stunnel 啟動的 https, 並且由 Stunnel 啟動程式在內部 IP 傳送 Fossil SCM 的網站資料. 換言之, KMOLab 從 certbot 取得的正式數位簽章並非用於 nginx, 而是轉給 Stunnel 使用. 而目前的 python-certbot-nginx 只能透過 nginx 確認網站合法的 domain name 設定, 因此在修改程式轉為相容 Stunnel 之前, 使用 certbot 的數位簽章, 必須手動進行. 實際操作步驟 首先必須停止 Stunnel 執行: sudo /etc/init.d/stunnel4 stop 接下來停止 nginx 執行: sudo /etc/init.d/nginx stop 接著將目前從 nginx http 跳轉到 Stunnel 啟動的 https 網站設定 /etc/nginx/sites-available/default 改為由 nginx 掌控 https 的 default_certbot 設定. 接著重新啟動 nginx: sudo /etc/init.d/nginx start 然後取得新的數位簽章: sudo certbot renew 所取得的公鑰與私鑰檔案: /etc/letsencrypt/live/mde1a1.kmol.info/cert.pem /etc/letsencrypt/live/mde1a1.kmol.info/privkey.pem 最後將 cert.pem 複製為 /etc/stunnel/localhost.crt, privkey.pem 複製為 /etc/stunnel/localhsot.key 後, 將 /etc/nginx/sites-available/default 換為跳轉為 Stunnel 控管的 default_stunnel, 重新啟動 nginx 與 stunnel, 就可以使用該數位簽章於從 nginx http 跳轉至正式 https 的 Stunnel+Fossil SCM 網站. 其中用來跳轉 https 的 nginx 設定: server { listen 80; server_name mde1a1.kmol.info; rewrite &#94;/(.*)$ https://mde1a1.kmol.info/$1 permanent; } 以 mde2a1.kmol.info 電腦的 certbot 數位簽章更新為例, 命令執行流程如下: sudo /etc/init.d/nginx stop sudo /etc/init.d/stunnel4 stop sudo cp /etc/nginx/sites-available/default_certbot /etc/nginx/sites-available/default sudo /etc/init.d/nginx start sudo certbot renew sudo cp /etc/nginx/sites-available/default_stunnel /etc/nginx/sites-available/default sudo /etc/init.d/nginx restart sudo cp /etc/letsencrypt/live/mde2a1.kmol.info/cert.pem /etc/stunnel/localhost.crt sudo cp /etc/letsencrypt/live/mde2a1.kmol.info/privkey.pem /etc/stunnel/localhost.key sudo /etc/init.d/stunnel4 start","tags":"Misc","url":"https://kmolab.github.io/blog/update_letsencrypt.html"},{"title":"2018 第二季-開始 Lua","text":"會興起將 Lua 導入計算機程式課程, 是因為 V-rep , 因為除了 C/C++ API 外, 標準 API 程式內嵌 (embedded) 與附加 (add-on) 語言, 就是 Lua . 以 Msys2 編譯 Lua 下載 kmol_twigs.7z 後, 解開壓縮檔, 以 start.bat 啟動隨身程式系統. 從 http://www.lua.org/download.html 下載 lua 5.3.4 原始碼. 在隨身系統的命令列中執行 mingw32-make mingw 就可以完成編譯, 取得 lua.exe, luac.exe 與 liblua.a Fengari 專案 fengari-lua 利用 Javascript 改寫 Lua 解譯器後, 在網頁中透過 fengari-web 就可以執行 Lua 程式外, 還能夠導入 js 模組, 使用 Javascript 程式庫中相關物件的方法與屬性. SchoolProject 就是利用 Ace 編輯器與 fengari-web , 讓使用者可以直接在瀏覽器中編輯執行 Lua 程式. vecp2018_lua ( 原始碼 ) 則延續 SchoolProject , 增加了一些功能, 可以用於大一的計算機程式課程中. 令人驚訝的發現 openresty 是一套結合 Nginx 與 Lua 的網際程式平台. 而 lapis 則是架構在 openresty 平台上的網際程式框架, 令人驚訝的發現是, 在如此一個並非十分熱門的平台網站中, 發現 錘子科技 捐了 15 萬美金給 openresty (儘管 過程艱辛 ), 而且 openresty 就是源自中國的開源專案. 相關資訊來自: http://www.infoq.com/cn/articles/what-is-openresty-mentioned-in-smartisan-release-conference .","tags":"Misc","url":"https://kmolab.github.io/blog/starting-lua-2018.html"},{"title":"本站網址改為 lab.kmol.info","text":"目前的網址為 kmolab.github.io, 從今起希望改為 lab.kmol.info DNS 設定 首先必須先在 DNS 伺服器中, 新增 CNAME 類型, 主機選擇 lab, 指向則設為 kmolab.github.io 修改 publishconf.py 接下來必須修改 publishconf.py, 將 SITEURL 設為 'https://kmolab.github.io/blog' Github 倉儲設定 倉儲中新增一個 CNAME 檔案, 內容為 lab.kmol.info, 且進入倉儲 settings 查驗是否 Custom domain 也是設為 lab.kmol.info, 透過以上設定就可以將 http://kmolab.github.io 轉為 http://lab.kmol.info","tags":"Misc","url":"https://kmolab.github.io/blog/use-blog-kmol-info-as-domain-name.html"},{"title":"2017 KMOLab 總結","text":"2017 年的課程在兩個禮拜前結束, KMOLab 也在秋季學期完成了計算機程式與電腦輔助設計實習的課程. 從 PyQt5 事件導向教起 原本只教導基本 Python3 語法的計算機程式課程, 首度以 PyQt5 的物件導向與事件導向為課程主體, 然後讓學員從中了解各種語法的使用時機. 儘管相較於一般工學院科系的計算機程式課程, 從 C++ 或 C 的內容學起, 有很大的差異, 但是出發點在於: 要讓大一的機械設計工程系學生儘快了解, 電腦程式語言該如何應用, 就必須把握機會, 在學生迷失於各種程式語法之前, 設法讓各學員提起更大的學習動機. 這著險棋因為有 Eric6 與 Qt Designer 的協助, 才值得一試, 從基本視窗按鈕元件與 lineEdit 元件的置入, 到對話框布局的配置, 因為都採用 Qt Designer 的滑鼠互動操作, 相信沒有太大的難度, 但是當 .ui XML 檔案轉為 Python3 原始碼之後, 到配合對話框建立與視窗元件互動的程式邏輯編寫, 就在在考驗著每一位程式初學者的耐性與學習動機. 過程中, 利用 PyQt5 建立了一個簡單的電腦輔助設計實習相關的機電系統控制介面程式, 用來控制 V-rep 鋼珠軌道運動模擬系統的視窗程式, 如下列影片所示, 希望以此為例說明在隨後的課程中, 如何使用 PyQt5 程式, 協助完成構想中的機電資產品設計: 上述這個簡單的視窗程式, 與計算機程式中所建立的簡易計算機程式, 非常類似, 僅使用了按鈕與 lineEdit 元件, 且利用 V-rep 的 Python remote API 模式編寫, 最大的教學目標是希望大一計算機程式課程學生, 到了大二上電腦輔助設計實習課程時, 能夠運用 PyQt5 建立監控用的視窗程式, 實際用來控制虛擬的 V-rep 機電系統, 或者是控制根據模擬設計過程所完成的實體系統. 全面採用 Fossil SCM 2017 Fall KMOLab 課程的另外一個特點是, 在兩門課程初期, 利用下列 Python 程式, 為每一位學員建立區域網路 Fossil SCM 主機上的倉儲帳號: import os import string import random # 使用 Gmail 寄信必須導入下列模組 import smtplib import re from email.mime.text import MIMEText from email.header import Header # 用來以亂數建立密碼的函式 def id_generator(size=6, chars=string.ascii_uppercase + string.digits): ''' source: https://stackoverflow.com/questions/2257441/random-string-generation-with-upper-case-letters-and-digits-in-python ''' return ''.join(random.choice(chars) for _ in range(size)) # 讀取學員名單, 逐一取得學員學號, 學員名單, 檢查點 1/7 student_data = open(\"2017fall_list/1b.txt\").read() student_list = student_data.splitlines() # 利用 gmail smtp 功能寄信 server = smtplib.SMTP('smtp.gmail.com:587') server.ehlo() server.starttls() # 以下必須準備好對應郵件帳號與密碼的外部檔案, 所提供的寄信帳號, 是否可以寄信, 檢查點 2/7 ''' 寄信之前必須到 https://www.google.com/settings/security/lesssecureapps 修改權限, 改為較低安全權限 否則無法使用程式寄信! ''' # 從外部檔案讀取要用來寄信的 gmail 帳號與密碼 # mail.txt 格式為: 電子郵箱,對應密碼, 以逗點隔開, 檢查點 3/7 email_data = open(\"z:/2017fall/mail.txt\").read() email, email_password= email_data.split(\",\") print(email, email_password) # 是否登入所提供寄信的電子郵箱, 4/7 server.login(email, email_password) # 不同課程名稱, 與對應主機名稱, 必須配合修改 5/7 course_title = \"計算機程式\" fossil_server = \"cpb.kmol.info\" for student_num in student_list: username = student_num repository = username + '.fossil' # 利用所提供的字串, 以亂數組成六個字元的密碼 password = id_generator(6, \"23456789abcdef\") print(student_num, \", \" , password) # 執行 dos command 指令, 建立倉儲 os.system(\"fossil init -A \" +username + \" \" + repository) print(\"已經建立倉儲 \" + repository) # 執行 dos command 指令, 修改使用者密碼 os.system(\"fossil user password \" + username + \" \" + password + \" -R \" + repository) print(\"已經修改密碼\") # 利用 Gmail 寄信, 告知各學員倉儲連結與帳號密碼 # 每一位學員收到的 output 都從這裡 reset output = \"\" # 若學號欄為空, 則不寄信 if student_num != \"\": # output 為寄給每一位學員的資料表格 mail_content = student_num+' 您好: 您在 '+course_title+' 課程中的區域網路倉儲: https://'+fossil_server+'/'+student_num+' ' mail_content += '管理帳號為:'+ student_num + ' 管理密碼為: '+ password+' ' print(student_num) print(mail_content) # 至此 mail_content 已經確定 # 在測試與實際寄送資料, 也必須配合修改, 檢查點 6/7 receiver_email = student_num + \"@gm.nfu.edu.tw\" # 測試用 #receiver_email = student_num+\"@mde.tw\" # 列出收信人 email 位址 #print(receiver_email) #message= MIMEText(mail_content,'plain','UTF-8') # 以 html 格式寄信 message= MIMEText(mail_content,'html','UTF-8') message['Subject'] = Header(course_title+\" Fossil SCM 帳號通知\", 'UTF-8') # 可以先不寄信, 確定格式正確後再開啟, 是否實際寄出信件, 檢查點 7/7 server.sendmail(\"gmail_address\", receiver_email, message.as_string()) server.quit() 由於先前的 KMOLab 課程, 都是在第一時間就導入 Github 帳號與用法教學, 好處是無需自行維護實體伺服器, 但是缺點則是 Git 的 Windows client 指令依賴一個大約 200 MB 目錄中的許多套件工具, 與初學者的距離較遠, 而 Fossil SCM 的 client 程式只有一個 6MB 的 fossil.exe 檔案, 且若在進階的計算機程式課程中可以直接利用可攜的 MSYS2 視窗環境自行從 Fossil SCM 網站中下載原始碼, 然後自行編譯出內含 https 協定連線的 fossil.exe, 這可以是一位大一機械設計工程系學生自行利用一個 32 GB USB 3.0 隨身碟, 自行打造 Windows 視窗環境下工具的第一步, 因此才從 2017 Fall 開始決定全面導入 Fossil SCM . 另外一個導入 Fossil SCM 的好處是, 其中大量使用 SQLite 的 SQL 語法存取資料 (因為都是由 D. Richard Hipp 建立), 因此也讓學生有機會及早一窺 SQL 語言的用法. 機電資導向的電腦輔助設計實習 過去的電腦輔助設計實習課程, 頂多只是利用機械類電腦輔助設計套件 (例如: PTC Creo, Solidworks, Autodesk Inventor, Siemens NX 或 Simens Solid Edge 等) 建立相關零組件, 或者利用 PTC Creo 應用程式延伸介面中的 Pro/Web.Link 程式架構, 直接在嵌入的 Internet Explorer 瀏覽器中, 進行 Javascript 的程式化參數零組件應用, 雖然可以利用瀏覽器中的 html 表單, 達到設計流程中的網際客製化, 但是隨著 Onshape 在 2015 年起提供教育界免費使用後, 連可以簡單放入隨身碟, 以網路取得認證的 PTC Creo 容量都超過 5GB 來看, 都嫌笨重, 更不用提其他無法輕易放入隨身碟中的固定式機械類電腦輔助設計套件, 在輕薄短小, 敏捷協同過程中所帶來的不便. 因為在一般的機械概念設計初期, 通常需要進行機構的結構設計, 而這些套件卻無法簡易讓初級使用者快速驗證目標機構的可行性, 因此在 2013 年 Solvespace 開源之後, KMOLab 就開始在課程中導入, 動機與採用 Fossil SCM 相同, 使用者可以利用 MSYS2 可攜套件, 在 Windows 10 64 位元環境中, 自行從 C++11 的原始碼編譯出所需的 3.0 版 solvespace.exe, 含執行時所需的 libwinpthread-1.dll 與 d3dcompiler_43.dll, 總容量大約只有 20 MB, 若採用官方以 Visual Studio 編譯的 2.0 版 solvespace.exe, 更只需要約 7 MB, 直接放在隨身碟中, 使用非常方便. 電腦輔助設計實習課程中結合 Solvespace 與 V-rep 的過程可以參考下列影片: 至於結合 Solvespace , Onshape 與 V-rep 的教學影片範例如下: 而實際從設計, 模擬到實體機電系統測試的範例可參考: 從概念轉為知識, 用知識解題 最後, 在 2017 Fall 教學的最後階段, KMOLab 還導入了一項源自法國的 C-K 設計理論 , C 代表 Concept 指設計過程中的許多概念, 而 K 則是 Knowledge, 也就是設計者已經掌握, 可以用來解決問題的知識, 這個設計理論中最重要的概念是, 沒有所謂愚笨或可笑的設計概念, 而應當視為閱聽者在面對這些概念時, 還不具備實現這些概念所需的知識. 簡言之, C-K 設計理論 闡述設計是可以被教導的, 而且可以引用數學原理, 從概念中衍生出更多概念, 將概念轉化為知識, 利用知識推演出更多知識, 同時, 許多知識隨著時空環境的變化, 也可能會轉為概念, 因為已經無法解決當時所面臨的實際問題. 在 C-K 設計理論 的引領下, 任何一個從事機械設計流程的成員, 都不再會因為掌握一些片段知識而自滿, 因為若這些知識沒有持續改進, 未來將無法用來解題, 同時, 初學者也不會因為在協同設計過程中, 擔心提出所謂離譜可笑的概念, 因為理論上所有的概念都可能被實現, 就好像對於一個在數學理論上擁有無限大知識的成員, 就學理上, 根本沒有解決不了的問題, 呵呵, 這確實有些抽象. 歡迎各位來到 2018 年, 一個深度學習與智慧口號滿天的歷史元年, 我們有整整一年的時間來探討, 大家所擁有的所謂深度學習與智慧機械, 到底是概念還是真能用來解決問題的知識.","tags":"Course","url":"https://kmolab.github.io/blog/Year-2017-Conclusion.html"},{"title":"網頁上的數學方程式","text":"利用 Mathjax 可以採 LaTeX 語法，在網頁上編寫數學方程式. 數學方程式 當 $a \\ne 0$, 一元二次方程式 (ax&#94;2 + bx + c = 0) 有兩組解, 可以寫成: $$x = {-b \\pm \\sqrt{b&#94;2-4ac} \\over 2a}.$$ 以上的原始 Markdown 檔案為: 當 $a \\ne 0$, 一元二次方程式 \\(ax&#94;2 + bx + c = 0\\) 有兩組解, 可以寫成: $$x = {-b \\pm \\sqrt{b&#94;2-4ac} \\over 2a}.$$ [Mathjax]:https://www.mathjax.org 機械設計方法與表達 假如您真正將在機械設計工程系所學, 用在解決實務問題, 就會發現整個過程都在與概念及知識混戰, 而概念與知識的交互作用, 正是所謂知識經濟的重要特徵, 概念可以通過驗證而成為知識, 用來解決問題, 而概念可能衍生出更多概念, 當知識在實務執行過程中, 因為各種原因而無法用來解決問題時, 就會轉化成為團隊間的概念, 而特定知識的運用與推演, 更會產生更多有用的知識. 上面與概念及知識相關的說明, 就是來自 C-K 設計理論 . 以上述利用 LaTeX 語法, 在網頁中產生數學方程式的概念, 來自於工程師設計表達過程中的需求, 而這些需求最早的\"知識\", 是將方程式事先做成圖形檔案, 然後再以 img 標註引入網頁, 但是這樣的知識很快受到挑戰, 因為整體流程非常沒有彈性, 並非直接從網頁中的文字\"自動\"轉為可視的數學公式, 因此早先的知識在 Javascript 的置入後, 由使用者編寫 LaTeX 語法, 然後再由程式方法在網頁中即時訂製出所要的數學方程式. 與數學方程式在網頁中的表達需求相同的, 是在網頁中正確引用各種程式碼, 在此我們採用的是舊版的 Syntaxhighlighter , 也是透過 Javascript 解讀所要引用的程式語法, 然後再利用設定顯示出對應的行號. 上述用來顯示四行 LaTeX 方程式與 Markdown 引用網址的原始內容, 就是應用之一. 組成內容與狀態的版次決定一切 當上述引用 Syntaxhighlighter 與 Mathjax 的過程中, 非常重要的一點就是這兩套 Javascript 程式碼, 在不斷更新的情況下, 不同版次的組成內容各不相同, 使用的方法也不一樣, 因此我們說事物組成內容與狀態的版次決定一切, 當許多問題的解決與討論, 在各自不知彼此立足點的組成內容與狀態版次的情況下, 許多無謂紛爭就會發生, 解決方法也比相對難以找到. 以我們目前在使用的 Leo Editor 來說, 可以在 Python2 或 Python3 的環境中使用, 並且需要安裝 PyQt 第四版或第五版模組才能啟動. 但是隨著 Python2 的生命週期即將抵達終點, 而且 Leo Editor 及 PyQt 幾乎隨時都在更動改版中, 因此假如使用者的操作系統、 Leo Editor 、 PyQt 與其他使用者用來建置網頁或程式的所有套件都能\"自動\"感知組成內容, 自動調適狀態, 自動搭配改版, 使用者就能高枕無憂, 永續使用這一系列工具, 問題是整個過程中牽涉到如何收費, 這些工具套件如何正確判斷使用者的需求, 倘若因此造成損失, 該由誰負責\"賠償\"或者恢復原狀, 重點在於哪一個才是原狀? 以過去三十幾年的電腦與網路使用歷程來看, 第一階段的電腦輔助, 從旁協助的角色, 早已提升到自動附加的半自主角色, 例如: Windows 10 的自主更新, 已經無需使用者同意, 眼前能夠想像的是在十年內, 電腦與網路全面自主為人類創造價值的世代, 希望屆時使用者不僅只是整體社會運作的組成元件 , 更是主導運作狀態的發號者.","tags":"Course","url":"https://kmolab.github.io/blog/Math-Equation-On-Web-Page.html"},{"title":"Cango Javascript 程式庫繪圖","text":"利用 Cango 與 Brython 進行網際繪圖 window.onload=function(){ brython({debug:1, pythonpath:['./../data/py']}); } function doSave(storage_id, filename){ var blob = new Blob([localStorage[storage_id]], {type: \"text/plain;charset=utf-8\"}); filename = document.getElementById(filename).value saveAs(blob, filename+\".py\"); } from browser import alert from browser import window import math # Javascript 物件 cango = window.Cango.new path = window.Path.new shape = window.Shape.new # Javascript 變數 shapedefs = window.shapeDefs cgo = cango(\"plotarea\") cgo.gridboxPadding(10, 10, 5, 7) # 設定座標系統 # cgo.setWorldCoordsRHC(xmin, ymin, xmax-xmin); cgo.setWorldCoordsRHC(-40, -50, 800, 300) # 畫軸線 cgo.drawAxes(-40, 750, -80, 710, { 'xOrigin':0, 'yOrigin':0, \"strokeColor\":\"#aaaaaa\", \"fillColor\": \"#aaaaaa\", \"xTickInterval\": 40, \"xLabelInterval\": 40, \"yTickInterval\": 40, \"yLabelInterval\": 40}) deg = math.pi/180 # 將繪製鏈條輪廓的內容寫成 class 物件 class chain(): # 輪廓的外型設為成員變數 chamber = \"M -6.8397, -1.4894 \\ A 7, 7, 0, 1, 0, 6.8397, -1.4894 \\ A 40, 40, 0, 0, 1, 6.8397, -18.511 \\ A 7, 7, 0, 1, 0, -6.8397, -18.511 \\ A 40, 40, 0, 0, 1, -6.8397, -1.4894 z\" cgoChamber = window.svgToCgo2D(chamber) # 利用鏈條起點與終點定義繪圖, 使用內定的 color, border 與 linewidth 變數 def basic(self, x1, y1, x2, y2, color=\"green\", border=True, linewidth=4, scale=3): self.x1 = x1 self.y1 = y1 self.x2 = x2 self.y2 = y2 self.color = color self.border = border self.linewidth = linewidth self.scale = scale # 注意, cgoChamber 為成員變數 # 新的 shape 物件函式 cmbr = shape(self.cgoChamber, { \"fillColor\": self.color, \"border\": self.border, \"strokeColor\": \"tan\", \"lineWidth\": self.linewidth }) # hole 為原點位置 # 新的 path 函式 hole = path(shapedefs.circle(4)) cmbr.appendPath(hole) # 複製 cmbr, 然後命名為 basic1 basic1 = cmbr.dup() # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角 basic1.rotate(math.atan2(self.y2-self.y1, self.x2-self.x1)/deg-90) # 放大 scale 倍 basic1.translate(self.x1, self.y1) basic1.scale(self.scale) cgo.render(basic1,False) # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數 def basic_rot(self, x1, y1, rot, color=\"green\", border=True, linewidth=4, scale=3): self.x1 = x1 self.y1 = y1 self.rot = rot self.color = color self.border = border self.linewidth = linewidth self.scale = scale # 注意, cgoChamber 為成員變數 cmbr = shape(self.cgoChamber, { \"fillColor\": self.color, \"border\": self.border, \"strokeColor\": \"tan\", \"lineWidth\": self.linewidth }) # hole 為原點位置 hole = path(shapedefs.circle(4)) cmbr.appendPath(hole) # 根據旋轉角度, 計算 x2 與 y2 x2 = self.x1 + 20*math.cos(self.rot*deg) y2 = self.y1 + 20*math.sin(self.rot*deg) # 複製 cmbr, 然後命名為 basic1 basic1 = cmbr.dup() # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量轉角 basic1.rotate(self.rot-90) # 放大 scale 倍 basic1.translate(self.x1, self.y1) basic1.scale(self.scale) cgo.render(basic1, False) return x2, y2 # 利用 chain class 建立案例, 對應到 mychain 變數 mychain = chain() # 畫 A # 左邊兩個垂直單元 x1, y1 = mychain.basic_rot(0, 0, 90) x2, y2 = mychain.basic_rot(x1, y1, 90) # 左斜邊兩個單元 x3, y3 = mychain.basic_rot(x2, y2, 80) x4, y4 = mychain.basic_rot(x3, y3, 71) # 最上方水平單元 x5, y5 = mychain.basic_rot(x4, y4, 0) # 右斜邊兩個單元 x6, y6 = mychain.basic_rot(x5, y5, -71) x7, y7 = mychain.basic_rot(x6, y6, -80) # 右邊兩個垂直單元 x8, y8 = mychain.basic_rot(x7, y7, -90) x9, y9 = mychain.basic_rot(x8, y8, -90) # 中間兩個水平單元 x10, y10 = mychain.basic_rot(x8, y8, -180) mychain.basic(x10, y10, x1, y1, color=\"red\") # 畫 B # 左邊四個垂直單元 x1, y1 = mychain.basic_rot(0+ 65, 0, 90) x2, y2 = mychain.basic_rot(x1, y1, 90) x3, y3 = mychain.basic_rot(x2, y2, 90) x4, y4 = mychain.basic_rot(x3, y3, 90) # 上方一個水平單元 x5, y5 = mychain.basic_rot(x4, y4, 0) # 右斜 -30 度 x6, y6 = mychain.basic_rot(x5, y5, -30) # 右上垂直向下單元 x7, y7 = mychain.basic_rot(x6, y6, -90) # 右斜 240 度 x8, y8 = mychain.basic_rot(x7, y7, 210) # 中間水平 mychain.basic(x8, y8, x2, y2) # 右下斜 -30 度 x10, y10 = mychain.basic_rot(x8, y8, -30) # 右下垂直向下單元 x11, y11 = mychain.basic_rot(x10, y10, -90) # 右下斜 240 度 x12, y12 = mychain.basic_rot(x11, y11, 210) # 水平接回起點 mychain.basic(x12,y12, 0, 0, color=\"red\") # 畫 C # 上半部 # 左邊中間垂直起點, 圓心位於線段中央, y 方向再向上平移兩個鏈條圓心距單位 x1, y1 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), 90) # 上方轉 80 度 x2, y2 = mychain.basic_rot(x1, y1, 80) # 上方轉 30 度 x3, y3 = mychain.basic_rot(x2, y2, 30) # 上方水平 x4, y4 = mychain.basic_rot(x3, y3, 0) # 下半部, 從起點開始 -80 度 x5, y5 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), -80) # 下斜 -30 度 x6, y6 = mychain.basic_rot(x5, y5, -30) # 下方水平單元 x7, y7 = mychain.basic_rot(x6, y6, -0, color=\"red\") # 畫 D # 左邊四個垂直單元 x1, y1 = mychain.basic_rot(0+65*3, 0, 90) x2, y2 = mychain.basic_rot(x1, y1, 90) x3, y3 = mychain.basic_rot(x2, y2, 90) x4, y4 = mychain.basic_rot(x3, y3, 90) # 上方一個水平單元 x5, y5 = mychain.basic_rot(x4, y4, 0) # 右斜 -40 度 x6, y6 = mychain.basic_rot(x5, y5, -40) x7, y7 = mychain.basic_rot(x6, y6, -70) # 右中垂直向下單元 x8, y8 = mychain.basic_rot(x7, y7, -90) # -110 度 x9, y9 = mychain.basic_rot(x8, y8, -100) # -150 x10, y10 = mychain.basic_rot(x9, y9, -150) # 水平接回原點 mychain.basic(x10, y10, 0+65*3, 0, color=\"red\") from browser import document as doc import ace # Brython 3.3.4 內建的 container 名稱為 'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id Ace = ace.Editor(editor_id=\"can1_editor\", console_id=\"can1_console\", container_id=\"can1_container\", storage_id=\"can1_py_src\" ) Ace.editor.setValue('''#Cango 繪圖 from browser import window import math cos30 = math.cos(30*math.pi/180) sin30 = math.sin(30*math.pi/180) # Javascript 物件 cango = window.Cango.new path = window.Path.new shape = window.Shape.new # Javascript 變數 shapedefs = window.shapeDefs g1 = cango(\"can1_container\") g1.clearCanvas() g1.gridboxPadding(10, 10, 5, 7) g1.fillGridbox(\"lightgreen\") g1.setWorldCoordsRHC(0, 0, 80) g1.drawText(\"gc.setWorldCoordsRHC() 設為 Y 向上為正\", {'x':3, 'y':52, 'fontSize': 30, 'fillColor':\"black\"}) g1.drawText(\"X\", {'x':60, 'y':2, 'fontSize': 30, 'fontWeight': 800, 'lorg': 9, 'fillColor': \"black\"}); g1.drawText(\"Y\", {'x':2, 'y':30, 'fontSize': 30, 'fontWeight': 800, 'lorg': 1, 'fillColor': \"black\"}); g1.drawArrow(60, 0, {'shaftWidth':2.5, 'fillColor':'black'}); g1.drawArrow(0, 30, {'shaftWidth':2.5, 'fillColor':'black'}); g1.drawPath([\"M\", 0,0, \"L\", 35*cos30, 35*sin30, 0, 0]); g1.drawArrowArc(25, 0, 30, {'clockwise':False, 'shaftWidth':2.5, 'fillColor':'black'}); ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['can1_run'].bind('click', Ace.run) doc['can1_show_console'].bind('click', Ace.show_console) doc['can1_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 from browser import document as doc import ace # Brython 3.3.4 內建的 container 名稱為 'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id Ace = ace.Editor(editor_id=\"can2_editor\", console_id=\"can2_console\", container_id=\"can2_container\", storage_id=\"can2_py_src\" ) Ace.editor.setValue('''#Cango 繪圖 from browser import window import math cos30 = math.cos(30*math.pi/180) sin30 = math.sin(30*math.pi/180) # Javascript 物件 cango = window.Cango.new path = window.Path.new shape = window.Shape.new # Javascript 變數 shapedefs = window.shapeDefs g1 = cango(\"can2_container\") g1.clearCanvas() g1.gridboxPadding(10, 10, 5, 7) g1.fillGridbox(\"lightpink\") g1.setWorldCoordsSVG(0, 0, 100) g1.drawText(\"gc.setWorldCoordsSVG() 設為 Y 向下為正\", {'x':2, 'y':-6, 'fontSize': 30, 'fillColor':\"black\"}) g1.drawText(\"X\", {'x':60, 'y':2, 'fontSize': 30, 'fontWeight': 800, 'lorg': 3, 'fillColor': \"black\"}); g1.drawText(\"Y\", {'x':2, 'y':30, 'fontSize': 30, 'fontWeight': 800, 'lorg': 7, 'fillColor': \"black\"}); g1.drawArrow(60, 0, {'shaftWidth':2.5, 'fillColor':'black'}); g1.drawArrow(0, 30, {'shaftWidth':2.5, 'fillColor':'black'}); g1.drawPath([\"M\", 0,0, \"L\", 35*cos30, 35*sin30, 0, 0]); g1.drawArrowArc(25, 0, 30, {'clockwise':False, 'shaftWidth':2.5, 'fillColor':'black'}); ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['can2_run'].bind('click', Ace.run) doc['can2_show_console'].bind('click', Ace.show_console) doc['can2_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 from browser import document as doc import ace # Brython 3.3.4 內建的 container 名稱為 'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id Ace = ace.Editor(editor_id=\"can3_editor\", console_id=\"can3_console\", container_id=\"can3_container\", storage_id=\"can3_py_src\" ) Ace.editor.setValue('''#Cango Bezier 繪圖 from browser import window # Javascript 物件 cango = window.Cango.new path = window.Path.new shape = window.Shape.new group = window.Group.new # Javascript 變數 shapedefs = window.shapeDefs g1 = cango(\"can3_container\") g1.clearCanvas() g1.gridboxPadding(10, 10, 5, 7) g1.fillGridbox(\"lightgreen\") g1.setWorldCoordsRHC(-100, -100, 400) x1 = 40 y1 = 20 cx1 = 90 cy1 = 120 x2 = 120 y2 = 100 cx2 = 130 cy2 = 20 cx3 = 150 cy3 = 120 x3 = 180 y3 = 60 def dragC1(mousePos): global cx1, cy1 cx1 = mousePos.x cy1 = mousePos.y drawCurve() def dragC2(mousePos): global cx2, cy2 cx2 = mousePos.x cy2 = mousePos.y drawCurve() def dragC3(mousePos): global cx3, cy3 cx3 = mousePos.x cy3 = mousePos.y drawCurve() def drawCurve(): qbez = path(['M', x1, y1, 'Q', cx1, cy1, x2, y2], { 'strokeColor':'blue'}) cbez = path(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], { 'strokeColor':'green'}) L1 = path(['M', x1, y1, 'L', cx1, cy1, x2, y2], { 'strokeColor':\"rgba(0, 0, 0, 0.2)\", 'dashed':[4]}) L2 = path(['M', x2, y2, 'L', cx2, cy2], { 'strokeColor':\"rgba(0, 0, 0, 0.2)\", 'dashed':[4]}) L3 = path(['M', x3, y3, 'L', cx3, cy3], { 'strokeColor':\"rgba(0, 0, 0, 0.2)\", 'dashed':[4]}) c1.transform.translate(cx1, cy1) c2.transform.translate(cx2, cy2) c3.transform.translate(cx3, cy3) grp = group(qbez, cbez, L1, L2, L3, c1, c2, c3) g1.render(grp, True) g1.clearCanvas(\"lightyellow\") g1.deleteAllLayers() g1.setWorldCoordsRHC(0, 0, 200) c1 = shape(shapedefs.circle(6), {'fillColor':'red'}) c1.enableDrag(None, dragC1, None) c2 = shape(shapedefs.circle(6), {'fillColor':'red'}) c2.enableDrag(None, dragC2, None) c3 = shape(shapedefs.circle(6), {'fillColor':'red'}) c3.enableDrag(None, dragC3, None); drawCurve() ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['can3_run'].bind('click', Ace.run) doc['can3_show_console'].bind('click', Ace.show_console) doc['can3_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除","tags":"Course","url":"https://kmolab.github.io/blog/cango-brython-svg-canvas.html"},{"title":"Brython 3.3.4 程式環境","text":"利用 Brython 與 Ace 編輯器, 建立瀏覽器上的簡單 Python3 程式練習環境. canvas { border: 1px solid black; } window.onload=function(){ brython({debug:1, pythonpath:['./../data/py']}); } function doSave(storage_id, filename){ var blob = new Blob([localStorage[storage_id]], {type: \"text/plain;charset=utf-8\"}); filename = document.getElementById(filename).value saveAs(blob, filename+\".py\"); } 編寫 Python3 程式邏輯之前必須先了解基本的程式語法, 其中包括: Python3 變數命名規則與關鍵字 Python 英文變數命名規格 變數必須以英文字母大寫或小寫或底線開頭 變數其餘字元可以是英文大小寫字母, 數字或底線 變數區分英文大小寫 變數不限字元長度 不可使用關鍵字當作變數名稱 使用者可以利用以下程式列出所使用 Python 的版次與關鍵字: from browser import document as doc import ace # Brython 3.3.4 內建的 container 名稱為 'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id Ace = ace.Editor(editor_id=\"kw_editor\", console_id=\"kw_console\", container_id=\"kw__container\", storage_id=\"kw_py_src\" ) Ace.editor.setValue('''# 導入 sys 模組 import sys # 導入 keyword 模組 import keyword # 利用 sys 模組中的 version_info 印出 Python 版次 print(\"Python version: \", sys.version_info) # 利用 keyword 模組中的 kwlist 印出關鍵字 print(\"Python keywords: \", keyword.kwlist) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['kw_run'].bind('click', Ace.run) doc['kw_show_console'].bind('click', Ace.show_console) doc['kw_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 Python3 的程式關鍵字, 使用者命名變數時, 必須避開下列保留字. Python keywords: ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 選擇好的變數名稱: 使用有意義且適當長度的變數名稱， 例如: 使用 length 代表長度, 不要單獨使用 l 或 L, 也不要使用 this_is_the_length 程式前後變數命名方式盡量一致, 例如: 使用 rect_length 或 RectLength 用底線開頭的變數通常具有特殊意義 print() 函式用法 print() 為 Python 程式語言中用來列印數值或字串的函式, 其中有 sep 變數定義分隔符號, ｓep 內定為 \",\", end 變數則用來定義列印結尾的符號, end 內定為跳行符號. for 迴圈用法與 Python 的縮排規定 重複迴圈用法, 使用者可以透過下列程式編輯區練習 for 迴圈與 print() 函式的用法. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"editor\", console_id=\"console\", container_id=\"first_container\", storage_id=\"py_src\" ) Ace.editor.setValue('''#ex1 簡單的 for 迴圈範例 for i in range(10): print(i) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['run'].bind('click', Ace.run) doc['show_console'].bind('click', Ace.show_console) doc['clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 下列的 Brython turtle 網際繪圖程式僅提供參考, 可以用來練習 Python3 程式語法. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"turtle_editor\", console_id=\"turtle_console\", container_id=\"container\", storage_id=\"turtle_py_src\" ) Ace.editor.setValue('''import turtle t=turtle.Turtle() t.penup() t.left(45) t.backward(125) t.right(45) t.pendown() for c in ['red', 'green', 'yellow', 'blue']: t.color(c) t.forward(75) t.left(90) t1=turtle.Turtle(\"turtle\") t1.penup() t1.pendown() t1.width(3) for c in ['red', 'blue', 'yellow', 'green', 'purple', 'brown']: t1.color(c) t1.forward(50) t1.left(60) t1.penup() t1.left(60) t1.backward(120) t1.pendown() t1.color('red') t1.write(\"I love Brython!!\") turtle._Screen().end() ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) doc['turtle_run'].bind('click', Ace.run) doc['turtle_show_console'].bind('click', Ace.show_console) doc['turtle_clear_console'].bind('click', Ace.clear_console) doc['turtle_clear_container'].bind('click', Ace.clear_container) Filename: .py Run Output 清除 清除畫布 函式用法與呼叫 使用者可以利用下列程式, 練習 def 函式定義與呼叫的用法. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"fun_editor\", console_id=\"fun_console\", container_id=\"fun_container\", storage_id=\"fun_py_src\" ) Ace.editor.setValue('''# 定義函式 def square_of_x(x): return x*x # 呼叫函式 y = square_of_x(3) # 列印 y 對應內容 print(y) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['fun_run'].bind('click', Ace.run) doc['fun_show_console'].bind('click', Ace.show_console) doc['fun_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 以下網際繪圖程式, 僅提供參考. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"by_editor\", console_id=\"by_console\", container_id=\"by_container\", storage_id=\"by_py_src\" ) Ace.editor.setValue('''# First of all, the import of some libraries from browser import document as doc from browser import html # All the elements will be inserted in the div with the \"container\" id container = doc['by_container'] # We create a new div element newdiv = html.DIV(id = \"new-div\") # Now we add some style newdiv.style = {\"padding\": \"5px\", \"backgroundColor\": \"#ADD8E6\"} # Now, lets add a table with a column with numbers and a # column with a word on each cell text = \"Brython is really cool\" textlist = text.split() table = html.TABLE() for i, word in enumerate(textlist): table <= html.TR(html.TD(i + 1) + html.TD(word)) # Now we add some style to the table table.style = {\"padding\": \"5px\", \"backgroundColor\": \"#aaaaaa\", \"width\": \"100%\"} # Now we add the table to the new div previously created newdiv <= table + html.BR() # a form? why not? form = html.FORM() input1 = html.INPUT(type=\"text\", name=\"firstname\", value=\"First name\") input2 = html.INPUT(type=\"text\", name=\"lastname\", value=\"Last name\") input3 = html.BUTTON(\"Button with no action!\") form <= input1 + html.BR() + input2 + html.BR() + input3 newdiv <= form + html.BR() # Finally, we will add something more 'HTML5istic', a canvas with # a color gradient in the newdiv previously created and below the form canvas = html.CANVAS(width = 300, height = 300) #canvas.style = {\"width\": \"100%\"} ctx = canvas.getContext('2d') ctx.rect(0, 0, 300, 300) grd = ctx.createRadialGradient(150, 150, 10, 150, 150, 150) grd.addColorStop(0, '#8ED6FF') grd.addColorStop(1, '#004CB3') ctx.fillStyle = grd ctx.fill() newdiv <= canvas # And finally we append the newdiv element # to the parent, in this case the div with the \"container\" id container <= newdiv ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['by_run'].bind('click', Ace.run) doc['by_show_console'].bind('click', Ace.show_console) doc['by_clear_console'].bind('click', Ace.clear_console) doc['by_clear_container'].bind('click', Ace.clear_container) Filename: .py Run Output 清除 清除畫布 以下網際動態繪圖程式, 僅提供參考. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"clock_editor\", console_id=\"clock_console\", container_id=\"clock_container\", storage_id=\"clock_py_src\" ) Ace.editor.setValue('''# First of all, the import of some libraries import time import math import datetime from browser import document as doc import browser.timer from browser import html sin,cos = math.sin,math.cos width,height = 250,250 # canvas dimensions ray = 100 # clock ray # All the elements will be inserted in the div with the \"container\" id container = doc['clock_container'] # We create a new div element newdiv = html.DIV(id = \"new-div\") # Now we add some style newdiv.style = {\"padding\": \"5px\", \"backgroundColor\": \"#ADD8E6\"} canvas = html.CANVAS(width = width, height = height) #canvas.style = {\"width\": \"100%\"} ctx = canvas.getContext('2d') def needle(angle,r1,r2,color=\"#000000\"): # draw a needle at specified angle in specified color # r1 and r2 are percentages of clock ray x1 = width/2-ray*cos(angle)*r1 y1 = height/2-ray*sin(angle)*r1 x2 = width/2+ray*cos(angle)*r2 y2 = height/2+ray*sin(angle)*r2 ctx.beginPath() ctx.strokeStyle = color ctx.moveTo(x1,y1) ctx.lineTo(x2,y2) ctx.stroke() def set_clock(): # erase clock ctx.beginPath() ctx.fillStyle = \"#FFF\" ctx.arc(width/2,height/2,ray*0.89,0,2*math.pi) ctx.fill() # redraw hours show_hours() # print day now = datetime.datetime.now() day = now.day ctx.font = \"bold 14px Arial\" ctx.textAlign = \"center\" ctx.textBaseline = \"middle\" ctx.fillStyle=\"#FFF\" ctx.fillText(day,width*0.7,height*0.5) # draw needles for hour, minute, seconds ctx.lineWidth = 3 hour = now.hour%12 + now.minute/60 angle = hour*2*math.pi/12 - math.pi/2 needle(angle,0.05,0.5) minute = now.minute angle = minute*2*math.pi/60 - math.pi/2 needle(angle,0.05,0.85) ctx.lineWidth = 1 second = now.second+now.microsecond/1000000 angle = second*2*math.pi/60 - math.pi/2 needle(angle,0.05,0.85,\"#FF0000\") # in red browser.timer.set_interval(set_clock,100) ctx.beginPath() ctx.lineWidth = 10 ctx.arc(width/2,height/2,ray,0,2*math.pi) ctx.stroke() for i in range(60): ctx.lineWidth = 1 if i%5 == 0: ctx.lineWidth = 3 angle = i*2*math.pi/60 - math.pi/3 x1 = width/2+ray*cos(angle) y1 = height/2+ray*sin(angle) x2 = width/2+ray*cos(angle)*0.9 y2 = height/2+ray*sin(angle)*0.9 ctx.beginPath() ctx.moveTo(x1,y1) ctx.lineTo(x2,y2) ctx.stroke() def show_hours(): ctx.beginPath() ctx.arc(width/2,height/2,ray*0.05,0,2*math.pi) ctx.fillStyle = \"#000\" ctx.fill() for i in range(1,13): angle = i*math.pi/6-math.pi/2 x3 = width/2+ray*cos(angle)*0.75 y3 = height/2+ray*sin(angle)*0.75 ctx.font = \"20px Arial\" ctx.textAlign = \"center\" ctx.textBaseline = \"middle\" ctx.fillText(i,x3,y3) # cell for day ctx.fillStyle = \"#000\" ctx.fillRect(width*0.65,height*0.47,width*0.1,height*0.06) show_hours() set_clock() newdiv <= canvas # And finally we append the newdiv element # to the parent, in this case the div with the \"container\" id container <= newdiv ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['clock_run'].bind('click', Ace.run) doc['clock_show_console'].bind('click', Ace.show_console) doc['clock_clear_console'].bind('click', Ace.clear_console) doc['clock_clear_container'].bind('click', Ace.clear_container) Filename: .py Run Output 清除 清除畫布 基本物件導向與案例 Python 採用類別 (class) 將案例變數 (instance variables) 與案例方法 (instance methods) 包在一起, 並用來定義一種物件 (object). 物件導向具有封裝 (encapsulation) , 繼承 (inheritance) 與多形 ( polymorphism) 等三種特性. 使用者可以利用下列程式練習 Python3 物件的定義與應用. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"oop1_editor\", console_id=\"oop1_console\", container_id=\"oop1_container\", storage_id=\"oop1_py_src\" ) Ace.editor.setValue('''# Robot class 定義 class Robot(object): def __init__(self, name, by): self._name = name self._build_year = by @property def name(self): return self._name @name.setter def name(self, newname): self._name = name @property def build_year(self): return self._build_year @build_year.setter def build_year(self, newby): self._build_year = newby x = Robot(\"bob\", 1993) x.build_year = 1993 print(x.name) print(x.build_year) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['oop1_run'].bind('click', Ace.run) doc['oop1_show_console'].bind('click', Ace.show_console) doc['oop1_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 以下平面機構動態模擬程式, 僅提供參考. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"link_editor\", console_id=\"link_console\", container_id=\"fourbar\", storage_id=\"link_py_src\" ) Ace.editor.setValue('''# 導入所需模組 from browser import document as doc from browser import window from browser import timer from browser import html import math # 利用 window 擷取 PrairieDraw 程式庫變數物件, 然後以 new 方法轉為 Brython 變數 pdraw = window.PrairieDraw.new # 利用 window 擷取 PrairieDrawAnim 程式庫變數物件, 然後以 new 方法轉為 Brython 變數 PrairieDrawAnim = window.PrairieDrawAnim.new # 利用 window 擷取 sylvester 程式庫變數物件 Vector, 並將其 create 方法直接轉為 Brython 變數 # 在 sylvester 中的 $V 簡化變數無法直接在 Brython 程式中引用 vector = window.Vector.create # 在 \"fourbar\" 畫布中建立 panim 動態模擬案例 panim = PrairieDrawAnim(\"fourbar\") # 平面連桿繪圖以 t = 0 起始 t = 0 # 控制轉動方向變數 direction = True # 繪製不同 t 時間下的平面連桿 def draw(): global t, direction, fast # 設定模擬繪圖範圍 panim.setUnits(6, 6) # 設定箭頭線寬 panim.setProp(\"arrowLineWidthPx\",2) # 起始變數設定 omega = 1 length_bar1 = 1 length_bar2 = 26/18 length_bar3 = 2 length_base = 40/18 time = 0 # 畫出地面直線 G = vector([0, -0.5]) panim.ground(G, vector([0, 1]), 10) # 連桿長度與角度計算 A = t*omega # \"theta\" AD = length_bar1 #length of left bar AB = length_base #distance between two stationary pivots BC = length_bar3 #length of right bar CD = length_bar2 #length of middle bar BD = math.sqrt(AD*AD + AB*AB - 2*AD*AB*math.cos(A)) C = math.acos((BC*BC + CD*CD - BD*BD)/(2*BC*CD)) ABD = math.asin(CD * math.sin(C) / BD) DBC = math.asin(AD * math.sin(A) / BD) B = ABD + DBC D = math.pi - B - C # draw pivot pivot_left = vector([AB/-2, 0]) pivot_right = vector([AB/2, 0]) panim.pivot(vector([pivot_left.e(1), -0.5]), pivot_left, 0.5) panim.pivot(vector([pivot_right.e(1), -0.5]), pivot_right, 0.5) # 儲存轉換矩陣 panim.save() #FIRST BAR panim.translate(pivot_left) panim.rotate(A) panim.rod(vector([0,0]), vector([AD,0]), 0.25) panim.point(vector([0,0])) #SECOND BAR panim.translate(vector([AD,0])) panim.rotate(A*-1) #\"undo\" the original A rotation panim.rotate(D) #rotate by D only panim.rod(vector([0,0]), vector([CD,0]), 0.25) panim.point(vector([0,0])) #THIRD BAR panim.translate(vector([CD,0])) panim.rotate(math.pi+C) panim.rod(vector([0,0]), vector([BC,0]), 0.25) panim.point(vector([0,0])) # 回復原先的轉換矩陣 panim.restore() panim.point(vector([pivot_right.e(1), 0])) # 時間增量 if direction == True: t += 0.08 else: t += -0.08 # 先畫出 t = 0 的連桿機構 draw() # 將 anim 設為 None anim = None def launchAnimation(ev): global anim # 初始啟動, anim 為 None if anim is None: # 每 0.08 秒執行一次 draw 函式繪圖 anim = timer.set_interval(draw, 80) # 初始啟動後, 按鈕文字轉為\"暫停\" doc['power'].text = '暫停' elif anim == 'hold': # 當 anim 為 'hold' 表示曾經暫停後的啟動, 因此持續以 set_interval() 持續旋轉, 且將 power 文字轉為\"暫停\" anim = timer.set_interval(draw, 80) doc['power'].text = '暫停' else: # 初始啟動後, 使用者再按 power, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停 # 且將 anim 變數設為 'hold', 且 power 文字轉為\"繼續\" timer.clear_interval(anim) anim = 'hold' doc['power'].text = '繼續' def reverse(ev): global anim, direction # 當 anim 為 hold 時, 按鈕無效 if anim != \"hold\": if direction == True: direction = False else: direction = True doc[\"power\"].bind(\"click\", launchAnimation) doc[\"reverse\"].bind(\"click\", reverse) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['link_run'].bind('click', Ace.run) doc['link_show_console'].bind('click', Ace.show_console) doc['link_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 啟動 反向 平面機構運動模擬 以下為 Jansen's 八連桿機構的基本 Kinematic 運算, 先採用 Sympy 以符號式推導出機構端點的運動軌跡方程式後, 利用 Python 執行數值分析運算, 列出機構端點的座標. from browser import document as doc # 表示要導入 data/py/ace.py import ace Ace = ace.Editor(editor_id=\"jansen_editor\", console_id=\"jansen_console\", container_id=\"jansen_container\", storage_id=\"jansen_py_src\" ) Ace.editor.setValue('''#jansen 多連桿機構驗算 from math import pi, cos, sin, sqrt, acos radian = 180/pi degree = pi/180 #PLAP def plap(ax, ay, ac, bac, bx, by, ccw): if ccw == 1: cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay else: cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay return cx, cy #PLLP def pllp(ax, ay, ac, cb, bx, by, cw): if cw == 1: cx = -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) cy = (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) else: cx = -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) cy = (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) return cx, cy ax = -38 ay = 0 # b 為原點 bx = 0 by = 0 cx = 0 cy = 7.8 # m 為配合 PLAP 新增固定點 mx = 30 my = 7.8 # dcm ccw 方向角度 dcm = 30*degree cd = 15 # 三角形 dcm 為 ccw plap d=(a, cd, dcm, m) dx, dy = plap(cx, cy, cd, dcm, mx, my, ccw=1) print(\"dx=\", dx, \"dy=\", dy) # 三角形 aed 為 cw pllp e=(a, ae, ed, d) ae = 41.5 ed = 50 ex, ey = pllp(ax, ay, ae, ed, dx, dy, cw=1) print(\"ex=\", ex, \"ey=\", ey) # 三角形 afe 為 cw pllp f=(a, af, fe, e) af = 40.1 fe = 55.8 fx, fy = pllp(ax, ay, af, fe, ex, ey, cw=1) print(\"fx=\", fx, \"fy=\", fy) # 三角形 dha 為 cw pllp h=(d, dh, ha, a) dh = 61.9 ha = 39.3 hx, hy = pllp(dx, dy, dh, ha, ax, ay, cw=1) print(\"hx=\", hx, \"hy=\", hy) # 三角形 hgf 為 cw pllp g=(h, hg, gf, f) hg = 36.7 gf = 39.4 gx, gy = pllp(hx, hy, hg, gf, fx, fy, cw=1) print(\"gx=\", gx, \"gy=\", gy) # 三角形 hkg 為 cw pllp k=(h, hk, kg, g) hk = 49 kg = 65.7 kx, ky = pllp(hx, hy, hk, kg, gx, gy, cw=1) print(\"kx=\", kx, \"ky=\", ky) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['jansen_run'].bind('click', Ace.run) doc['jansen_show_console'].bind('click', Ace.show_console) doc['jansen_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 以下為與上述 Jansen's 八連桿機構對應的座標驗證圖, 機構端點座標 kx= -30.81 ky= -84.02: 平面機構數目合成 itertools module implements a number of iterator building blocks. itertools.product(*iterables, repeat=1) - Cartesian product of input iterables. 根據 http://www.iftomm2015.tw/IFToMM2015CD/PDF/OS2-048.pdf (or local download ) from browser import document as doc # 表示要導入 data/py/ace.py import ace Ace = ace.Editor(editor_id=\"numsyn_editor\", console_id=\"numsyn_console\", container_id=\"numsyn_container\", storage_id=\"numsyn_py_src\" ) Ace.editor.setValue('''#數目合成 from itertools import product # NL links and NJ joints as inputs class NumberSynthesis: def __init__(self, NL, NJ): self.NL = NL self.NJ = NJ @property def Mmax(self): if self.NL <= self.NJ and self.NJ <= (2*self.NL-3): return self.NJ - self.NL + 2 elif (2*self.NL-3) <= self.NJ and self.NJ <= (self.NL*(self.NL-1)/2): return self.NL - 1 else: raise ValueError(\"incorrect number.\") @property def NLm(self): result = [] correction = lambda l: sum((i+2)*l[i] for i in range(len(l))) == 2*self.NJ for symbols in product(range(self.NL+1), repeat=self.Mmax-2): NLMmax = self.NL - sum(symbols) answer = symbols+(NLMmax,) if correction(answer) and NLMmax>=0: result.append(answer) return tuple(result) a = NumberSynthesis(9, 11) print(\"the maximum number of joints incident to a link: \", a.Mmax) print(\"link assortments of the generalized kinematic chains: \", a.NLm) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['numsyn_run'].bind('click', Ace.run) doc['numsyn_show_console'].bind('click', Ace.show_console) doc['numsyn_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 目前所在頁面, 分別利用 Brython 與 Ace 編輯器, 可直接在網誌中執行 Python3 程式, 基本架構為將 Brython 的標準輸出轉到特定 div 標註, 而 Ace 編輯器則設為與其內的程式碼相同長度, 但至多只會在頁面中顯示 20 行, 且編輯器內的程式碼使用 12 號字元. ace.py 原始碼, 位於 data/py 目錄中, 將原先只能單一呼叫的函式改為物件, 可以在同一頁面中產生案例時, 透過各標註的 id 字串區分各段程式碼, 是本課程 Python3 物件導向程式的實際應用範例, 謹提供參考. import sys import time import traceback import javascript from browser import document as doc, window, alert if hasattr(window, 'localStorage'): from browser.local_storage import storage else: storage = None class cOutput: def __init__(self, target): self.target = doc[target] def write(self, data): self.target.value += str(data) class Editor(): def __init__(self, editor_id, console_id, container_id, storage_id): self.editor_id = editor_id self.console_id = console_id self.container_id = container_id self.storage_id = storage_id self.output = '' try: self.editor = window.ace.edit(self.editor_id) session = self.editor.getSession() session.setMode(\"ace/mode/python\") self.editor.setOptions({ 'enableLiveAutocompletion': True, 'enableSnippets': True, 'highlightActiveLine': False, 'highlightSelectedWord': True, 'autoScrollEditorIntoView': True, # 'maxLines': session.getLength() 可以根據程式長度設定 editor 列數 # 設定讓使用者最多可以在畫面中顯示 20 行程式碼 'maxLines': 20, 'fontSize': '12pt' }) except: from browser import html self.editor = html.TEXTAREA(rows=20, cols=70) doc[self.editor_id] <= self.editor def get_value(): return self.editor.value def set_value(x): self.editor.value = x self.editor.getValue = get_value self.editor.setValue = set_value def run(self, *args): sys.stdout = cOutput(self.console_id) sys.stderr = cOutput(self.console_id) doc[self.console_id].value = '' src = self.editor.getValue() if storage is not None: storage[self.storage_id] = src t0 = time.perf_counter() try: #ns = {'__name__':'__main__'} # 以 self.editor_id 名稱執行程式 ns = {'__name__': self.editor_id} exec(src, ns) state = 1 except Exception as exc: traceback.print_exc(file=sys.stderr) state = 0 self.output = doc[self.console_id].value print('<completed in %6.2f ms>' % ((time.perf_counter() - t0) * 1000.0)) return state def show_console(self, ev): doc[self.console_id].value = self.output doc[self.console_id].cols = 60 doc[self.console_id].rows = 10 def clear_console(self, ev): doc[self.console_id].value = \"\" def clear_container(self, ev): doc[self.container_id].clear() # load a Python script def load_script(self, evt): _name = evt.target.value + '?foo=%s' % time.time() self.editor.setValue(open(_name).read())","tags":"Course","url":"https://kmolab.github.io/blog/brython-programming-environment.html"},{"title":"CMSimfly 與 Fossil SCM","text":"CMSimfly 是一套採用 Flask 應用程式框架編寫的網際內容管理系統 (Content Management System), Fossil SCM 則是以 ANSI C 編寫的軟體組態管理 (Software Configuration Management) 系統, 兩套程式各有不同的特色, CMSimfly 適合用來管理無版次的大型檔案, 而 Fossil SCM 則可用來記錄詳細的軟體設計開發歷程. CMSimfly 與 Fossil SCM 安裝規劃 CMSimfly 採用 Python3 與 Flask 編寫, 可以採用 uwsgi 模組啟動, 預計網際前端透過 Nginx https 埠號 8443 承接來自瀏覽器的請求, 而 Fossil SCM 的 http port 80 前端則由 Nginx 承接後, 直接跳轉 Stunnel 所代理的 https 服務. 因此當使用者以瀏覽器 http 連線, 伺服器會馬上跳轉 https 的 Fossil SCM, 假如要連結 CMSimfly, 則必須以 https 8443 連線. uwsgi 有多種啟動方式, 在此希望透過 Emperor 的多應用程式的模式啟動, 基本架構是, uwsgi 指令在 /etc/rc.local 中以 exec 執行, 可以在伺服器開機時執行, 而 uwsgi Emperor 中指定以一般用戶身分執行, 實際封包在內部網路的 8081 啟動, 之後透過 /etc/nginx/sites-available/default 中的 server 設定, 只接受 8443 埠號的 IPv4 與 IPv6 網際瀏覽器請求. CMSimfly 安裝設定 根據 uwsgi 與 Emperor 的啟動, 伺服器所需模組, 包括 pip3, Flask, python3 開發環境, uwsgi, nginx 與 uwsgi-plugin-python3 模組: sudo apt install python3-pip sudo pip3 install Flask sudo apt install build-essential python3-dev sudo pip3 install uwsgi sudo apt install nginx uwsgi-plugin-python3 而 /etc/nginx/sites-available/default 的設定 server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://my.server.host.name; } server { listen 8443 ssl; listen [::]:8443 ssl; location /static { alias /home/user/cmsimfly/static/; } location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8081; } server_name my.server.host.name; ssl on; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } 位於 /home/user/uwsgi_ini/ 目錄下的 uwsgi.ini 檔案設定: [uwsgi] socket = 127.0.0.1:8081 uid = user gid = user plugins-dir = /usr/lib/uwsgi/plugins/ plugin = python3 master = true process = 4 threads = 2 chdir = /home/user/cmsimfly wsgi-file = /home/user/cmsimfly/wsgi.py 假如希望額外啟動其他的 uwsgi 程式, 例如第二組 CMSimfly 或其他對應的 Flask 應用程式, 則需要在 /etc/nginx/sites-available/default 增加另外一組 server 設定, 主要在選定內部網路的特定埠號, 例如: 127.0.0.1:8082, 編寫 default 設定檔案成為: server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://my.server.host.name; } server { listen 8443 ssl; listen [::]:8443 ssl; location /static { alias /home/user/cmsimfly/static/; } location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8081; } server_name my.server.host.name; ssl on; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } server { listen 9443 ssl; listen [::]:9443 ssl; location /static { alias /home/user/cmsimfly2/static/; } location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8082; } server_name my.server.host.name; ssl on; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } 然後在 /home/user/uwsgi_ini 目錄中, 再配合增加一組 uwsgi2.ini, 內容為: [uwsgi] socket = 127.0.0.1:8082 uid = user gid = user plugins-dir = /usr/lib/uwsgi/plugins/ plugin = python3 process = 4 threads = 2 chdir = /home/user/cmsimfly2 wsgi-file = /home/user/cmsimfly2/wsgi.py /etc/nginx/sites-available/default 與 /home/user/uwsgi_ini/uwsgi2.ini 設定修改後, 只要透過 /etc/init.d/nginx restart 重新啟動 Nginx, 並且重新執行 uwsgi 指令, 意即, uwsgi --emperor /home/user/uwsgi_ini, 納入 /home/user/uwsgi_ini/uwsgi.ini 與 /home/user/uwsgi_ini/uwsgi2.ini 的多 uwsgi Emperor 架構應用程式即可在 https://my.sever.host.name:9443 多一組 CMSimply 網際內容管理的伺服. 若要讓伺服器在開機時執行 uwsgi, 則需要在/etc/rc.local 加入: exec uwsgi --emperor /home/user/uwsgi_ini 過程中若需要重新啟動 nginx, 以 /etc/init.d/nginx restart 執行. Fossil SCM 與 Stunnel 聯合啟動 因為在 Nginx /etc/nginx/sites-available/default 中已經將 port 80 的回應處理直接透過 http 301 狀態碼的宣告, 永久轉接到 https://my.server.host.name, 因此只要透過 Stunnel 代理在標準的 IPv4 與 IPv6 網路協定中, 以 https 啟動 Fossil SCM 即可. 首先要安裝 Stunnel 與 Fossil SCM: sudo apt update sudo apt install stunnel4 -y sudo apt install fossil 讓 Stunnel 開機時啟動: /etc/default/stunnel4 檔案設定, 將原先內定的 ENABLED=0 改為 1: ENABLED=1 因為要以 https 設定 /etc/stunnel/stunnel.conf, 因此 /etc/stunnel 目錄中需要 stunnel.crt 與 stunnel.key. 在 /etc/stunnel 目錄中執行 openssl 指令: sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout stunnel.key -out stunnel.crt 然後設定 /etc/stunnel/stunnel.conf: [https] accept = your.ipv4.ip:443 accept = :::443 cert = /etc/stunnel/localhost.crt key = /etc/stunnel/localhost.key exec = /usr/bin/fossil execargs = /usr/bin/fossil http /home/user/ --https --nojail --notfound default 重新啟動 stunnel 時, 執行 /etc/init.d/stunnel4","tags":"Research","url":"https://kmolab.github.io/blog/cmsimfly-and-fossil-on-same-machine.html"},{"title":"2017 Fall 主機設定","text":"在 2017 年 Spring, 電腦輔助設計室購入兩台 HP 伺服器, 分別是 HPE ProLiant ML10 Gen9 Server 與 HPE ProLiant ML350 Gen9 Server , 操作系統為 Ubuntu 16.04, 根據 Ubuntu LTS 通告 , 使用週期可至 2021 年, 預計在 2019 年 Spring 由新伺服器接手提供服務. 近端、區網與雲端其實是同一端 自 2017 年 10 月起, 已經沒有免費的 OpenShift 雲端服務可以使用, 遠端較穩定的 html + javascript hosting 只剩下 Github Pages, 但是就課程與研究所需的近端、區網與雲端上的各項服務而言, 雲端的免費套餐終將越來越縮水的情況下, 強化近端與區網上的軟硬體服務, 將會更加重要. 這個學期工作站室的伺服器, 將全面使用 Fossil SCM 管理所有的課程與研究專案, 每一位上課的學員都將在近端與區網擁有一個 Fossil 倉儲, 用來存放與課程相關的所有內容. Github 與 Bitbuckert 等雲端免費方案仍然扮演重要角色, 只是在無廣域網路連線與區域網路連線的情況下, 各學員的各項課程內容演練與操作資料提交, 將能在隨身的可攜系統上完成, 之後再配合區網與雲端網路的連線, 設法在分組協同的模式下, 將近端資料同步到區網與雲端主機. 因此 2017 Fall 起, 如何在近端、區網與雲端不同硬體環境下, 保持倉儲資料版本的同步, 就是另外一個重點. 主機設定 接下來, 我們透過 https://cadpb.kmol.info/40523201 學員倉儲, 來說明提供 Fossil SCM 服務的主機如何設定. 首先當然是要先掌握 kmol.info 網域的主導權, 透過網域 DNS 的控管, 讓區域網路中的主機可以在 A 與 AAA 設定下的 IPv4 與 IPv6 網址呼應, 例如: cadpb.kmol.info 指的就是 cadp 電腦輔助設計實習課程中的 b 班所使用的伺服器名稱. 如前所述, 這些伺服器都是安裝 Ubuntu 16.04 Server 操作系統 + OpenSSH, 目的是希望在 Self-signed Certificate 的模式下運作. 接著必須根據 多 Fossil SCM 倉儲主機 的架構, 分別安裝 Fossil SCM 與 Stunnel. 其中, 特別將 Fossil SCM 伺服的目錄指向 /home/cadpa2017, 表示各操作系統帳號所有人, 可以自行利用 fossil 指令, 建立多個倉儲, 此一模式就是同一台主機可以透過網域來界定上課班級, 操作系統帳號可以界定大分組名稱, 而採用學號的倉儲名稱則可以用來界定參與協同的所有者. 因此, 一旦各倉儲所有者掌握管理該 .fossil 檔案的總管理權之後, 可以將其他學員納入自己所掌控的 .fossil users 中, 視實際需求賦於各帳號不同權限. 且可透過制式的 URL, 在得知各班各分組的成員學號情況下, 連結至各學員的倉儲中進行資料檢視. 機械設計專案的資料格式 由於設計是一種利用口語、文字、2D、3D、數學與實體等形式, 所完成的明確與具體表達, 過程中必須仔細思考、多方考量, 而且在不同時段與多人協同合作的結果, 將會產生許多不同的資料版本. 加上二十一世紀的機械可說是各種固體、流體與軟體元件精巧組合而成, 能達成特定功能之器物. 因此機械設計專案過程所產生的各種資料及版本, 更需要特別關注並竭力保存, 以便讓新舊學員在自學、執行與想像的創造力發揮階段, 擁有可持續改進的工具之外, 也能有保有多元開放的完整學習資料. 在這樣對於機械設計表達、內容物與創造流程的認知下, 我們會希望學員在口語表達階段除了錄音之外, 能夠利用 Reveal.js 投影片寫下文字資料, 能儘量採用開放的設計格式, 在 Fossil SCM 倉儲中保留可以持續追蹤的文字資料格式, 2D/3D 的末端二位元檔案, 並非版次管理系統所關注並保留的重點, 學員該紀錄的是, 各種末端檔案是在何種情況下, 根據哪些約束條件, 用甚麼方法產生, 隨後的使用者在檢視歷史資料的同時, 應該可以根據這些較能持續改進的文字資料, 配合不同的情況, 使用不同的工具, 建立其所需的二位元末端檔案. 換言之, 一個多元開放的機械設計專案, 在導入各種軟硬體組態管理的時間點, 必須全面檢視所用的工具, 所處的環境, 盡量採用能持續改進的專案資料格式, 而非只儲存不知前因與狀況下所產生的封閉格式檔案. 文字、大綱與程式 當上述 Fossil SCM 主機的設定, 可以讓各學員個別管理 .fossil 倉儲檔案之後, 利用瀏覽器介面可以控管 users, 可以利用 wiki 建立快寫網頁, 可以將各種影片檔案以 attach 方式附加在 wiki 頁面中, 也可以在專案進行過程利用 tickets 追蹤設計問題, 並在專案階段性任務完成時, 以 technote 紀錄成果. 除了利用瀏覽器介面維護的協同內容之外, 機械設計過程中採 Pelican Blog 紀錄的網誌, 採 Reveal.js 格式的簡報網頁, 以及各種計算機程式檔案, 則必須在文字、大綱與程式架構下來進行管理. 在此我們所採用的管理工具為 Leo Editor, SciTE 與 Eric6. Leo Editor 是一套採用 Python3 + PyQt5 所編寫的大綱管理套件, 其任務是負責利用大綱架構管理鬆散的 Pelican Blog, 並且利用 button 執行操作系統指令, 還肩負透過 Python3 程式碼所組成的 button, 在近端啟動 IPv4 與 IPv6 WWW 伺服模擬環境, 能讓學員在近端檢視所有之後要推送到區網與雲端中的網誌與投影片內容. SciTE 則提供文字編輯以及 Python3 與 ANSI C 程式執行環境, 而 Eric6 則用於 PyQt5 程式的開發. 純 IPv6 主機設定 目前在系主幹上的電腦已經可以選擇透過 IPv6 DHCP 或自行設定 IPv6 位址連線上網. 在安裝 Ubuntu 16.04 Server 時, 選擇安裝 OpenSSH 模組, 之後則必須透過 IPv4/IPv6 雙支援的 Squid Proxy Server 才可以利用 apt 維護系統所安裝的套件. apt Proxy 的設定必須在 /etc/apt/atp.conf 中納入: Acquire::http::Proxy \"http://[2001:288:6004:17::87]:3128\"; 直接存檔後, apt 指令就可以透過 Proxy Server 連接到只支援 IPv4 網路協定的電腦. Ubuntu Server 安裝後, 若希望安裝 ubuntu-desktop: sudo apt install ubuntu-desktop 接著必須在 Firefox 瀏覽中設定 Proxy Server 代理主機, 否則無法連到只支援 IPv4 網路協定的網站. 其中 Firefox 的 Proxy Server 設定, Proxy Server 的 IPv6 網址無需中括號. 其次若希望採用自訂的 IPv6 網路設定, 可以修改 /etc/network/interfaces 檔案 啟用 inet6 static or auto address 2001... netmask 64 gateway 2001... dns-nameservers 2001:b000:168::1 最後則安裝設定中文輸入法: sudo apt install fcitx fcitx-chewing 然後修改系統的 language support 將輸入法改為 fcitx 設定後, 必須登出再登入, 讓設定生效, input method 則選擇 chewing. 各階段設定檔案 Stunnel 的設定, 目的在與 Fossil SCM 結合, 提供 https 的連線代理. /etc/stunnel/stunnel.conf [https] accept = your_IPv4_ip:443 accept = :::443 cert = /etc/stunnel/localhost.crt key = /etc/stunnel/localhost.key exec = /usr/bin/fossil execargs = /usr/bin/fossil http /home/ --https --nojail --notfound user/default 因為 Fossil SCM 加上 Stunnel 設定時, 已經將連線協定設為 HTTPS, 因此 http 伺服則交由 nginx 回應: sudo apt install nginx 之後再些改 /etc/ nginx/site-available/default nginx return 301 設定: server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://hp.kmol.info; }","tags":"Research","url":"https://kmolab.github.io/blog/2017fall-srver-setup.html"},{"title":"2017 Fall 即將開學","text":"再過幾天, 2017 Fall 學期即將開始, 去年 copy.com 免費雲端磁碟停止提供服務, 這個月底 OpenShift 的 online 2 免費帳號也將走入歷史, 可以預期, 之後 Github 與 Bitbucket 的免費方案也將會越來越限縮, 或許就連 Onshape 與 V-rep 目前所提供的免費教育授權, 也會步上相同後塵. 課程工具檢討 以機械設計工程師的培訓角度而言, 除了第三方的雲端系統外, 還有自建的廣域網路上的伺服器, 區域網路上的伺服器, 以及單機隨身系統上的伺服器. 其中自建的三種伺服器都能從 http://service.mde.tw/public/python2017fall_36.7z 隨身系統中所提供的工具進行配置與模擬. 可攜隨身系統中最重要的工具為 Python3 程式環境, 搭配 SCiTE, TinyC, Leo Editor, Pelican, Reveal.js, Eric6 IDE, 以及 Flask 與 Brython, 使用者可以編寫 PyQt5 套件, 可以練習以 ANSI C 建立簡單的動態連結程式庫, 配合 Python3 主程式使用. 也能建立整合網際前後端的 Python3 程式, 同時納入網誌與網際投影片系統. 這些工具在從事各種機械設計產品開發時, 所產生的資料版本, 自 2017 Spring 起, 已經同時採用 Github 與 Fossil SCM 進行管理, 2017 Fall 將會更側重 Fossil SCM 的運用, 除了讓同一倉儲, 在兩套遠端不同分散式資料版次管理系統保持同步外, 近端也會擁有一套備份, 可以簡單地利用 fossil ui 進行檢視, 或者結合 Stunnel, 讓近端的倉儲管理與遠端模式相同. 至於用來執行 Fossil SCM 伺服器的主機, 目前使用的是接近淘汰的機種, 這學期將要測試一台電腦能夠承受幾名學員同步提交推送資料, 最終, 學員必須要學會如何將 Pelican Blog, Reveal.js 投影片版本資料, 同時放到 Github 與區域網路上的 Fossil SCM 伺服器. CAD 的工具目前採用單機上輕量的 Solvespace 與雲端上的 OnShape, Solvespace 是一套採 C++11 編寫的 GPL 授權參數式電腦輔助設計套件, 永續使用較無問題, OnShape 在協同產品上的設計功能, 有其獨特性, 因此將繼續採用. V-rep 也提供 GPL 使用授權, 2017 Fall 起將要自行編譯使用. 2017 Fall 區網主機 主要伺服器可以從 http://mde.tw 進入. 2017 Fall 區網課程網頁: https://mde1a1.kmol.info/2017fall Github 與 Fossil SCM 同步倉儲: https://mde1a1.kmol.info/pymcadp","tags":"Course","url":"https://kmolab.github.io/blog/2017fall-semester-starts.html"},{"title":"Sunset of OpenShift Online 2 Platform","text":"OpenShift 在 2017.08.25 於 https://blog.openshift.com/migrate-to-v3-v2-eol/ 宣布, 先前所推出的 Online 2 Platform, 將要在 2017.09.30 走入歷史. 為了因應這個變化, 許多過去所建立的網站資料將要轉到 Github 與 Fossil SCM. https://wordpress-2015course.rhcloud.com/ 有用的連結 Free Math Books http://www.openculture.com/free-math-textbooks Kinematic Synthesis of Linkage http://ebooks.library.cornell.edu/k/kmoddl/toc_hartenberg1.html the kinematic models for design http://ebooks.library.cornell.edu/k/kmoddl/about.html CSS 與 Div 取代 Table https://sofree.cc/css-table/ http://www.flycan.com/article/css/css-float-442.html 以 http://2016spring-cadlab.rhcloud.com 取出舊版程式? cadlab At mde 備份: https://wordpress-2015course.rhcloud.com/?p=4579 Product Design Modeling using CAD/CAE How to be a star engineer http://ieeexplore.ieee.org/document/795608/","tags":"Course","url":"https://kmolab.github.io/blog/sunset-of-openshift-online2.html"},{"title":"Calculator in PyQt5 and Eric6","text":"根據 http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html 的說明, 利用 Eric6 與 PyQt5 開發簡單的計算器視窗程式. Flask 與 Javascript 建立簡單計算器: Buttons are grouped in categories according to their behavior. For example, all the digit buttons (labeled 0 to 9) append a digit to the current operand. For these, we connect multiple buttons to the same slot (e.g., digitClicked()). The categories are digits, unary operators (Sqrt, x², 1/x), additive operators (+, -), and multiplicative operators (×, ÷). The other buttons have their own slots. The private createButton() function is used as part of the widget construction. abortOperation() is called whenever a division by zero occurs or when a square root operation is applied to a negative number. calculate() applies a binary operator (+, -, ×, or ÷). These variables, together with the contents of the calculator display (a QLineEdit), encode the state of the calculator: sumInMemory contains the value stored in the calculator's memory (using MS, M+, or MC). sumSoFar stores the value accumulated so far. When the user clicks =, sumSoFar is recomputed and shown on the display. Clear All resets sumSoFar to zero. factorSoFar stores a temporary value when doing multiplications and divisions. pendingAdditiveOperator stores the last additive operator clicked by the user. pendingMultiplicativeOperator stores the last multiplicative operator clicked by the user. waitingForOperand is true when the calculator is expecting the user to start typing an operand. Additive and multiplicative operators are treated differently because they have different precedences. For example, 1 + 2 ÷ 3 is interpreted as 1 + (2 ÷ 3) because ÷ has higher precedence than +. The table below shows the evolution of the calculator state as the user enters a mathematical expression. Waiting for Operand? 等待運算處理對象? Add. Op. - 加或減運算元,若隨後無乘與除等優先運算元, 且按下等於或接著按加或減運算元, 則前段隨即完成運算後列在 Sum so Far 欄位. Mul. Op. - 乘或除運算元, 屬於優先運算元, 因此若輸入已經滿足運算數接優先運算元, 再接其他運算元則 將局部優先運算所需的前方運算數, 放入 Factor so Far, 而前面未處理的加或減運算數, 則放入 Sum so Far. User Input Display Sum so Far Add. Op. Factor so Far Mult. Op. Waiting for Operand? 0 0 true 1 1 0 false 1 + 1 1 + true 1 + 2 2 1 + false 1 + 2 ÷ 2 1 + 2 ÷ true 1 + 2 ÷ 3 3 1 + 2 ÷ false 1 + 2 ÷ 3 - 1.66667 1.66667 - true 1 + 2 ÷ 3 - 4 4 1.66667 - false 1 + 2 ÷ 3 - 4 = -2.33333 0 true Unary operators, such as Sqrt, require no special handling; they can be applied immediately since the operand is already known when the operator button is clicked. Finally, we declare the variables associated with the display and the buttons used to display numerals. In the constructor, we initialize the calculator's state. The pendingAdditiveOperator and pendingMultiplicativeOperator variables don't need to be initialized explicitly, because the QString constructor initializes them to empty strings. We create the QLineEdit representing the calculator's display and set up some of its properties. In particular, we set it to be read-only. We also enlarge display's font by 8 points. For each button, we call the private createButton() function with the proper text label and a slot to connect to the button. The layout is handled by a single QGridLayout. The QLayout::setSizeConstraint() call ensures that the Calculator widget is always shown as its optimal size (its size hint), preventing the user from resizing the calculator. The size hint is determined by the size and size policy of the child widgets. Most child widgets occupy only one cell in the grid layout. For these, we only need to pass a row and a column to QGridLayout::addWidget(). The display, backspaceButton, clearButton, and clearAllButton widgets occupy more than one column; for these we must also pass a row span and a column span. Pressing one of the calculator's digit buttons will emit the button's clicked() signal, which will trigger the digitClicked() slot. First, we find out which button sent the signal using QObject::sender(). This function returns the sender as a QObject pointer. Since we know that the sender is a Button object, we can safely cast the QObject. We could have used a C-style cast or a C++ static_cast<>(), but as a defensive programming technique we use a qobject_cast(). The advantage is that if the object has the wrong type, a null pointer is returned. Crashes due to null pointers are much easier to diagnose than crashes due to unsafe casts. Once we have the button, we extract the operator using QToolButton::text(). The slot needs to consider two situations in particular. If display contains \"0\" and the user clicks the 0 button, it would be silly to show \"00\". And if the calculator is in a state where it is waiting for a new operand, the new digit is the first digit of that new operand; in that case, any result of a previous calculation must be cleared first. At the end, we append the new digit to the value in the display. The unaryOperatorClicked() slot is called whenever one of the unary operator buttons is clicked. Again a pointer to the clicked button is retrieved using QObject::sender(). The operator is extracted from the button's text and stored in clickedOperator. The operand is obtained from display. Then we perform the operation. If Sqrt is applied to a negative number or 1/x to zero, we call abortOperation(). If everything goes well, we display the result of the operation in the line edit and we set waitingForOperand to true. This ensures that if the user types a new digit, the digit will be considered as a new operand, instead of being appended to the current value. The additiveOperatorClicked() slot is called when the user clicks the + or - button. Before we can actually do something about the clicked operator, we must handle any pending operations. We start with the multiplicative operators, since these have higher precedence than additive operators: If × or ÷ has been clicked earlier, without clicking = afterward, the current value in the display is the right operand of the × or ÷ operator and we can finally perform the operation and update the display. If + or - has been clicked earlier, sumSoFar is the left operand and the current value in the display is the right operand of the operator. If there is no pending additive operator, sumSoFar is simply set to be the text in the display. Finally, we can take care of the operator that was just clicked. Since we don't have the right-hand operand yet, we store the clicked operator in the pendingAdditiveOperator variable. We will apply the operation later, when we have a right operand, with sumSoFar as the left operand. The multiplicativeOperatorClicked() slot is similar to additiveOperatorClicked(). We don't need to worry about pending additive operators here, because multiplicative operators have precedence over additive operators. Like in additiveOperatorClicked(), we start by handling any pending multiplicative and additive operators. Then we display sumSoFar and reset the variable to zero. Resetting the variable to zero is necessary to avoid counting the value twice. The pointClicked() slot adds a decimal point to the content in display. The changeSignClicked() slot changes the sign of the value in display. If the current value is positive, we prepend a minus sign; if the current value is negative, we remove the first character from the value (the minus sign). The backspaceClicked() removes the rightmost character in the display. If we get an empty string, we show \"0\" and set waitingForOperand to true. The clear() slot resets the current operand to zero. It is equivalent to clicking Backspace enough times to erase the entire operand. The clearAll() slot resets the calculator to its initial state. The clearMemory() slot erases the sum kept in memory, readMemory() displays the sum as an operand, setMemory() replace the sum in memory with the current sum, and addToMemory() adds the current value to the value in memory. For setMemory() and addToMemory(), we start by calling equalClicked() to update sumSoFar and the value in the display. The private createButton() function is called from the constructor to create calculator buttons. The private abortOperation() function is called whenever a calculation fails. It resets the calculator state and displays \"####\". The private calculate() function performs a binary operation. The right operand is given by rightOperand. For additive operators, the left operand is sumSoFar; for multiplicative operators, the left operand is factorSoFar. The function return false if a division by zero occurs.","tags":"Course","url":"https://kmolab.github.io/blog/calculator-pyqt5-eric6.html"},{"title":"Create a Multi-repository Fossil SCM Server","text":"In order to create a multi-repository Fossil SCM server on Ubuntu 16.04 environment, three steps are needed. Step 1: install Stunnel and Fossil SCM sudo apt update sudo apt install stunnel4 -y sudo apt install fossil Edit /etc/environment file and add the following setup to allow only the https connections: HTTPS=on Edit /etc/default/stunnel4 file and modified the ENABLED value from 0 to 1 to get stunnel service running when the computer startup: ENABLED=1 Step 2: Stunnel setup Change directory to /etc/stunnel/ and use the following command to generate localhost.key and localhost.crt files. sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt edit stunnel.conf configuration file under /etc/stunnel/ as follows: [https] accept = your_IPv4_ip:443 accept = :::443 cert = /etc/stunnel/localhost.crt key = /etc/stunnel/localhost.key exec = /usr/bin/fossil execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound default which means the IPv4 and IPv6 requests are both accepted under port 443. And /home/user/repository/ is used to store the Fossil SCM repo files. The default repo file is /home/user/repository/default.fossil The setting of \"--notfound default\" means if the repository file is not specified, connection URL is default which is a relative directory associated with the server main URL. Step 3: create Fossil SCM repositories Change directory to /home/user/repository and use \"fossil init default.fossil\" command to create the default repository. If more repository is needed, also use \"fossil init other.fossil\" to create other.fossil repository under /home/user/repository. After the setup use \"/etc/init.d/stunnel4 restart\" command to restart the Stunnel service. Use https://site-url:443/ to connect to default.fossil and use https://site-url:443/other to connect to other.fossil.","tags":"Course","url":"https://kmolab.github.io/blog/create-a-multi-repository-fossil-scm-server.html"},{"title":"2015 Fall CADP W16","text":"根據 Nutcracker 機構 的尺寸規格, 請設法算出 Piston 零件的有效運動範圍. 計算 Piston 不發生干涉的有效行程, 可採如下方法: 實際利用 Onshape 中的組立, 移動 piston 零件, 靠目測概略決定 piston 的有效行程. (目測法, 只能得到大概的行程範圍) 利用 Solvespace 繪製 2D 約束圖, 然後利用約束點在線或圓上的方式, 以圖解法解出有效行程, 如下圖一, 圖二與圖三所示. (圖解法, 利用 Solvespace 既有的約束條件設定完成計算) 利用 Jupyter 與 Python3 的 sympy 模組, 先進行符號式推導, 然後再利用數值分析解出 piston 的有效行程, 機構各點標示如下圖四所示, 計算出 的 theta 轉角為 105.7, 如下圖五所示. (以自行編寫的 sympy 程式解題, 透過 Jupyterhub 可以有效進行協同設計運算) 除了上述的目測, 圖解與符號式結合數值分析法之外, 也可以採用 基因演算法解題 , 計算出的 theta 轉角為 105.7, 如下圖六所示. (利用演化法解題, 可以在單機運算, 也可以在 Jupyterhub 平台 上進行運算) 圖一: 利用 Solvespace 中的繪圖約束條件找出右邊的極限點距離 Onshape Piston 組立原點 0.5 圖二: 利用 Solvespace 中的繪圖約束條件找出左邊的極限點距離 Onshape Piston 組立原點 2.23 圖三: 當 piston 位於左邊極限點時, AB 轉角為 105.37 度 圖四: Jupyter 計算分析時機構各點標示圖 圖五: 利用 Jupyter 符號式結合數值分析法所得結果 圖六: 利用基因演算解題, 所得到的結果, 當 piston 位於左邊極限點時, AB 轉角為 105.7 度 若採用 deap 與 numpy 解題 (AB 轉角極限為 105.71 度): # 這裡採用 numpy 與 deap 模組解題, 使用 Genetic Algorithm 模式 # 解的問題為 Nutcracker 左邊 connect 轉角極限 import random import array from deap import base from deap import creator from deap import tools import numpy # for evalIntersect 函式中的 sqrt, sin, cos, pi from math import * # 1/4 最小化題目 type of problem creator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,)) creator.create(\"Individual\", array.array, typecode='d', \\ fitness=creator.FitnessMin) # 2/4 initilization # 兩個變數題目 NDIM = 2 toolbox = base.Toolbox() toolbox.register(\"attr_float\", random.uniform, 0, 5) toolbox.register(\"individual\", tools.initRepeat, creator.Individual, toolbox.attr_float, NDIM) toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual) # 3/4 選擇 operator step3/4 toolbox.register(\"select\", tools.selRandom, k=3) # 也可以採用下列設定 #toolbox.register(\"mate\", tools.cxTwoPoint) #toolbox.register(\"mutate\", tools.mutGaussian, mu=0, sigma=1, indpb=0.1) #toolbox.register(\"select\", tools.selTournament, tournsize=3, k=3) def evalIntersect(individual): t = individual[0] deg = pi/180 theta = individual[1]*deg xtarget = 0.75/2 ytarget = 0.5 x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 \\ + 529)/92 + 3*cos(theta)/2 y = (-3*t/2 + 123/92)*sin(theta) # 適應值 fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8) # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰 if t > 1: fitness_value += 1000 if t < 0: fitness_value += 1000 # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰 if theta > 2*pi: fitness_value += 1000 if theta < 0: fitness_value += 1000 return fitness_value, toolbox.register(\"evaluate\", evalIntersect) # 以上到 evaluate 為止, 為定義 operators # 4/4 以下則為 Algorithms def main(): # Differential evolution parameters CR = 0.25 F = 1 MU = 300 NGEN = 200 pop = toolbox.population(n=MU); hof = tools.HallOfFame(1) stats = tools.Statistics(lambda ind: ind.fitness.values) stats.register(\"avg\", numpy.mean) stats.register(\"std\", numpy.std) stats.register(\"min\", numpy.min) stats.register(\"max\", numpy.max) # Evaluate the individuals fitnesses = toolbox.map(toolbox.evaluate, pop) for ind, fit in zip(pop, fitnesses): ind.fitness.values = fit for g in range(1, NGEN): for k, agent in enumerate(pop): a,b,c = toolbox.select(pop) y = toolbox.clone(agent) index = random.randrange(NDIM) for i, value in enumerate(agent): if i == index or random.random() < CR: y[i] = a[i] + F*(b[i]-c[i]) y.fitness.values = toolbox.evaluate(y) if y.fitness > agent.fitness: pop[k] = y hof.update(pop) print(\"Best individual is \", hof[0], hof[0].fitness.values[0]) if __name__ == \"__main__\": main() 上述課程資料與 Wordpress 網頁 上的資料內容相同, Ｗordpress 網站屬於動態的網誌, 而 http://chiamingyen.github.io/kmolab/ 則是靜態網誌系統, 採用靜態網誌的優點如下: 比較安全 比較不會過時 部署成本比較低 可在各種平台上使用 各階段改版資料均有紀錄 以下為參考用的 GA 解 Nutcracker 題目的程式碼: #encoding=utf8 # genetic.py # import random import operator # for Intersect from math import * MAXIMIZE, MINIMIZE = 11, 22 class Individual: chromosome = None score = None # Here the size of var depends on var_number var = [] var_number = 2 for i in range(var_number): var.append(0) alleles = (0,1) # 以下為參數可負數時的編碼考量 #前10為小數,後10為整數,第21則為正負號 #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號. #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號 #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號 # -1023 ~ 1023 #length = 21*var_number,若接受負數參數,則必須同步修改 20->21 length = 20*var_number seperator = '' optimization = MINIMIZE def __init__(self, chromosome=None): self.chromosome = chromosome or self._makechromosome() self.score = None # set during evaluation def _getvar(self,chromosome=None): x = 0 for i in range(0,self.var_number): for j in range(i*20,i*20+10): x +=self.chromosome[j]<<(j-(i*20)) if (x>999): x=999 x/=1000. for j in range(i*20+10,i*20+20): x +=self.chromosome[j]<<(j-(i*20+10)) self.var[i] = x return self.var ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings #for design variable -1023 ~1023 for i in range(self.var_number): x = 0 for j in range(i*21,i*21+10): x +=self.chromosome[j]<<(j-(i*21)) if (x>999): x=999 x/=1000. for j in range(i*(21)+10,i*(21)+20): x +=self.chromosome[j]<<(j-(i*21+10)) if(self.chromosome[i*(21)+20] == 1): self.var[i] = -x else: self.var[i] = x x = 0 return self.var ''' def _makechromosome(self): \"makes a chromosome from randomly selected alleles.\" return [random.choice(self.alleles) for gene in range(self.length)] def evaluate(self, optimum=None): \"this method MUST be overridden to evaluate individual fitness score.\" pass def crossover(self, other): \"override this method to use your preferred crossover method.\" return self._twopoint(other) def mutate(self, gene): \"override this method to use your preferred mutation method.\" self._pick(gene) # sample mutation method def _pick(self, gene): \"chooses a random allele to replace this gene's allele.\" self.chromosome[gene] = random.choice(self.alleles) # sample crossover method def _twopoint(self, other): \"creates offspring via two-point crossover between mates.\" left, right = self._pickpivots() def mate(p0, p1): chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容 chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因 #child = p1.__class__(chromosome) 這是原先的程式,但是應該子代要指向 p0 的內容才對 child = p0.__class__(chromosome) child._repair(p0, p1) return child return mate(self, other), mate(other, self) # some crossover helpers ... def _repair(self, parent1, parent2): \"override this method, if necessary, to fix duplicated genes.\" pass def _pickpivots(self): left = random.randrange(1, self.length-2) right = random.randrange(left, self.length-1) return left, right # # other methods # def __repr__(self): \"returns string representation of self\" ''' return '<%s chromosome=\"%s\" score=%s var=%s>' % \\ (self.__class__.__name__, self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome)) ''' return '<%s score=%s var=%s>' % \\ (self.__class__.__name__,self.score,self._getvar(self.chromosome)) # since the __cmp__ special function is gone use the __lt__ in stead # use the expression (a > b) - (a < b) as the equivalent for cmp(a, b) #def __cmp__(self, other): # these are for python 3 def __cmp__(self, other): if self.optimization == MINIMIZE: #return cmp(self.score, other.score) return (self.score > other.score) - (self.score < other.score) else: # MAXIMIZE #return cmp(other.score, self.score) return (other.score > self.score) - (other.score < self.score) def __lt__(self, other): return self.__cmp__(other) < 0 def __le__(self, other): return self.__cmp__(other) <= 0 def __gt__(self, other): return self.__cmp__(other) > 0 def __ge__(self, other): return self.__cmp__(other) >= 0 def copy(self): twin = self.__class__(self.chromosome[:]) twin.score = self.score return twin class Environment(object): x = [0] y = [0] def __init__(self, kind, population=None, size=100, maxgenerations=100, crossover_rate=0.90, mutation_rate=0.07, optimum=None): self.kind = kind self.size = size self.optimum = optimum self.population = population or self._makepopulation() for individual in self.population: individual.evaluate(self.optimum) self.crossover_rate = crossover_rate self.mutation_rate = mutation_rate self.maxgenerations = maxgenerations self.generation = 0 self.report() def _makepopulation(self): return [self.kind() for individual in range(self.size)] def run(self): while not self._goal(): self.step() def _goal(self): return self.generation > self.maxgenerations or \\ self.best.score == self.optimum def step(self): # this sort is not working with python 3.0, modification is needed self.population.sort() self._crossover() self.generation += 1 self.report() self.x.append(self.generation) # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值 if self.best.score <=5: self.y.append(self.best.score) else: self.y.append(5) def _crossover(self): next_population = [self.best.copy()] while len(next_population) < self.size: mate1 = self._select() if random.random() < self.crossover_rate: mate2 = self._select() offspring = mate1.crossover(mate2) else: offspring = [mate1.copy()] for individual in offspring: self._mutate(individual) individual.evaluate(self.optimum) next_population.append(individual) self.population = next_population[:self.size] def _select(self): \"override this to use your preferred selection method\" return self._tournament() def _mutate(self, individual): for gene in range(individual.length): if random.random() < self.mutation_rate: individual.mutate(gene) # # sample selection method # def _tournament(self, size=8, choosebest=0.90): competitors = [random.choice(self.population) for i in range(size)] competitors.sort() if random.random() < choosebest: return competitors[0] else: return random.choice(competitors[1:]) def best(): doc = \"individual with best fitness score in population.\" def fget(self): return self.population[0] return locals() best = property(**best()) def report(self): print (\"=\"*70) print (\"generation: \", self.generation) print (\"best: \", self.best) # 以上為 genetic.py 目前將兩者結合在一起 #encoding=utf8 # volume.py - useage example # # the fittest individual will have a chromosome consisting of 40 '1's # # #import genetic #此一加總函式在 volume 最大化中,並未使用 def sum(seq): def add(x,y): return x+y return reduce(add, seq, 0) class Volume(Individual): optimization = MAXIMIZE def evaluate(self, optimum=None): SURFACE = 80 # self.score is the fitness value self._getvar(self.chromosome) x = self.var[0] y = self.var[1] z=(SURFACE - x*y)/(2.*(x+y)) fitness_value = x*y*z self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip class Intersect(Individual): optimization = MINIMIZE def evaluate(self, optimum=None): # self.score is the fitness value self._getvar(self.chromosome) t = self.var[0] deg = pi/180 theta = self.var[1]*deg xtarget = 0.75/2 ytarget = 0.5 x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2 y = (-3*t/2 + 123/92)*sin(theta) # 適應值 fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8) # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰 if t > 1: fitness_value += 1000 if t < 0: fitness_value += 1000 # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰 if theta > 2*pi: fitness_value += 1000 if theta < 0: fitness_value += 1000 self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip if __name__ == \"__main__\": #env = Environment(Volume, size=500, maxgenerations=100) env = Environment(Intersect, size=500, maxgenerations=100) env.run()","tags":"Course","url":"https://kmolab.github.io/blog/2015-cadp-w16.html"},{"title":"計算機程式與電腦輔助設計實習","text":"以下為 Brython 網際程式環境. window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } 投影片: from browser import document, html container1 = document['container1'] adata = open(\"./../data/1a_list.txt\").read() alist = adata.splitlines() n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://s\"+str(stud_num)+\".github.io/2017springwcm_hw\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container1 <= mlink template slide 測試 LaTex 方程式寫法與轉換: $$H\\frac{d&#94;{2}\\theta (t)}{dt&#94;{2}} = gSin\\theta(t)+a_2(t)H-a_1(t)Cos\\theta(t)$$ 經過轉換成為: $$H\\frac{d&#94;{2}\\theta (t)}{dt&#94;{2}} = gSin\\theta(t)+a_2(t)H-a_1(t)Cos\\theta(t)$$ $$\\[L(\\mu,\\sigma;X)=\\sum_i\\left[-\\frac 1 2 \\ln(2\\pi)-\\ln(\\sigma)-\\frac{1}{2\\sigma&#94;2}(X_i-\\mu)&#94;2\\right]\\]$$ 經過轉換成為: $$[L(\\mu,\\sigma;X)=\\sum_i\\left[-\\frac 1 2 \\ln(2\\pi)-\\ln(\\sigma)-\\frac{1}{2\\sigma&#94;2}(X_i-\\mu)&#94;2\\right]]$$","tags":"Course","url":"https://kmolab.github.io/blog/2017fall-cp-cadp.html"},{"title":"網際內容管理","text":"網際內容管理課程在教導學生, 利用電腦與網路軟硬體配置, 完成各項與機械設計內容管理有關的任務. 所謂網際指的是 Web-Based, 也就是 World-Wide-Web Based 的簡稱, 中文也可以翻為\"植基於全球資訊網\" 或 \"以全球資訊網為基礎\", 其內涵是希望讓使用者在網際網路 (Internet) 的基礎上, 利用 Web Browser (瀏覽器) 操作各種與機械設計內容管理有關的任務. Ubuntu 操作系統 根據 https://www.ubuntu.com/info/release-end-of-life 的生命週期年限, 選擇 LTS Server 版本安裝, 安裝過程需要安裝 OpenSSL 模組, 以及 ubuntu-desktop, Windows 客戶端則透過 xming 與 http://www.putty.org/ 進行安全的遠端登入. IPv4 與 IPv6 網路設定 一般來說, 只有必須擔負特定 WWW Server、DNS Server 與 Proxy Server 的主機需要同時支援 IPv4 與 IPv6 網路協定外, 其餘客戶端都可以只透過 IPv6 網路協定上網. WWW Server 使用 Nginx, DNS Serve 使用 Bind, 而 Proxy Server 則使用 Squid. Nginx Nginx WWW 伺服器通常用來伺服靜態文件或者作為其他近端伺服資料傳送的代理主機 (例如, uwsgi 網際服務). Ethercalc Ethercalc 允許多人利用瀏覽器同時維護一份線上試算表, 可以用於協同資料永久存檔前的轉介站. Fossil SCM Fossil SCM 是一套小而美的分散式資料管理系統 Squid Proxy Server 在 IPv4 轉換到 IPv6 的過程中, 雙網路協定支援的代理主機扮演非常重要的角色, 例如, 從純 IPv4 瀏覽器連線到純 IPv6 WWW 伺服器, 就需要透過雙網路協定的代理主機轉介資料, 其次 putty ssh 遠端登入或 sftp 安全資料傳送, 也都需要雙網路支援的代理主機居中轉換不同協定資料. X-windows Putty Leo Editor Filezilla 與 SFTP Uwsgi 與 CMSimfly","tags":"Course","url":"https://kmolab.github.io/blog/wcm-course-1.html"},{"title":"協同產品設計實習","text":"協同產品設計課程在教導學生, 以同步或非同步協同方式, 利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.","tags":"Course","url":"https://kmolab.github.io/blog/cd-course-1.html"},{"title":"電腦輔助設計實習","text":"電腦輔助設計課程在教導學生利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務. CAD Book: http://mde.tw/2016fallcadp/data/CAD_book.pdf Space Modeling with SolidWorks and NX http://beyondplm.com/2015/03/18/autodesk-and-onshape-disagree-about-cloud-technology-and-focus/ https://www.solidsmack.com/cad/onshape-comes-out-swinging-changes-mcad-pricing-forever/ https://newscrewdriver.com/category/3d-printing/3d-printing-software/fusion-360-vs-onshape/ eBook: State of Product Development / PLM 2016 http://image.engineering.com/239575/articles/Nov%202016/Autodesk%20Q615/Autodesk_pdf1R.pdf CADO: https://github.com/BGCECSE2015/CADO Electronics made easy: http://fritzing.org/home/ SFEPy: https://github.com/sfepy/sfepy http://nbviewer.jupyter.org/github/sukhbinder/sfepy-simple_tutorial/blob/master/Getting_Started_With_SFEPY_using_a_simpleplate_example.ipynb","tags":"Course","url":"https://kmolab.github.io/blog/cadp-course-1.html"},{"title":"計算機程式","text":"計算機程式課程在教導學生利用電腦完成各項與機械設計流程有關的任務. 為什麼非學不可? https://cacm.acm.org/blogs/blog-cacm/166115-why-scientists-and-engineers-must-learn-programming/fulltext 首先, 看看機械設計流程會牽涉哪些任務, 所謂機械設計, 就是歷經詳細思慮考量, 完成互動元件間之精巧配置, 使其展現特定功能之具體規劃表達. 換言之, 機械設計是一種具體規劃的表達 (presentation), 其內容是經過一系列詳細的思慮與考量所得到的結果, 而此項結果通常有具體的功能, 並且包含許多互動 (interaction) 元件之間的彈性與精巧配置 (flexible and sophisticated configuration). 我們將上述與機械設計有關的關鍵字引列如下: 機械設計是一種表達, 此種表達可以利用文字、口語、2D 靜態圖像、3D 或影音動態圖像、理論分析或實體呈現. 機械設計的過程所需要的各種思慮與考量牽涉許多定性與定量的分析, 包含許多工程原理原則與實務經驗, 這些分析除了必須利用數學建立模型, 透過演算預先模擬外, 還需要使用有效率可協同的方式紀錄過程中所產生的各種資料. 機械設計產品中所包含的各種互動元件, 包括硬體元件、流體元件、軟體元件與管理元件等. 機械設計過程中, 為了在實體化之前能預先針對各種互動元件間的組成與配置進行最佳化, 因此需要使用各種逼真的模擬方法加以呈現. 如何進行文字、2D&3D表達 有沒有一種方法可以讓多名使用者協同管理一份文件, 其中包含各種互動式圖文與影音資料, 各使用者在編修內容過程可以有效對資料進行保全, 可以有效分散備份, 可以紀錄各編修者所增刪的內容, 可以透過有效率的方法散佈此份文件的內容? 使用工具的評量方法 機械設計工程師為了有效完成具體規劃內容的表達, 過程中必須使用各種類型的工具, 其中包括: 文字資料構建、管理與呈現的工具 (text) 2 口語資料構建、管理與呈現的工具 (oral) 2D 靜態圖像資料構建、管理與呈現的工具 (2d) 3D 或影音動態圖像資料構建、管理與呈現的工具 (3d) 理論分析資料構建、管理與呈現的工具 (analytical) 實體構建、管理與呈現的工具 (physical) 工具取得、維護使用成本與其他工具整合效能成本等 工具取得成本 (now and how) 維護更新與永續使用成本 (update and sustainable) 工具掌握度與整合效能成本 (integration) 一定要學 C C 是為建立 Unix 操作系統而生的程式語言, 也是近代許多高階程式語言建構的基礎, 例如, 最早的 C 程式編譯器雖然採用組合語言編寫, 但是隨後的 C 程式編譯器則可以採用舊版的 C 來編譯, 而 Python 解譯器在 1980 年代晚期出現時, 就是以 C 程式編寫, 之後雖然有採用 Java 編寫的 Jython (2001), 以 C# 編寫的 IronPython (2006), 以 RPython 編寫的 PyPy (2007), 以 Javascript 編寫的 Brython (2012), 但是 CPython 仍然是最通用的版本. 儘管 C 程式語言對於工程師而言非常重要, 但是 C 或更進階的 C++ 程式語言的學習並不容易, 並不只是因為 C/C++ 擁有指標, 能夠控制電腦的底層記憶體, 而是因為 C/C++ 程式語言所涵蓋的應用非常廣. 但是無論如何, 工程師一定要學會基本的 C 程式語言, 倒是毋庸置疑. https://www.asme.org/career-education/articles/teachers-academics/c-as-part-of-a-mechanical-engineering-curriculum C 的指標與陣列導引 http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html CP to CADP https://github.com/2015fallhw/cptocadp 如何完成下列工作? 1) 從一本英文書的文字檔中, 算出總字數, 並按照英文字母排列, 列出書中所使用的單字, 並查出各單字的中文解釋. 2) 從網站中擷取當天台幣與美金及英鎊的匯率, 並根據某一列有台幣、美金與英鎊的檔案進行各幣值的總結算. 3) 每組有六人, 某一任務需要完成六項工作, 每人負責一項, 但各工作間必須互相配合, 任務進行中需要完整呈現各組員每一階段所完成的內容細節, 請問該如何完成. https://github.com/dustinrohde/python-rpn 4) 如何將材料特性 2D 圖表轉為電腦可以套用的文字檔或資料庫檔案? 漸開線正齒輪齒面寬運算 - 選擇正齒輪對所要傳遞的功率大小, 選擇所要使用的正齒輪齒數、模數與壓力角, 選擇齒輪的材質, 選擇小齒輪的齒數, 選擇安全係數, 從上述資料中算出齒輪齒面寬, 以便能在安全的範圍中, 不致產生過大噪音條件下完成所需功率的傳遞. 漸開線正齒輪 功率 齒數、模數與壓力角 齒輪的材質與強度 安全係數 振動與噪音 齒輪的鍵銷設計 齒輪的軸尺寸、強度與耐用度設計 軸承的選用設計 齒輪箱的設計 齒輪的潤滑與散熱設計 其他相關的設計分析、製造規劃與後勤維修等議題 5) 文字檔與數位檔案的差別與運用, 各種 2D 與 3D 零組件檔格式的讀取與轉換 https://en.wikipedia.org/wiki/AutoCAD_DXF http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf ASCII DXF File Format Binary DXF File Format https://en.wikipedia.org/wiki/STL_(file_format) http://www.fabbers.com/tech/STL_Format ASCII STL File Format Binary STL File Format IGES Version 5.3: http://paulbourke.net/dataformats/iges/IGES.pdf IGES Version 6: https://filemonger.com/specs/igs/devdept.com/version6.pdf https://en.wikipedia.org/wiki/IGES DXF, IGES and STEP: http://homepages.cae.wisc.edu/~me232/info/dxf_iges_step.pdf Python3 學習 Official Tutorial: https://docs.python.org/3/tutorial/ 10 min Python Tutorial help(), dir(), print(), range() , built-in types , 看影片自學: https://www.youtube.com/watch?v=D48iCw3WWpI http://www.spronck.net/pythonbook https://github.com/coodict/python3-in-one-pic/blob/master/notebooks/py3-in-one-pic.ipynb 資料分析: https://lectures.quantecon.org/py/ Python 很慢? https://www.youtube.com/watch?v=8hHOxfXcWsg https://www.youtube.com/watch?v=a8LsdodGoWQ PyQT https://kuanyui.github.io/2014/09/13/learn-python-via-pyqt/ 網際程式繪圖","tags":"Course","url":"https://kmolab.github.io/blog/cp-course-1.html"},{"title":"大學生為何不來上課?","text":"大學生不願進教室上課的原因很多, 學費太低? 學不到東西? 完全跟不上進度? 老師太混? 上與不上都差不多? 實在爬不起來? 沒有人叫我起床? 大學生為何不來上課? 首先就大學生上課, 有幾項基本組成: 時段、課程內容、教師與學生等. 因此, 大學生之所以不想來上課, 可能是因為時段太早, 學生爬不起來而翹課; 也可能是課程內容不能讓學生認同, 內容太過簡單, 內容太過困難等原因, 讓學生視上課為畏途, 一有機會就不願意到課; 另外也可能是老師的教學方式得不到學生認同, 因此不願意上課; 最後則是學生本身的心態, 完全不知道為何要上這門課, 或者如何克服課程中所碰到的困難等問題, 導致學生一逮到機會就斷然翹課. 時段太早爬不起床 因時段太早而翹課, 大家都知道這絕對是藉口, 也就是說, 這不是學生翹課的主要原因, 而是因為其他主要原因的影響下, 讓學生拿時段太早當作翹課的藉口. 內容太淺, 內容太深 接著來談談因為課程內容無法得到學生認同而翹課的因素, 一般而說, 過去循序漸進, 以靜態課本內容為主的教學, 較能得到學生的認同, 因為所有會涵蓋的教學內容, 都已經鉅細靡遺列在教科書中, 因此針對此類型的課程, 學生到課的主要動機在於能以較高效益理解教科書內容, 但是針對主題已定但內容會隨學習成效而加以取捨的課程, 若學生的學習動機不夠強, 就會覺得無法掌握課程教學的主軸而失焦, 導致認為課程內容太過無聊或太過複雜而中途放棄, 造成學生不願意到課. 打工賺錢太忙, 沒時間上課 有部分學生因為經濟問題, 而必須邊上課邊工作賺錢, 大多數情況下, 由於大學尚未畢業, 無法根據專業找到報酬較高的工作, 因此大多在以時數累積賺錢的第一線服務業工作為主. 當學生日以繼夜打工賺取學費或生活費的同時, 經常以此為藉口而弄得沒時間上課時, 最後在大學註冊的最終目的, 就只剩下拿學位一件事, 一般情況下, 非但無法專心在自己所學的專業上日日進步, 反而在自己的學業成績單上留下許多不良紀錄, 嚴重影響畢業後的發展. 針對此類學生, 我們的建議是, 可以向學校的科系辦公室或職涯規劃單位求助, 尋求與本身專業有關的打工機會, 並且試著利用學校各專業科目所學內容, 在專業公司協助解決實務問題, 假若, 我們是說假若, 事實證明學校所傳授的知識, 完全無法在打工的過程中解決任何實務問題, 那麼表示念這書甚至拿這學位, 根本無助於往後的發展, 這時這些學生就可大步離開學校, 全力投入自己設想更有意義的工作上, 最後也就不會再有沒時間上課的問題了. 不知老師在教什麼? 老師的教學方式確實會影響學生的學習意願, 但是當學生從頭到尾都沒能到課的情形下, 還大聲疾呼說不知老師在教什麼? 就有些說不過去. 學這些東西沒有用 假如學生與家長真的認為在學校所學, 甚至拿學位無助往後發展, 建議應該及早離開學校, 從事更有意義的事, 尋求更好的發展機會. 其他思考 學生為何而讀, 為何而學, 為何而問? 老師如何弄懂學生處境 設法與學生共同學習 鼓勵自學、執行與想像 設法與表現好的學生一起協助跟不上進度的同學 https://www.ptt.cc/bbs/Gossiping/M.1392611157.A.D09.html https://kknews.cc/education/bxbg34n.html https://www.cheers.com.tw/blog/blogTopic.action?id=425&nid=5513 https://www.thenewslens.com/article/664 https://shinphotos.com/2014-03-08-297/ http://www.businessweekly.com.tw/article.aspx?id=1124&type=Blog 大學生應有的學習態度 面對全球協同的知識經濟環境, 身為一個大學生, 至少必須: 不要怕困難 (基本信念) – 因為幾乎處於網路時代的所有人, 在享受高度科技發展所帶來的便利性之後, 都必須隨時獨力或合力克服各種困難. 不要失去熱忱 (強化動力) – 許多人在生活周遭都會碰到非常多不盡如人意的各種挑戰, 持續保持個人與團隊的處事熱忱, 是堅持克服困難的必備動力. 不要以為不可能 (終究達陣) – 只要個人不斷提升待人處事能力, 持續接觸人文養分, 並且在團隊機制的架構下, 以轉知為智的精神來解決各式問題, 假以時日, 便可實現團隊理想, 化不可能為可能! 培養新世紀大學生的關鍵能力: http://www.tpea.org.tw/uploads/TPEA_2013112021132.pdf","tags":"Misc","url":"https://kmolab.github.io/blog/first-discussion-blog.html"},{"title":"其他","text":"不在設置, 模擬, 實作與論述類別的內容, 則放入雜項其他類別","tags":"Misc","url":"https://kmolab.github.io/blog/first-misc-blog.html"},{"title":"實作","text":"紀錄與實作有關的內容, 實體製作 操作流程拍攝 有關實作, 包含拍攝實際操作的照片與影片. 在 Windows 環境建議使用 ShareX 拍攝, Ubuntu 則建議使用 Kazam . 另外一個值得研究的 PyQt5 + FFMpeg 工具位於: https://github.com/codeshard/videomorph 理想的課程網頁 https://lectures.quantecon.org/ 是一門教授數學與計量經濟學的課程, 分別使用 Python 與 Julia 程式語言, 採用 Python3 的課程教材 pdf 位於: https://lectures.quantecon.org/_static/pdfs/QuantEconlectures-python3.pdf . 這門課程的網頁不僅有 News , 有 論壇 , 並使用 Jupyter 建立網際 Notebook . 其中, 互動討論程式: https://github.com/discourse/discourse , 為 discourse, 採用 Ruby 建立. Docker for Discourse: https://github.com/discourse/discourse_docker 安裝: https://blog.fntsr.tw/articles/2014/11/07/how-to-build-discourse-with-docker-1/ Discourse 中文: https://meta.discoursecn.org/ 網際程式框架: https://github.com/emberjs/ember.js","tags":"Misc","url":"https://kmolab.github.io/blog/first-realization-blog.html"},{"title":"電腦模擬","text":"紀錄與電腦模擬相關內容與紀錄， 使用工具 Python3, RoboDK ( RoboDK API ) PyQt5 pyqt5 程式 http://projects.skylogic.ca/blog/how-to-install-pyqt5-and-build-your-first-gui-in-python-3-4/ run.py, 自行編寫用從 core/main.py 中導入 MainWindow 類別建立案例後執行 if __name__ == \"__main__\": import sys from PyQt5.QtWidgets import QApplication from core.main import MainWindow app = QApplication(sys.argv) main = MainWindow() main.show() sys.exit(app.exec_()) core/main.py, 以 main.ui 滑鼠右鍵 generate Dialog Code 產生 # -*- coding: utf-8 -*- \"\"\" Module implementing MainWindow. \"\"\" from PyQt5.QtCore import pyqtSlot from PyQt5.QtWidgets import QMainWindow from PyQt5.QtCore import QLineF from PyQt5.QtWidgets import QFrame from PyQt5.QtWidgets import QGraphicsScene, QGraphicsView, QGraphicsEllipseItem from .Ui_main import Ui_MainWindow class MainWindow(QMainWindow, Ui_MainWindow): \"\"\" Class documentation goes here. \"\"\" def __init__(self, parent=None): \"\"\" Constructor @param parent reference to the parent widget @type QWidget \"\"\" super(MainWindow, self).__init__(parent) self.setupUi(self) @pyqtSlot() def on_actionAbout_triggered(self): \"\"\" Slot documentation goes here. \"\"\" # TODO: not implemented yet #raise NotImplementedError #建立景物 scene = QGraphicsScene(-200, -200, 400, 400) # Create Ellipse Item item = QGraphicsEllipseItem(-150, -100, 300, 300) # Add item scene.addItem(item) # 納入繪圖物件 scene.addText(\"終於可以!\") scene.addLine(QLineF(0, 0, 200, 200)) # set no frame to graphicsView self.graphicsView.setFrameShape(QFrame.NoFrame) # 在既有的 graphicsView 中設定景物 # graphicsView in a layout and set layout to the grid to fit the size of window self.graphicsView.setScene(scene) # 顯示 self.graphicsView.show() @pyqtSlot() def on_actionQuit_triggered(self): \"\"\" Slot documentation goes here. \"\"\" # TODO: not implemented yet #raise NotImplementedError self.close() core/Ui_main.py, 利用 main.ui 以 compile form 產生 # -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'Y:\\tmp\\pyqt5_vault\\ex3\\core\\main.ui' # # Created by: PyQt5 UI code generator 5.8.2 # # WARNING! All changes made in this file will be lost! from PyQt5 import QtCore, QtGui, QtWidgets class Ui_MainWindow(object): def setupUi(self, MainWindow): MainWindow.setObjectName(\"MainWindow\") MainWindow.resize(800, 600) self.centralWidget = QtWidgets.QWidget(MainWindow) self.centralWidget.setObjectName(\"centralWidget\") self.graphicsView = QtWidgets.QGraphicsView(self.centralWidget) self.graphicsView.setGeometry(QtCore.QRect(-15, -29, 871, 581)) self.graphicsView.setObjectName(\"graphicsView\") MainWindow.setCentralWidget(self.centralWidget) self.menuBar = QtWidgets.QMenuBar(MainWindow) self.menuBar.setGeometry(QtCore.QRect(0, 0, 800, 22)) self.menuBar.setObjectName(\"menuBar\") self.menuFile = QtWidgets.QMenu(self.menuBar) self.menuFile.setObjectName(\"menuFile\") MainWindow.setMenuBar(self.menuBar) self.actionAbout = QtWidgets.QAction(MainWindow) self.actionAbout.setObjectName(\"actionAbout\") self.actionQuit = QtWidgets.QAction(MainWindow) self.actionQuit.setObjectName(\"actionQuit\") self.menuFile.addAction(self.actionAbout) self.menuFile.addAction(self.actionQuit) self.menuBar.addAction(self.menuFile.menuAction()) self.retranslateUi(MainWindow) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): _translate = QtCore.QCoreApplication.translate MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\")) self.menuFile.setTitle(_translate(\"MainWindow\", \"File\")) self.actionAbout.setText(_translate(\"MainWindow\", \"About\")) self.actionQuit.setText(_translate(\"MainWindow\", \"Quit\")) if __name__ == \"__main__\": import sys app = QtWidgets.QApplication(sys.argv) MainWindow = QtWidgets.QMainWindow() ui = Ui_MainWindow() ui.setupUi(MainWindow) MainWindow.show() sys.exit(app.exec_()) main.ui MainWindow 0 0 800 600 MainWindow -15 -29 871 581 0 0 800 22 File About Quit Binary Genetic Algorithm #encoding=utf8 # genetic.py # import random import operator # for Intersect from math import * MAXIMIZE, MINIMIZE = 11, 22 class Individual: # 染色體先設為 None chromosome = None # 得分也先設為 None score = None # Here the size of var depends on var_number print # var 變數的元素個數取決於 var_number 的個數 (即變數個數) var = [] # 表示適應值變數個數有兩個 var_number = 2 #先將 var 數列中元素都設為 0 for i in range(var_number): var.append(0) # 等位基因表示各基因可選的內容, 這裡表示不是 0 就是 1 alleles = (0,1) # 2**10 = 32*32 = 1024, 表示若用十個 binary 位數來表示整數, 可以表示從 0 到 1023 的數值大小 # 若也用另外 十個 binary 位數來表示小數值, 則也是 0 到 1023 的數值表示能力, # 而再加一個表示正負的代表 binary 位數, 每一個變數需要 21 個 binary numbers # 以下為參數可負數時的編碼考量 #前10為小數,後10為整數,第21則為正負號 #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號. #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號 #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號 # -1023 ~ 1023 #length = 21*var_number,若接受負數參數,則必須同步修改 20->21 # 因為這裡只接受正的變數值, 所以每一個變數需要 20 個 binary 位數 length = 20*var_number seperator = '' optimization = MINIMIZE def __init__(self, chromosome=None): self.chromosome = chromosome or self._makechromosome() self.score = None # set during evaluation ''' bitwise operators (binary left shift): The left operands value is moved left by the number of bits specified by the right operand. x << y Returns x with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is the same as multiplying x by 2**y. ''' # 根據染色體各位元的值轉為 10 進位值 def _getvar(self, chromosome=None): # x 起始值設為 0 x = 0 for i in range(0, self.var_number): # 先根據前 20 個位元值, 透過 binary left shift 轉為 10 進位之後, 再轉為對應小數 for j in range(i*20, i*20+10): x += self.chromosome[j]<<(j-(i*20)) # 因為前 20 個 binary 數, 負責 10 進位數的小數點後 3 個位數, 只要轉為 10 進位值之後, 若大於 999, 則僅取 999, # 再除以 1000, 可以得到 .999 表示 .999 為最大的小數表示數, 不要因為大於 1000 後若除以 1000 將進位到整數, 會與整數有交互影響 if (x>999): x = 999 x /= 1000. # 整數部份 0 ~ 1023 的表示範圍則沒有問題, 利用 bitwise 轉換後, 直接取整數值 for j in range(i*20+10, i*20+20): x += self.chromosome[j]<<(j-(i*20+10)) self.var[i] = x return self.var ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings #for design variable -1023 ~1023 for i in range(self.var_number): x = 0 for j in range(i*21, i*21+10): x += self.chromosome[j]<<(j-(i*21)) if (x>999): x = 999 x /= 1000. for j in range(i*(21)+10, i*(21)+20): x += self.chromosome[j]<<(j-(i*21+10)) # 各變數範圍第 21 位數若為 1, 則表示該數為負數 if(self.chromosome[i*(21)+20] == 1): self.var[i] = -x else: self.var[i] = x # 讓 x 再設回原值 0 表示內定各變數為正數 x = 0 return self.var ''' # 建立染色體 def _makechromosome(self): \"makes a chromosome from randomly selected alleles.\" return [random.choice(self.alleles) for gene in range(self.length)] # 計算適應值 def evaluate(self, optimum=None): \"this method MUST be overridden to evaluate individual fitness score.\" pass # 交配方法 def crossover(self, other): \"override this method to use your preferred crossover method.\" return self._twopoint(other) # 突變方法 def mutate(self, gene): \"override this method to use your preferred mutation method.\" self._pick(gene) # sample mutation method def _pick(self, gene): \"chooses a random allele to replace this gene's allele.\" self.chromosome[gene] = random.choice(self.alleles) # sample crossover method def _twopoint(self, other): \"creates offspring via two-point crossover between mates.\" left, right = self._pickpivots() def mate(p0, p1): chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容 chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因 child = p0.__class__(chromosome) child._repair(p0, p1) return child return mate(self, other), mate(other, self) # some crossover helpers ... def _repair(self, parent1, parent2): \"override this method, if necessary, to fix duplicated genes.\" pass def _pickpivots(self): left = random.randrange(1, self.length-2) right = random.randrange(left, self.length-1) return left, right # # other methods # def __repr__(self): \"returns string representation of self\" ''' return '<%s chromosome=\"%s\" score=%s var=%s>' % \\ (self.__class__.__name__, self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome)) ''' return '<%s score=%s var=%s>' % \\ (self.__class__.__name__,self.score,self._getvar(self.chromosome)) # since the __cmp__ special function is gone use the __lt__ in stead # use the expression (a > b) - (a < b) as the equivalent for cmp(a, b) #def __cmp__(self, other): # these are for python 3 def __cmp__(self, other): if self.optimization == MINIMIZE: #return cmp(self.score, other.score) return (self.score > other.score) - (self.score < other.score) else: # MAXIMIZE #return cmp(other.score, self.score) return (other.score > self.score) - (other.score < self.score) def __lt__(self, other): return self.__cmp__(other) < 0 def __le__(self, other): return self.__cmp__(other) <= 0 def __gt__(self, other): return self.__cmp__(other) > 0 def __ge__(self, other): return self.__cmp__(other) >= 0 def copy(self): twin = self.__class__(self.chromosome[:]) twin.score = self.score return twin class Environment(object): x = [0] y = [0] def __init__(self, kind, population=None, size=100, maxgenerations=100, crossover_rate=0.90, mutation_rate=0.07, optimum=None): self.kind = kind self.size = size self.optimum = optimum self.population = population or self._makepopulation() for individual in self.population: individual.evaluate(self.optimum) self.crossover_rate = crossover_rate self.mutation_rate = mutation_rate self.maxgenerations = maxgenerations self.generation = 0 self.report() def _makepopulation(self): return [self.kind() for individual in range(self.size)] def run(self): while not self._goal(): self.step() def _goal(self): return self.generation > self.maxgenerations or \\ self.best.score == self.optimum def step(self): # this sort is not working with python 3.0, modification is needed self.population.sort() self._crossover() self.generation += 1 self.report() self.x.append(self.generation) # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值 if self.best.score <=5: self.y.append(self.best.score) else: self.y.append(5) def _crossover(self): next_population = [self.best.copy()] while len(next_population) < self.size: mate1 = self._select() if random.random() < self.crossover_rate: mate2 = self._select() offspring = mate1.crossover(mate2) else: offspring = [mate1.copy()] for individual in offspring: self._mutate(individual) individual.evaluate(self.optimum) next_population.append(individual) self.population = next_population[:self.size] def _select(self): \"override this to use your preferred selection method\" return self._tournament() def _mutate(self, individual): for gene in range(individual.length): if random.random() < self.mutation_rate: individual.mutate(gene) # # sample selection method # def _tournament(self, size=8, choosebest=0.90): competitors = [random.choice(self.population) for i in range(size)] competitors.sort() if random.random() < choosebest: return competitors[0] else: return random.choice(competitors[1:]) def best(): doc = \"individual with best fitness score in population.\" def fget(self): return self.population[0] return locals() best = property(**best()) def report(self): try: print (\"=\"*70) print (\"generation: \", self.generation) print (\"best: \", self.best) except: g.es (\"=\"*70) g.es (\"generation: \", self.generation) g.es (\"best: \", self.best) # 以上為 genetic.py 目前將兩者結合在一起 #encoding=utf8 # volume.py - useage example # # the fittest individual will have a chromosome consisting of 40 '1's # # #import genetic class Volume(Individual): optimization = MAXIMIZE def evaluate(self, optimum=None): SURFACE = 80 # self.score is the fitness value self._getvar(self.chromosome) x = self.var[0] y = self.var[1] z=(SURFACE - x*y)/(2.*(x+y)) fitness_value = x*y*z self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip class Intersect(Individual): optimization = MINIMIZE def evaluate(self, optimum=None): # self.score is the fitness value self._getvar(self.chromosome) t = self.var[0] deg = pi/180 theta = self.var[1]*deg xtarget = 0.75/2 ytarget = 0.5 x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2 y = (-3*t/2 + 123/92)*sin(theta) # 適應值 fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8) # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰 if t > 1: fitness_value += 1000 if t < 0: fitness_value += 1000 # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰 if theta > 2*pi: fitness_value += 1000 if theta < 0: fitness_value += 1000 self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip if __name__ == \"__main__\": env = Environment(Volume, size=500, maxgenerations=100) #env = Environment(Intersect, size=500, maxgenerations=100) env.run() Deap 與 Scoop Deap: https://github.com/DEAP/deap Scoop: https://en.wikipedia.org/wiki/Python_SCOOP_(software) https://groups.google.com/forum/#!topic/deap-users/v3wbky0EUf0 https://groups.google.com/forum/m/#!msg/deap-users/P4IkiE-Bvbg/xSoMDphbMR4J 平行運算 http://research.cs.wisc.edu/htcondor/ https://github.com/J-Robinson/GridGA 利用 Blender 製作 Essence of calculus Essence of linear algebra","tags":"Research","url":"https://kmolab.github.io/blog/first-simulation-blog.html"},{"title":"軟硬體設置","text":"紀錄電腦與網路的軟硬體相關設置 Github, Bitbucket 與 Fossil SCM Github 目前提供的免費帳號, 允許多人協同提交推送版本, 唯一的限制就是單一檔案不能大於 50 MB. Bitbucket 則允許免費使用非公開的倉儲, 但是至多只允許五個帳號協同. Fossil SCM 則適合在近端或區域網路中使用, 目前 KMOLab 希望在區網中導入作為與 Github Pages 配合的工具, 使用者可以將 Fossil SCM 的 working directory 限縮在 Github 近端倉儲的特定目錄下, 且在 .gitignore 中排除 FOSSIL (under Windows) 的版次管理, 但是相關的 fossil update 與 fossil server 功能仍然必須依照特定的流程進行操作, 以避免兩套版次管理系統內容的不同步導致資料覆蓋流失. github 倉儲與 bitbucket 倉儲, 則可以利用 git remote add 同步. Leo Editor, Pelican 與 Reveal.js Leo Editor 是一套能夠以程式方法有效管理多元資料的文字資料編輯器, 以下就是用來管理 KMOLab Pelican 靜態網誌有關內容的畫面, 其中的 @button local-blog 是用來產生靜態網誌的指令按鈕, @button github-blog 則是用來產生嵌入 Disqus 留言系統的 Github Pages 網誌對應指令, 兩個指令的差別在於使用不同的設定檔案, 使用者可以先利用近端的按鈕, 建立網誌後在近端以另一個 https-server 按鈕建立 https 伺服, 用瀏覽器檢查所產生的網誌內容, 一旦要送到 Github 倉儲, 必須再利用遠端按鈕產生另外一組網誌與搜尋用 .json 檔案後, 再提交推送到倉儲. 在這個過程中, 使用者依照 Pelican 的特定 Markdown 檔案編寫網誌內容外, Leo Editor 專案檔中也可以放入其他有關的註記與設定檔案編輯用的節點. 若需要在 Pelican 的環境中修改設定, 都可以全部在一個 Leo Editor 專案檔中完成. Leo Editor 另外一項有用的特定就是能夠利用從屬節點關係與內文指令來表示複雜的 html 檔案, 如下圖所示, 各段落的超文件標註可以利用節點加以切割, 使用者在編寫 reveal.js 投影片時, 可以只集中在特定簡報內容的編寫, 並且透過節點的複製與搬移, 甚至使用 Leo Editor 的節點 clone 功能, 同步相同內容但是同時出現在不同位置的節點. Pelican Blog 共用設定檔案: pelicanconf.py #!/usr/bin/env python # -*- coding: utf-8 -*- # from __future__ import unicode_literals AUTHOR = 'KMOL' SITENAME = 'KMOLab 機械設計工程' # 不要用文章所在目錄作為類別 USE_FOLDER_AS_CATEGORY = False #PATH = 'content' #OUTPUT_PATH = 'output' TIMEZONE = 'Asia/Taipei' DEFAULT_LANG = 'en' # Feed generation is usually not desired when developing FEED_ALL_ATOM = None CATEGORY_FEED_ATOM = None TRANSLATION_FEED_ATOM = None AUTHOR_FEED_ATOM = None AUTHOR_FEED_RSS = None # Blogroll LINKS = (('Pelican', 'http://getpelican.com/'), ('pelican-bootstrap3', 'https://github.com/DandyDev/pelican-bootstrap3/'), ('pelican-plugins', 'https://github.com/getpelican/pelican-plugins'), ('Tipue search', 'https://github.com/Tipue/Tipue-Search'),) # Social widget #SOCIAL = (('You can add links in your config file', '#'),('Another social link', '#'),) DEFAULT_PAGINATION = 10 # Uncomment following line if you want document-relative URLs when developing #RELATIVE_URLS = True # 必須絕對目錄或相對於設定檔案所在目錄 PLUGIN_PATHS = ['plugin'] PLUGINS = ['summary', 'tipue_search', 'sitemap'] # for sitemap plugin SITEMAP = { 'format': 'xml', 'priorities': { 'articles': 0.5, 'indexes': 0.5, 'pages': 0.5 }, 'changefreqs': { 'articles': 'monthly', 'indexes': 'daily', 'pages': 'monthly' } } # search is for Tipue search DIRECT_TEMPLATES = (('index', 'tags', 'categories', 'authors', 'archives', 'search')) # for pelican-bootstrap3 theme settings #TAG_CLOUD_MAX_ITEMS = 50 DISPLAY_CATEGORIES_ON_SIDEBAR = True DISPLAY_RECENT_POSTS_ON_SIDEBAR = True DISPLAY_TAGS_ON_SIDEBAR = True DISPLAY_TAGS_INLINE = True TAGS_URL = \"tags.html\" CATEGORIES_URL = \"categories.html\" MENUITEMS = [('About', '/blog/pages/about/')] #SHOW_ARTICLE_AUTHOR = True #MENUITEMS = [('Home', '/'), ('Archives', '/archives.html'), ('Search', '/search.html')] 遠端 publishconf.py #!/usr/bin/env python # -*- coding: utf-8 -*- # from __future__ import unicode_literals # This file is only used if you use `make publish` or # explicitly specify it as your config file. import os import sys sys.path.append(os.curdir) from pelicanconf import * # 因為 publishconf.py 在 pelicanconf.py 之後, 因此若兩處有相同變數的設定, 將以較後讀入的 publishconf.py 中的設定為主. # 將所有靜態 html 檔案移到 blog 子目錄 SITEURL = 'https://kmolab.github.io/blog' # 此設定用於將資料送到 gh-pages, 因此使用絕對 URL 設定 RELATIVE_URLS = False # 為了要讓 local 與 gh-pages 上都能夠使用 Tipue search, 可能要採用不同的 theme THEME = 'theme/pelican-bootstrap3' #BOOTSTRAP_THEME = 'readable' #BOOTSTRAP_THEME = 'readable-old' BOOTSTRAP_THEME = 'united' #PYGMENTS_STYLE = 'paraiso-drak' #PYGMENTS_STYLE = 'fruity' # 為了同時兼容 render_math, 必須放棄 fruity PYGMENTS_STYLE = 'monokai' FEED_ALL_ATOM = 'feeds/all.atom.xml' CATEGORY_FEED_ATOM = 'feeds/%s.atom.xml' DELETE_OUTPUT_DIRECTORY = True # Following items are often useful when publishing DISQUS_SITENAME = \"kmolabmde\" #GOOGLE_ANALYTICS = \"\" # 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定 DEFAULT_DATE = 'fs' # 遠端的 code hightlight #MD_EXTENSIONS = ['fenced_code', 'extra', 'codehilite(linenums=True)'] MARKDOWN = { 'extension_configs': { 'markdown.extensions.codehilite': {'css_class': 'highlight'}, 'markdown.extensions.extra': {}, 'markdown.extensions.meta': {}, }, 'output_format': 'html5', } # 若要依照日期存檔呼叫 #ARTICLE_URL = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/' #ARTICLE_SAVE_AS = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' PAGE_URL = 'pages/{slug}/' PAGE_SAVE_AS = 'pages/{slug}/index.html' SHOW_ARTICLE_AUTHOR = True local_publishconf.py #!/usr/bin/env python # -*- coding: utf-8 -*- # from __future__ import unicode_literals # This file is only used if you use `make publish` or # explicitly specify it as your config file. import os import sys sys.path.append(os.curdir) from pelicanconf import * # 因為 publishconf.py 在 pelicanconf.py 之後, 因此若兩處有相同變數的設定, 將以較後讀入的 publishconf.py 中的設定為主. # 請注意, 為了在近端讓 Tipue search 傳回的搜尋結果連結正確, 必須使用 ./ SITEURL = './' # 此設定用於近端靜態網頁查驗, 因此使用相對 URL RELATIVE_URLS = True # 為了要讓 local 與 gh-pages 上都能夠使用 Tipue search, 可能要採用不同的 theme THEME = 'theme/pelican-bootstrap3_local' #BOOTSTRAP_THEME = 'readable' #BOOTSTRAP_THEME = 'readable-old' BOOTSTRAP_THEME = 'united' #PYGMENTS_STYLE = 'paraiso-drak' #PYGMENTS_STYLE = 'fruity' # 為了同時兼容 render_math, 必須放棄 fruity PYGMENTS_STYLE = 'monokai' FEED_ALL_ATOM = 'feeds/all.atom.xml' CATEGORY_FEED_ATOM = 'feeds/%s.atom.xml' DELETE_OUTPUT_DIRECTORY = True # Following items are often useful when publishing #DISQUS_SITENAME = \"kmolabmde\" #GOOGLE_ANALYTICS = \"\" # 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定 DEFAULT_DATE = 'fs' # 近端的 code hightlight #MD_EXTENSIONS = ['fenced_code', 'extra', 'codehilite(linenums=True)'] MARKDOWN = { 'extension_configs': { 'markdown.extensions.codehilite': {'css_class': 'highlight'}, 'markdown.extensions.extra': {}, 'markdown.extensions.meta': {}, }, 'output_format': 'html5', } # 若要依照日期存檔呼叫 #ARTICLE_URL = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' #ARTICLE_SAVE_AS = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' PAGE_URL = 'pages/{slug}/' PAGE_SAVE_AS = 'pages/{slug}/index.html' SHOW_ARTICLE_AUTHOR = True 區網中的 IPv4 與 IPv6 WWW Server Pelican 在近端產生 weblog 後, 若要在近端以 https 檢視結果, 就必須同時建立 https Server. 近端 IPv4 WWW 伺服器程式: import os import subprocess import threading import http.server, ssl def domake(): # build directory os.chdir(\"./../\") server_address = ('localhost', 5443) httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler) httpd.socket = ssl.wrap_socket(httpd.socket, server_side=True, certfile='localhost.crt', keyfile='localhost.key', ssl_version=ssl.PROTOCOL_TLSv1) print(os.getcwd()) print(\"5443 https server started\") httpd.serve_forever() # 利用執行緒執行 https 伺服器 make = threading.Thread(target=domake) make.start() 近端 IPv6 ＷＷＷ 伺服器程式: import os import subprocess import threading import socket import http.server, ssl class HTTPServerV6(http.server.HTTPServer): address_family = socket.AF_INET6 def domake(): # build directory os.chdir(\"./../\") ipv6_address = '::1' server_address = (ipv6_address, 6443) #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler) httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler) httpd.socket = ssl.wrap_socket(httpd.socket, server_side=True, certfile='localhost.crt', keyfile='localhost.key', ssl_version=ssl.PROTOCOL_TLSv1) print(\"6443 https server started\") httpd.serve_forever() # 利用執行緒執行 https 伺服器 make = threading.Thread(target=domake) make.start()","tags":"Research","url":"https://kmolab.github.io/blog/first-setup-blog.html"}]}