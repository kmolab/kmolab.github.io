{"pages":[{"title":"About","text":"機械設計工程 KMOLab 倉儲 KMOLab 倉儲: https://github.com/kmolab/kmolab.github.io KMOLab 投影片: https://kmolab.github.io KMOLab 網誌: https://kmolab.github.io/blog Contact: kmolab At mde dot tw KMOLab 信念 二十一世紀的科技大學, 在培育具世界觀與在地文化素養, 能適應環境並成功面對挑戰之專業人才. 所謂專業, 即具有專長, 能夠就業之謂. 所謂文化者, 因思考及概念而有之教化. 所謂素養, 即平日的涵養. Excellence is an art won by training and habituation. We do not act rightly because we have virtue or excellence, but we rather have those because we have acted rightly. We are what we repeatedly do. Excellence, then, is not an act but a habit. — Aristotle (384 BC – March 7, 322 BC) 卓越須經由訓練與習慣養成才能獲得。並非具備品德或卓越能讓人舉止得宜，反而是舉止得宜能讓人卓越。經過切身重複實作，才可體會，卓越並非一種作為，而是習慣。 — 亞理士多德 (西元前 384 年 – 西元前 322 年 3 月 7 日) 體魄康強, 精神活潑, 舉止端莊, 人格健全, 便是大學生的風度. 不倦的追求真理, 熱烈的愛護國家, 積極的造福人類, 才是大學生的職志. — 羅家倫 (1928) KMOLab 標誌","tags":"misc","url":"./pages/about/"},{"title":"Sunset of OpenShift Online 2 Platform","text":"OpenShift 在 2017.08.25 於 https://blog.openshift.com/migrate-to-v3-v2-eol/ 宣布, 先前所推出的 Online 2 Platform, 將要在 2017.09.30 走入歷史. 為了因應這個變化, 許多過去所建立的網站資料將要轉到 Github 與 Fossil SCM. https://wordpress-2015course.rhcloud.com/ 有用的連結 Free Math Books http://www.openculture.com/free-math-textbooks Kinematic Synthesis of Linkage http://ebooks.library.cornell.edu/k/kmoddl/toc_hartenberg1.html the kinematic models for design http://ebooks.library.cornell.edu/k/kmoddl/about.html CSS 與 Div 取代 Table https://sofree.cc/css-table/ http://www.flycan.com/article/css/css-float-442.html 以 http://2016spring-cadlab.rhcloud.com 取出舊版程式? cadlab At mde 備份: https://wordpress-2015course.rhcloud.com/?p=4579 Product Design Modeling using CAD/CAE How to be a star engineer http://ieeexplore.ieee.org/document/795608/","tags":"Course","url":"./sunset-of-openshift-online2.html"},{"title":"Calculator in PyQt5 and Eric6","text":"根據 http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html 的說明, 利用 Eric6 與 PyQt5 開發簡單的計算器視窗程式. Flask 與 Javascript 建立簡單計算器: Buttons are grouped in categories according to their behavior. For example, all the digit buttons (labeled 0 to 9) append a digit to the current operand. For these, we connect multiple buttons to the same slot (e.g., digitClicked()). The categories are digits, unary operators (Sqrt, x², 1/x), additive operators (+, -), and multiplicative operators (×, ÷). The other buttons have their own slots. The private createButton() function is used as part of the widget construction. abortOperation() is called whenever a division by zero occurs or when a square root operation is applied to a negative number. calculate() applies a binary operator (+, -, ×, or ÷). These variables, together with the contents of the calculator display (a QLineEdit), encode the state of the calculator: sumInMemory contains the value stored in the calculator's memory (using MS, M+, or MC). sumSoFar stores the value accumulated so far. When the user clicks =, sumSoFar is recomputed and shown on the display. Clear All resets sumSoFar to zero. factorSoFar stores a temporary value when doing multiplications and divisions. pendingAdditiveOperator stores the last additive operator clicked by the user. pendingMultiplicativeOperator stores the last multiplicative operator clicked by the user. waitingForOperand is true when the calculator is expecting the user to start typing an operand. Additive and multiplicative operators are treated differently because they have different precedences. For example, 1 + 2 ÷ 3 is interpreted as 1 + (2 ÷ 3) because ÷ has higher precedence than +. The table below shows the evolution of the calculator state as the user enters a mathematical expression. Waiting for Operand? 等待運算處理對象? Add. Op. - 加或減運算元,若隨後無乘與除等優先運算元, 且按下等於或接著按加或減運算元, 則前段隨即完成運算後列在 Sum so Far 欄位. Mul. Op. - 乘或除運算元, 屬於優先運算元, 因此若輸入已經滿足運算數接優先運算元, 再接其他運算元則 將局部優先運算所需的前方運算數, 放入 Factor so Far, 而前面未處理的加或減運算數, 則放入 Sum so Far. User Input Display Sum so Far Add. Op. Factor so Far Mult. Op. Waiting for Operand? 0 0 true 1 1 0 false 1 + 1 1 + true 1 + 2 2 1 + false 1 + 2 ÷ 2 1 + 2 ÷ true 1 + 2 ÷ 3 3 1 + 2 ÷ false 1 + 2 ÷ 3 - 1.66667 1.66667 - true 1 + 2 ÷ 3 - 4 4 1.66667 - false 1 + 2 ÷ 3 - 4 = -2.33333 0 true Unary operators, such as Sqrt, require no special handling; they can be applied immediately since the operand is already known when the operator button is clicked. Finally, we declare the variables associated with the display and the buttons used to display numerals. In the constructor, we initialize the calculator's state. The pendingAdditiveOperator and pendingMultiplicativeOperator variables don't need to be initialized explicitly, because the QString constructor initializes them to empty strings. We create the QLineEdit representing the calculator's display and set up some of its properties. In particular, we set it to be read-only. We also enlarge display's font by 8 points. For each button, we call the private createButton() function with the proper text label and a slot to connect to the button. The layout is handled by a single QGridLayout. The QLayout::setSizeConstraint() call ensures that the Calculator widget is always shown as its optimal size (its size hint), preventing the user from resizing the calculator. The size hint is determined by the size and size policy of the child widgets. Most child widgets occupy only one cell in the grid layout. For these, we only need to pass a row and a column to QGridLayout::addWidget(). The display, backspaceButton, clearButton, and clearAllButton widgets occupy more than one column; for these we must also pass a row span and a column span. Pressing one of the calculator's digit buttons will emit the button's clicked() signal, which will trigger the digitClicked() slot. First, we find out which button sent the signal using QObject::sender(). This function returns the sender as a QObject pointer. Since we know that the sender is a Button object, we can safely cast the QObject. We could have used a C-style cast or a C++ static_cast<>(), but as a defensive programming technique we use a qobject_cast(). The advantage is that if the object has the wrong type, a null pointer is returned. Crashes due to null pointers are much easier to diagnose than crashes due to unsafe casts. Once we have the button, we extract the operator using QToolButton::text(). The slot needs to consider two situations in particular. If display contains \"0\" and the user clicks the 0 button, it would be silly to show \"00\". And if the calculator is in a state where it is waiting for a new operand, the new digit is the first digit of that new operand; in that case, any result of a previous calculation must be cleared first. At the end, we append the new digit to the value in the display. The unaryOperatorClicked() slot is called whenever one of the unary operator buttons is clicked. Again a pointer to the clicked button is retrieved using QObject::sender(). The operator is extracted from the button's text and stored in clickedOperator. The operand is obtained from display. Then we perform the operation. If Sqrt is applied to a negative number or 1/x to zero, we call abortOperation(). If everything goes well, we display the result of the operation in the line edit and we set waitingForOperand to true. This ensures that if the user types a new digit, the digit will be considered as a new operand, instead of being appended to the current value. The additiveOperatorClicked() slot is called when the user clicks the + or - button. Before we can actually do something about the clicked operator, we must handle any pending operations. We start with the multiplicative operators, since these have higher precedence than additive operators: If × or ÷ has been clicked earlier, without clicking = afterward, the current value in the display is the right operand of the × or ÷ operator and we can finally perform the operation and update the display. If + or - has been clicked earlier, sumSoFar is the left operand and the current value in the display is the right operand of the operator. If there is no pending additive operator, sumSoFar is simply set to be the text in the display. Finally, we can take care of the operator that was just clicked. Since we don't have the right-hand operand yet, we store the clicked operator in the pendingAdditiveOperator variable. We will apply the operation later, when we have a right operand, with sumSoFar as the left operand. The multiplicativeOperatorClicked() slot is similar to additiveOperatorClicked(). We don't need to worry about pending additive operators here, because multiplicative operators have precedence over additive operators. Like in additiveOperatorClicked(), we start by handling any pending multiplicative and additive operators. Then we display sumSoFar and reset the variable to zero. Resetting the variable to zero is necessary to avoid counting the value twice. The pointClicked() slot adds a decimal point to the content in display. The changeSignClicked() slot changes the sign of the value in display. If the current value is positive, we prepend a minus sign; if the current value is negative, we remove the first character from the value (the minus sign). The backspaceClicked() removes the rightmost character in the display. If we get an empty string, we show \"0\" and set waitingForOperand to true. The clear() slot resets the current operand to zero. It is equivalent to clicking Backspace enough times to erase the entire operand. The clearAll() slot resets the calculator to its initial state. The clearMemory() slot erases the sum kept in memory, readMemory() displays the sum as an operand, setMemory() replace the sum in memory with the current sum, and addToMemory() adds the current value to the value in memory. For setMemory() and addToMemory(), we start by calling equalClicked() to update sumSoFar and the value in the display. The private createButton() function is called from the constructor to create calculator buttons. The private abortOperation() function is called whenever a calculation fails. It resets the calculator state and displays \"####\". The private calculate() function performs a binary operation. The right operand is given by rightOperand. For additive operators, the left operand is sumSoFar; for multiplicative operators, the left operand is factorSoFar. The function return false if a division by zero occurs.","tags":"Course","url":"./calculator-pyqt5-eric6.html"},{"title":"Create a Multi-repository Fossil SCM Server","text":"In order to create a multi-repository Fossil SCM server on Ubuntu 16.04 environment, three steps are needed. Step 1: install Stunnel and Fossil SCM sudo apt update sudo apt install stunnel4 -y sudo apt install fossil Edit /etc/environment file and add the following setup to allow only the https connections: HTTPS=on Edit /etc/default/stunnel4 file and modified the ENABLED value from 0 to 1 to get stunnel service running when the computer startup: ENABLED=1 Step 2: Stunnel setup Change directory to /etc/stunnel/ and use the following command to generate localhost.key and localhost.crt files. sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt edit stunnel.conf configuration file under /etc/stunnel/ as follows: [https] accept = your_IPv4_ip:443 accept = :::443 cert = /etc/stunnel/localhost.crt key = /etc/stunnel/localhost.key exec = /usr/bin/fossil execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound default which means the IPv4 and IPv6 requests are both accepted under port 443. And /home/user/repository/ is used to store the Fossil SCM repo files. The default repo file is /home/user/repository/default.fossil The setting of \"--notfound default\" means if the repository file is not specified, connection URL is default which is a relative directory associated with the server main URL. Step 3: create Fossil SCM repositories Change directory to /home/user/repository and use \"fossil init default.fossil\" command to create the default repository. If more repository is needed, also use \"fossil init other.fossil\" to create other.fossil repository under /home/user/repository. After the setup use \"/etc/init.d/stunnel4 restart\" command to restart the Stunnel service. Use https://site-url:443/ to connect to default.fossil and use https://site-url:443/other to connect to other.fossil.","tags":"Course","url":"./create-a-multi-repository-fossil-scm-server.html"},{"title":"2015 Fall CADP W16","text":"根據 Nutcracker 機構 的尺寸規格, 請設法算出 Piston 零件的有效運動範圍. 計算 Piston 不發生干涉的有效行程, 可採如下方法: 實際利用 Onshape 中的組立, 移動 piston 零件, 靠目測概略決定 piston 的有效行程. (目測法, 只能得到大概的行程範圍) 利用 Solvespace 繪製 2D 約束圖, 然後利用約束點在線或圓上的方式, 以圖解法解出有效行程, 如下圖一, 圖二與圖三所示. (圖解法, 利用 Solvespace 既有的約束條件設定完成計算) 利用 Jupyter 與 Python3 的 sympy 模組, 先進行符號式推導, 然後再利用數值分析解出 piston 的有效行程, 機構各點標示如下圖四所示, 計算出 的 theta 轉角為 105.7, 如下圖五所示. (以自行編寫的 sympy 程式解題, 透過 Jupyterhub 可以有效進行協同設計運算) 除了上述的目測, 圖解與符號式結合數值分析法之外, 也可以採用 基因演算法解題 , 計算出的 theta 轉角為 105.7, 如下圖六所示. (利用演化法解題, 可以在單機運算, 也可以在 Jupyterhub 平台 上進行運算) 圖一: 利用 Solvespace 中的繪圖約束條件找出右邊的極限點距離 Onshape Piston 組立原點 0.5 圖二: 利用 Solvespace 中的繪圖約束條件找出左邊的極限點距離 Onshape Piston 組立原點 2.23 圖三: 當 piston 位於左邊極限點時, AB 轉角為 105.37 度 圖四: Jupyter 計算分析時機構各點標示圖 圖五: 利用 Jupyter 符號式結合數值分析法所得結果 圖六: 利用基因演算解題, 所得到的結果, 當 piston 位於左邊極限點時, AB 轉角為 105.7 度 若採用 deap 與 numpy 解題 (AB 轉角極限為 105.71 度): # 這裡採用 numpy 與 deap 模組解題, 使用 Genetic Algorithm 模式 # 解的問題為 Nutcracker 左邊 connect 轉角極限 import random import array from deap import base from deap import creator from deap import tools import numpy # for evalIntersect 函式中的 sqrt, sin, cos, pi from math import * # 1/4 最小化題目 type of problem creator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,)) creator.create(\"Individual\", array.array, typecode='d', \\ fitness=creator.FitnessMin) # 2/4 initilization # 兩個變數題目 NDIM = 2 toolbox = base.Toolbox() toolbox.register(\"attr_float\", random.uniform, 0, 5) toolbox.register(\"individual\", tools.initRepeat, creator.Individual, toolbox.attr_float, NDIM) toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual) # 3/4 選擇 operator step3/4 toolbox.register(\"select\", tools.selRandom, k=3) # 也可以採用下列設定 #toolbox.register(\"mate\", tools.cxTwoPoint) #toolbox.register(\"mutate\", tools.mutGaussian, mu=0, sigma=1, indpb=0.1) #toolbox.register(\"select\", tools.selTournament, tournsize=3, k=3) def evalIntersect(individual): t = individual[0] deg = pi/180 theta = individual[1]*deg xtarget = 0.75/2 ytarget = 0.5 x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 \\ + 529)/92 + 3*cos(theta)/2 y = (-3*t/2 + 123/92)*sin(theta) # 適應值 fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8) # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰 if t > 1: fitness_value += 1000 if t < 0: fitness_value += 1000 # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰 if theta > 2*pi: fitness_value += 1000 if theta < 0: fitness_value += 1000 return fitness_value, toolbox.register(\"evaluate\", evalIntersect) # 以上到 evaluate 為止, 為定義 operators # 4/4 以下則為 Algorithms def main(): # Differential evolution parameters CR = 0.25 F = 1 MU = 300 NGEN = 200 pop = toolbox.population(n=MU); hof = tools.HallOfFame(1) stats = tools.Statistics(lambda ind: ind.fitness.values) stats.register(\"avg\", numpy.mean) stats.register(\"std\", numpy.std) stats.register(\"min\", numpy.min) stats.register(\"max\", numpy.max) # Evaluate the individuals fitnesses = toolbox.map(toolbox.evaluate, pop) for ind, fit in zip(pop, fitnesses): ind.fitness.values = fit for g in range(1, NGEN): for k, agent in enumerate(pop): a,b,c = toolbox.select(pop) y = toolbox.clone(agent) index = random.randrange(NDIM) for i, value in enumerate(agent): if i == index or random.random() < CR: y[i] = a[i] + F*(b[i]-c[i]) y.fitness.values = toolbox.evaluate(y) if y.fitness > agent.fitness: pop[k] = y hof.update(pop) print(\"Best individual is \", hof[0], hof[0].fitness.values[0]) if __name__ == \"__main__\": main() 上述課程資料與 Wordpress 網頁 上的資料內容相同, Ｗordpress 網站屬於動態的網誌, 而 http://chiamingyen.github.io/kmolab/ 則是靜態網誌系統, 採用靜態網誌的優點如下: 比較安全 比較不會過時 部署成本比較低 可在各種平台上使用 各階段改版資料均有紀錄 以下為參考用的 GA 解 Nutcracker 題目的程式碼: #encoding=utf8 # genetic.py # import random import operator # for Intersect from math import * MAXIMIZE, MINIMIZE = 11, 22 class Individual: chromosome = None score = None # Here the size of var depends on var_number var = [] var_number = 2 for i in range(var_number): var.append(0) alleles = (0,1) # 以下為參數可負數時的編碼考量 #前10為小數,後10為整數,第21則為正負號 #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號. #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號 #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號 # -1023 ~ 1023 #length = 21*var_number,若接受負數參數,則必須同步修改 20->21 length = 20*var_number seperator = '' optimization = MINIMIZE def __init__(self, chromosome=None): self.chromosome = chromosome or self._makechromosome() self.score = None # set during evaluation def _getvar(self,chromosome=None): x = 0 for i in range(0,self.var_number): for j in range(i*20,i*20+10): x +=self.chromosome[j]<<(j-(i*20)) if (x>999): x=999 x/=1000. for j in range(i*20+10,i*20+20): x +=self.chromosome[j]<<(j-(i*20+10)) self.var[i] = x return self.var ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings #for design variable -1023 ~1023 for i in range(self.var_number): x = 0 for j in range(i*21,i*21+10): x +=self.chromosome[j]<<(j-(i*21)) if (x>999): x=999 x/=1000. for j in range(i*(21)+10,i*(21)+20): x +=self.chromosome[j]<<(j-(i*21+10)) if(self.chromosome[i*(21)+20] == 1): self.var[i] = -x else: self.var[i] = x x = 0 return self.var ''' def _makechromosome(self): \"makes a chromosome from randomly selected alleles.\" return [random.choice(self.alleles) for gene in range(self.length)] def evaluate(self, optimum=None): \"this method MUST be overridden to evaluate individual fitness score.\" pass def crossover(self, other): \"override this method to use your preferred crossover method.\" return self._twopoint(other) def mutate(self, gene): \"override this method to use your preferred mutation method.\" self._pick(gene) # sample mutation method def _pick(self, gene): \"chooses a random allele to replace this gene's allele.\" self.chromosome[gene] = random.choice(self.alleles) # sample crossover method def _twopoint(self, other): \"creates offspring via two-point crossover between mates.\" left, right = self._pickpivots() def mate(p0, p1): chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容 chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因 #child = p1.__class__(chromosome) 這是原先的程式,但是應該子代要指向 p0 的內容才對 child = p0.__class__(chromosome) child._repair(p0, p1) return child return mate(self, other), mate(other, self) # some crossover helpers ... def _repair(self, parent1, parent2): \"override this method, if necessary, to fix duplicated genes.\" pass def _pickpivots(self): left = random.randrange(1, self.length-2) right = random.randrange(left, self.length-1) return left, right # # other methods # def __repr__(self): \"returns string representation of self\" ''' return '<%s chromosome=\"%s\" score=%s var=%s>' % \\ (self.__class__.__name__, self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome)) ''' return '<%s score=%s var=%s>' % \\ (self.__class__.__name__,self.score,self._getvar(self.chromosome)) # since the __cmp__ special function is gone use the __lt__ in stead # use the expression (a > b) - (a < b) as the equivalent for cmp(a, b) #def __cmp__(self, other): # these are for python 3 def __cmp__(self, other): if self.optimization == MINIMIZE: #return cmp(self.score, other.score) return (self.score > other.score) - (self.score < other.score) else: # MAXIMIZE #return cmp(other.score, self.score) return (other.score > self.score) - (other.score < self.score) def __lt__(self, other): return self.__cmp__(other) < 0 def __le__(self, other): return self.__cmp__(other) <= 0 def __gt__(self, other): return self.__cmp__(other) > 0 def __ge__(self, other): return self.__cmp__(other) >= 0 def copy(self): twin = self.__class__(self.chromosome[:]) twin.score = self.score return twin class Environment(object): x = [0] y = [0] def __init__(self, kind, population=None, size=100, maxgenerations=100, crossover_rate=0.90, mutation_rate=0.07, optimum=None): self.kind = kind self.size = size self.optimum = optimum self.population = population or self._makepopulation() for individual in self.population: individual.evaluate(self.optimum) self.crossover_rate = crossover_rate self.mutation_rate = mutation_rate self.maxgenerations = maxgenerations self.generation = 0 self.report() def _makepopulation(self): return [self.kind() for individual in range(self.size)] def run(self): while not self._goal(): self.step() def _goal(self): return self.generation > self.maxgenerations or \\ self.best.score == self.optimum def step(self): # this sort is not working with python 3.0, modification is needed self.population.sort() self._crossover() self.generation += 1 self.report() self.x.append(self.generation) # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值 if self.best.score <=5: self.y.append(self.best.score) else: self.y.append(5) def _crossover(self): next_population = [self.best.copy()] while len(next_population) < self.size: mate1 = self._select() if random.random() < self.crossover_rate: mate2 = self._select() offspring = mate1.crossover(mate2) else: offspring = [mate1.copy()] for individual in offspring: self._mutate(individual) individual.evaluate(self.optimum) next_population.append(individual) self.population = next_population[:self.size] def _select(self): \"override this to use your preferred selection method\" return self._tournament() def _mutate(self, individual): for gene in range(individual.length): if random.random() < self.mutation_rate: individual.mutate(gene) # # sample selection method # def _tournament(self, size=8, choosebest=0.90): competitors = [random.choice(self.population) for i in range(size)] competitors.sort() if random.random() < choosebest: return competitors[0] else: return random.choice(competitors[1:]) def best(): doc = \"individual with best fitness score in population.\" def fget(self): return self.population[0] return locals() best = property(**best()) def report(self): print (\"=\"*70) print (\"generation: \", self.generation) print (\"best: \", self.best) # 以上為 genetic.py 目前將兩者結合在一起 #encoding=utf8 # volume.py - useage example # # the fittest individual will have a chromosome consisting of 40 '1's # # #import genetic #此一加總函式在 volume 最大化中,並未使用 def sum(seq): def add(x,y): return x+y return reduce(add, seq, 0) class Volume(Individual): optimization = MAXIMIZE def evaluate(self, optimum=None): SURFACE = 80 # self.score is the fitness value self._getvar(self.chromosome) x = self.var[0] y = self.var[1] z=(SURFACE - x*y)/(2.*(x+y)) fitness_value = x*y*z self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip class Intersect(Individual): optimization = MINIMIZE def evaluate(self, optimum=None): # self.score is the fitness value self._getvar(self.chromosome) t = self.var[0] deg = pi/180 theta = self.var[1]*deg xtarget = 0.75/2 ytarget = 0.5 x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2 y = (-3*t/2 + 123/92)*sin(theta) # 適應值 fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8) # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰 if t > 1: fitness_value += 1000 if t < 0: fitness_value += 1000 # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰 if theta > 2*pi: fitness_value += 1000 if theta < 0: fitness_value += 1000 self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip if __name__ == \"__main__\": #env = Environment(Volume, size=500, maxgenerations=100) env = Environment(Intersect, size=500, maxgenerations=100) env.run()","tags":"Course","url":"./2015-cadp-w16.html"},{"title":"計算機程式與電腦輔助設計實習","text":"以下為 Brython 網際程式環境. window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } 投影片: from browser import document, html container1 = document['container1'] adata = open(\"./../data/1a_list.txt\").read() alist = adata.splitlines() n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://s\"+str(stud_num)+\".github.io/2017springwcm_hw\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container1 <= mlink template slide 測試 LaTex 方程式寫法與轉換: $$H\\frac{d&#94;{2}\\theta (t)}{dt&#94;{2}} = gSin\\theta(t)+a_2(t)H-a_1(t)Cos\\theta(t)$$ 經過轉換成為: $$H\\frac{d&#94;{2}\\theta (t)}{dt&#94;{2}} = gSin\\theta(t)+a_2(t)H-a_1(t)Cos\\theta(t)$$ $$\\[L(\\mu,\\sigma;X)=\\sum_i\\left[-\\frac 1 2 \\ln(2\\pi)-\\ln(\\sigma)-\\frac{1}{2\\sigma&#94;2}(X_i-\\mu)&#94;2\\right]\\]$$ 經過轉換成為: $$[L(\\mu,\\sigma;X)=\\sum_i\\left[-\\frac 1 2 \\ln(2\\pi)-\\ln(\\sigma)-\\frac{1}{2\\sigma&#94;2}(X_i-\\mu)&#94;2\\right]]$$","tags":"Course","url":"./2017fall-cp-cadp.html"},{"title":"網際內容管理","text":"網際內容管理課程在教導學生, 利用電腦與網路軟硬體配置, 完成各項與機械設計內容管理有關的任務. 所謂網際指的是 Web-Based, 也就是 World-Wide-Web Based 的簡稱, 中文也可以翻為\"植基於全球資訊網\" 或 \"以全球資訊網為基礎\", 其內涵是希望讓使用者在網際網路 (Internet) 的基礎上, 利用 Web Browser (瀏覽器) 操作各種與機械設計內容管理有關的任務. Ubuntu 操作系統 根據 https://www.ubuntu.com/info/release-end-of-life 的生命週期年限, 選擇 LTS Server 版本安裝, 安裝過程需要安裝 OpenSSL 模組, 以及 ubuntu-desktop, Windows 客戶端則透過 xming 與 http://www.putty.org/ 進行安全的遠端登入. IPv4 與 IPv6 網路設定 一般來說, 只有必須擔負特定 WWW Server、DNS Server 與 Proxy Server 的主機需要同時支援 IPv4 與 IPv6 網路協定外, 其餘客戶端都可以只透過 IPv6 網路協定上網. WWW Server 使用 Nginx, DNS Serve 使用 Bind, 而 Proxy Server 則使用 Squid. Nginx Nginx WWW 伺服器通常用來伺服靜態文件或者作為其他近端伺服資料傳送的代理主機 (例如, uwsgi 網際服務). Ethercalc Ethercalc 允許多人利用瀏覽器同時維護一份線上試算表, 可以用於協同資料永久存檔前的轉介站. Fossil SCM Fossil SCM 是一套小而美的分散式資料管理系統 Squid Proxy Server 在 IPv4 轉換到 IPv6 的過程中, 雙網路協定支援的代理主機扮演非常重要的角色, 例如, 從純 IPv4 瀏覽器連線到純 IPv6 WWW 伺服器, 就需要透過雙網路協定的代理主機轉介資料, 其次 putty ssh 遠端登入或 sftp 安全資料傳送, 也都需要雙網路支援的代理主機居中轉換不同協定資料. X-windows Putty Leo Editor Filezilla 與 SFTP Uwsgi 與 CMSimfly","tags":"Course","url":"./wcm-course-1.html"},{"title":"協同產品設計實習","text":"協同產品設計課程在教導學生, 以同步或非同步協同方式, 利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.","tags":"Course","url":"./cd-course-1.html"},{"title":"電腦輔助設計實習","text":"電腦輔助設計課程在教導學生利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務. CAD Book: http://mde.tw/2016fallcadp/data/CAD_book.pdf Space Modeling with SolidWorks and NX http://beyondplm.com/2015/03/18/autodesk-and-onshape-disagree-about-cloud-technology-and-focus/ https://www.solidsmack.com/cad/onshape-comes-out-swinging-changes-mcad-pricing-forever/ https://newscrewdriver.com/category/3d-printing/3d-printing-software/fusion-360-vs-onshape/ eBook: State of Product Development / PLM 2016 http://image.engineering.com/239575/articles/Nov%202016/Autodesk%20Q615/Autodesk_pdf1R.pdf CADO: https://github.com/BGCECSE2015/CADO Electronics made easy: http://fritzing.org/home/ SFEPy: https://github.com/sfepy/sfepy http://nbviewer.jupyter.org/github/sukhbinder/sfepy-simple_tutorial/blob/master/Getting_Started_With_SFEPY_using_a_simpleplate_example.ipynb","tags":"Course","url":"./cadp-course-1.html"},{"title":"計算機程式","text":"計算機程式課程在教導學生利用電腦完成各項與機械設計流程有關的任務. 為什麼非學不可? https://cacm.acm.org/blogs/blog-cacm/166115-why-scientists-and-engineers-must-learn-programming/fulltext 首先, 看看機械設計流程會牽涉哪些任務, 所謂機械設計, 就是歷經詳細思慮考量, 完成互動元件間之精巧配置, 使其展現特定功能之具體規劃表達. 換言之, 機械設計是一種具體規劃的表達 (presentation), 其內容是經過一系列詳細的思慮與考量所得到的結果, 而此項結果通常有具體的功能, 並且包含許多互動 (interaction) 元件之間的彈性與精巧配置 (flexible and sophisticated configuration). 我們將上述與機械設計有關的關鍵字引列如下: 機械設計是一種表達, 此種表達可以利用文字、口語、2D 靜態圖像、3D 或影音動態圖像、理論分析或實體呈現. 機械設計的過程所需要的各種思慮與考量牽涉許多定性與定量的分析, 包含許多工程原理原則與實務經驗, 這些分析除了必須利用數學建立模型, 透過演算預先模擬外, 還需要使用有效率可協同的方式紀錄過程中所產生的各種資料. 機械設計產品中所包含的各種互動元件, 包括硬體元件、流體元件、軟體元件與管理元件等. 機械設計過程中, 為了在實體化之前能預先針對各種互動元件間的組成與配置進行最佳化, 因此需要使用各種逼真的模擬方法加以呈現. 如何進行文字、2D&3D表達 有沒有一種方法可以讓多名使用者協同管理一份文件, 其中包含各種互動式圖文與影音資料, 各使用者在編修內容過程可以有效對資料進行保全, 可以有效分散備份, 可以紀錄各編修者所增刪的內容, 可以透過有效率的方法散佈此份文件的內容? 使用工具的評量方法 機械設計工程師為了有效完成具體規劃內容的表達, 過程中必須使用各種類型的工具, 其中包括: 文字資料構建、管理與呈現的工具 (text) 2 口語資料構建、管理與呈現的工具 (oral) 2D 靜態圖像資料構建、管理與呈現的工具 (2d) 3D 或影音動態圖像資料構建、管理與呈現的工具 (3d) 理論分析資料構建、管理與呈現的工具 (analytical) 實體構建、管理與呈現的工具 (physical) 工具取得、維護使用成本與其他工具整合效能成本等 工具取得成本 (now and how) 維護更新與永續使用成本 (update and sustainable) 工具掌握度與整合效能成本 (integration) 一定要學 C C 是為建立 Unix 操作系統而生的程式語言, 也是近代許多高階程式語言建構的基礎, 例如, 最早的 C 程式編譯器雖然採用組合語言編寫, 但是隨後的 C 程式編譯器則可以採用舊版的 C 來編譯, 而 Python 解譯器在 1980 年代晚期出現時, 就是以 C 程式編寫, 之後雖然有採用 Java 編寫的 Jython (2001), 以 C# 編寫的 IronPython (2006), 以 RPython 編寫的 PyPy (2007), 以 Javascript 編寫的 Brython (2012), 但是 CPython 仍然是最通用的版本. 儘管 C 程式語言對於工程師而言非常重要, 但是 C 或更進階的 C++ 程式語言的學習並不容易, 並不只是因為 C/C++ 擁有指標, 能夠控制電腦的底層記憶體, 而是因為 C/C++ 程式語言所涵蓋的應用非常廣. 但是無論如何, 工程師一定要學會基本的 C 程式語言, 倒是毋庸置疑. https://www.asme.org/career-education/articles/teachers-academics/c-as-part-of-a-mechanical-engineering-curriculum C 的指標與陣列導引 http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html CP to CADP https://github.com/2015fallhw/cptocadp 如何完成下列工作? 1) 從一本英文書的文字檔中, 算出總字數, 並按照英文字母排列, 列出書中所使用的單字, 並查出各單字的中文解釋. 2) 從網站中擷取當天台幣與美金及英鎊的匯率, 並根據某一列有台幣、美金與英鎊的檔案進行各幣值的總結算. 3) 每組有六人, 某一任務需要完成六項工作, 每人負責一項, 但各工作間必須互相配合, 任務進行中需要完整呈現各組員每一階段所完成的內容細節, 請問該如何完成. 例如: 3 1 + 2 / 各數字與符號隔開, 表示 3 + 1 / 2 2 3 4 + 4 * 7 / 答案為? https://github.com/dustinrohde/python-rpn 4) 如何將材料特性 2D 圖表轉為電腦可以套用的文字檔或資料庫檔案? 漸開線正齒輪齒面寬運算 - 選擇正齒輪對所要傳遞的功率大小, 選擇所要使用的正齒輪齒數、模數與壓力角, 選擇齒輪的材質, 選擇小齒輪的齒數, 選擇安全係數, 從上述資料中算出齒輪齒面寬, 以便能在安全的範圍中, 不致產生過大噪音條件下完成所需功率的傳遞. 漸開線正齒輪 功率 齒數、模數與壓力角 齒輪的材質與強度 安全係數 振動與噪音 齒輪的鍵銷設計 齒輪的軸尺寸、強度與耐用度設計 軸承的選用設計 齒輪箱的設計 齒輪的潤滑與散熱設計 其他相關的設計分析、製造規劃與後勤維修等議題 5) 文字檔與數位檔案的差別與運用, 各種 2D 與 3D 零組件檔格式的讀取與轉換 https://en.wikipedia.org/wiki/AutoCAD_DXF http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf ASCII DXF File Format Binary DXF File Format https://en.wikipedia.org/wiki/STL_(file_format) http://www.fabbers.com/tech/STL_Format ASCII STL File Format Binary STL File Format IGES Version 5.3: http://paulbourke.net/dataformats/iges/IGES.pdf IGES Version 6: https://filemonger.com/specs/igs/devdept.com/version6.pdf https://en.wikipedia.org/wiki/IGES DXF, IGES and STEP: http://homepages.cae.wisc.edu/~me232/info/dxf_iges_step.pdf Python3 學習 Official Tutorial: https://docs.python.org/3/tutorial/ 10 min Python Tutorial help(), dir(), print(), range() , built-in types , 看影片自學: https://www.youtube.com/watch?v=D48iCw3WWpI http://www.spronck.net/pythonbook https://github.com/coodict/python3-in-one-pic/blob/master/notebooks/py3-in-one-pic.ipynb 資料分析: https://lectures.quantecon.org/py/ Python 很慢? https://www.youtube.com/watch?v=8hHOxfXcWsg https://www.youtube.com/watch?v=a8LsdodGoWQ PyQT https://kuanyui.github.io/2014/09/13/learn-python-via-pyqt/ 網際程式繪圖","tags":"Course","url":"./cp-course-1.html"},{"title":"大學生為何不來上課?","text":"所謂論述 (Discussion) 就是針對特定議題的敘述與分析, 例如: 討論有關大學生為何不來上課? 就應該是一篇論述. 大學生為何不來上課? 首先就大學生上課, 有幾項基本組成: 時段、課程內容、教師與學生等. 因此, 大學生之所以不想來上課, 可能是因為時段太早, 學生爬不起來而翹課; 也可能是課程內容不能讓學生認同, 內容太過簡單, 內容太過困難等原因, 讓學生視上課為畏途, 一有機會就不願意到課; 另外也可能是老師的教學方式得不到學生認同, 因此不願意上課; 最後則是學生本身的心態, 完全不知道為何要上這門課, 或者如何克服課程中所碰到的困難等問題, 導致學生一逮到機會就斷然翹課. 時段太早爬不起床 因時段太早而翹課, 大家都知道這絕對是藉口, 也就是說, 這不是學生翹課的主要原因, 而是因為其他主要原因的影響下, 讓學生拿時段太早當作翹課的藉口. 內容太淺, 內容太深 接著來談談因為課程內容無法得到學生認同而翹課的因素, 一般而說, 過去循序漸進, 以靜態課本內容為主的教學, 較能得到學生的認同, 因為所有會涵蓋的教學內容, 都已經鉅細靡遺列在教科書中, 因此針對此類型的課程, 學生到課的主要動機在於能以較高效益理解教科書內容, 但是針對主題已定但內容會隨學習成效而加以取捨的課程, 若學生的學習動機不夠強, 就會覺得無法掌握課程教學的主軸而失焦, 導致認為課程內容太過無聊或太過複雜而中途放棄, 造成學生不願意到課. 不知老師在教什麼? 老師的教學方式確實會影響學生的學習意願, 但是當學生從頭到尾都沒能到課的情形下, 還大聲疾呼說不知老師在教什麼? 就有些說不過去. 學這些東西沒有用 學生為何而讀, 為何而學, 為何而問? 老師如何弄懂學生處境 設法與學生共同學習 鼓勵自學、執行與想像 設法與表現好的學生一起協助跟不上進度的同學 https://www.ptt.cc/bbs/Gossiping/M.1392611157.A.D09.html https://kknews.cc/education/bxbg34n.html https://www.cheers.com.tw/blog/blogTopic.action?id=425&nid=5513 https://www.thenewslens.com/article/664 https://shinphotos.com/2014-03-08-297/ http://www.businessweekly.com.tw/article.aspx?id=1124&type=Blog 大學生應有的學習態度 面對全球協同的知識經濟環境, 身為一個大學生, 至少必須: 不要怕困難 (基本信念) – 因為幾乎處於網路時代的所有人, 在享受高度科技發展所帶來的便利性之後, 都必須隨時獨力或合力克服各種困難. 不要失去熱忱 (強化動力) – 許多人在生活周遭都會碰到非常多不盡如人意的各種挑戰, 持續保持個人與團隊的處事熱忱, 是堅持克服困難的必備動力. 不要以為不可能 (終究達陣) – 只要個人不斷提升待人處事能力, 持續接觸人文養分, 並且在團隊機制的架構下, 以轉知為智的精神來解決各式問題, 假以時日, 便可實現團隊理想, 化不可能為可能! 培養新世紀大學生的關鍵能力: http://www.tpea.org.tw/uploads/TPEA_2013112021132.pdf","tags":"Discussion","url":"./first-discussion-blog.html"},{"title":"其他","text":"不在設置, 模擬, 實作與論述類別的內容, 則放入雜項其他類別","tags":"Misc","url":"./first-misc-blog.html"},{"title":"實作","text":"紀錄與實作有關的內容, 實體製作 拍攝實際操作的照片與影片 將上課的實際情況反應出來 課該怎麼上: https://lectures.quantecon.org/ 互動討論程式: https://github.com/discourse/discourse Docker for Discourse: https://github.com/discourse/discourse_docker 安裝: https://blog.fntsr.tw/articles/2014/11/07/how-to-build-discourse-with-docker-1/ Discourse 中文: https://meta.discoursecn.org/ 網際程式框架: https://github.com/emberjs/ember.js","tags":"Realization","url":"./first-realization-blog.html"},{"title":"電腦模擬","text":"紀錄與電腦模擬相關內容與紀錄， 使用工具 Python3, RoboDK 電腦模擬 為什麼要模擬?假如要您負責送人登月, 不需模擬嗎? 幾天後就要接受面試, 需要先前排練嗎? 幾位好友要到墾丁旅遊, 需要事先安排好吃住與玩樂內容嗎?需要想想如何安排交通工具與路線嗎? PyQt5 pyqt5 程式 http://projects.skylogic.ca/blog/how-to-install-pyqt5-and-build-your-first-gui-in-python-3-4/ run.py, 自行編寫用從 core/main.py 中導入 MainWindow 類別建立案例後執行 if __name__ == \"__main__\": import sys from PyQt5.QtWidgets import QApplication from core.main import MainWindow app = QApplication(sys.argv) main = MainWindow() main.show() sys.exit(app.exec_()) core/main.py, 以 main.ui 滑鼠右鍵 generate Dialog Code 產生 # -*- coding: utf-8 -*- \"\"\" Module implementing MainWindow. \"\"\" from PyQt5.QtCore import pyqtSlot from PyQt5.QtWidgets import QMainWindow from PyQt5.QtCore import QLineF from PyQt5.QtWidgets import QFrame from PyQt5.QtWidgets import QGraphicsScene, QGraphicsView, QGraphicsEllipseItem from .Ui_main import Ui_MainWindow class MainWindow(QMainWindow, Ui_MainWindow): \"\"\" Class documentation goes here. \"\"\" def __init__(self, parent=None): \"\"\" Constructor @param parent reference to the parent widget @type QWidget \"\"\" super(MainWindow, self).__init__(parent) self.setupUi(self) @pyqtSlot() def on_actionAbout_triggered(self): \"\"\" Slot documentation goes here. \"\"\" # TODO: not implemented yet #raise NotImplementedError #建立景物 scene = QGraphicsScene(-200, -200, 400, 400) # Create Ellipse Item item = QGraphicsEllipseItem(-150, -100, 300, 300) # Add item scene.addItem(item) # 納入繪圖物件 scene.addText(\"終於可以!\") scene.addLine(QLineF(0, 0, 200, 200)) # set no frame to graphicsView self.graphicsView.setFrameShape(QFrame.NoFrame) # 在既有的 graphicsView 中設定景物 # graphicsView in a layout and set layout to the grid to fit the size of window self.graphicsView.setScene(scene) # 顯示 self.graphicsView.show() @pyqtSlot() def on_actionQuit_triggered(self): \"\"\" Slot documentation goes here. \"\"\" # TODO: not implemented yet #raise NotImplementedError self.close() core/Ui_main.py, 利用 main.ui 以 compile form 產生 # -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'Y:\\tmp\\pyqt5_vault\\ex3\\core\\main.ui' # # Created by: PyQt5 UI code generator 5.8.2 # # WARNING! All changes made in this file will be lost! from PyQt5 import QtCore, QtGui, QtWidgets class Ui_MainWindow(object): def setupUi(self, MainWindow): MainWindow.setObjectName(\"MainWindow\") MainWindow.resize(800, 600) self.centralWidget = QtWidgets.QWidget(MainWindow) self.centralWidget.setObjectName(\"centralWidget\") self.graphicsView = QtWidgets.QGraphicsView(self.centralWidget) self.graphicsView.setGeometry(QtCore.QRect(-15, -29, 871, 581)) self.graphicsView.setObjectName(\"graphicsView\") MainWindow.setCentralWidget(self.centralWidget) self.menuBar = QtWidgets.QMenuBar(MainWindow) self.menuBar.setGeometry(QtCore.QRect(0, 0, 800, 22)) self.menuBar.setObjectName(\"menuBar\") self.menuFile = QtWidgets.QMenu(self.menuBar) self.menuFile.setObjectName(\"menuFile\") MainWindow.setMenuBar(self.menuBar) self.actionAbout = QtWidgets.QAction(MainWindow) self.actionAbout.setObjectName(\"actionAbout\") self.actionQuit = QtWidgets.QAction(MainWindow) self.actionQuit.setObjectName(\"actionQuit\") self.menuFile.addAction(self.actionAbout) self.menuFile.addAction(self.actionQuit) self.menuBar.addAction(self.menuFile.menuAction()) self.retranslateUi(MainWindow) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): _translate = QtCore.QCoreApplication.translate MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\")) self.menuFile.setTitle(_translate(\"MainWindow\", \"File\")) self.actionAbout.setText(_translate(\"MainWindow\", \"About\")) self.actionQuit.setText(_translate(\"MainWindow\", \"Quit\")) if __name__ == \"__main__\": import sys app = QtWidgets.QApplication(sys.argv) MainWindow = QtWidgets.QMainWindow() ui = Ui_MainWindow() ui.setupUi(MainWindow) MainWindow.show() sys.exit(app.exec_()) main.ui MainWindow 0 0 800 600 MainWindow -15 -29 871 581 0 0 800 22 File About Quit Binary Genetic Algorithm #encoding=utf8 # genetic.py # import random import operator # for Intersect from math import * MAXIMIZE, MINIMIZE = 11, 22 class Individual: # 染色體先設為 None chromosome = None # 得分也先設為 None score = None # Here the size of var depends on var_number print # var 變數的元素個數取決於 var_number 的個數 (即變數個數) var = [] # 表示適應值變數個數有兩個 var_number = 2 #先將 var 數列中元素都設為 0 for i in range(var_number): var.append(0) # 等位基因表示各基因可選的內容, 這裡表示不是 0 就是 1 alleles = (0,1) # 2**10 = 32*32 = 1024, 表示若用十個 binary 位數來表示整數, 可以表示從 0 到 1023 的數值大小 # 若也用另外 十個 binary 位數來表示小數值, 則也是 0 到 1023 的數值表示能力, # 而再加一個表示正負的代表 binary 位數, 每一個變數需要 21 個 binary numbers # 以下為參數可負數時的編碼考量 #前10為小數,後10為整數,第21則為正負號 #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號. #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號 #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號 # -1023 ~ 1023 #length = 21*var_number,若接受負數參數,則必須同步修改 20->21 # 因為這裡只接受正的變數值, 所以每一個變數需要 20 個 binary 位數 length = 20*var_number seperator = '' optimization = MINIMIZE def __init__(self, chromosome=None): self.chromosome = chromosome or self._makechromosome() self.score = None # set during evaluation ''' bitwise operators (binary left shift): The left operands value is moved left by the number of bits specified by the right operand. x << y Returns x with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is the same as multiplying x by 2**y. ''' # 根據染色體各位元的值轉為 10 進位值 def _getvar(self, chromosome=None): # x 起始值設為 0 x = 0 for i in range(0, self.var_number): # 先根據前 20 個位元值, 透過 binary left shift 轉為 10 進位之後, 再轉為對應小數 for j in range(i*20, i*20+10): x += self.chromosome[j]<<(j-(i*20)) # 因為前 20 個 binary 數, 負責 10 進位數的小數點後 3 個位數, 只要轉為 10 進位值之後, 若大於 999, 則僅取 999, # 再除以 1000, 可以得到 .999 表示 .999 為最大的小數表示數, 不要因為大於 1000 後若除以 1000 將進位到整數, 會與整數有交互影響 if (x>999): x = 999 x /= 1000. # 整數部份 0 ~ 1023 的表示範圍則沒有問題, 利用 bitwise 轉換後, 直接取整數值 for j in range(i*20+10, i*20+20): x += self.chromosome[j]<<(j-(i*20+10)) self.var[i] = x return self.var ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings #for design variable -1023 ~1023 for i in range(self.var_number): x = 0 for j in range(i*21, i*21+10): x += self.chromosome[j]<<(j-(i*21)) if (x>999): x = 999 x /= 1000. for j in range(i*(21)+10, i*(21)+20): x += self.chromosome[j]<<(j-(i*21+10)) # 各變數範圍第 21 位數若為 1, 則表示該數為負數 if(self.chromosome[i*(21)+20] == 1): self.var[i] = -x else: self.var[i] = x # 讓 x 再設回原值 0 表示內定各變數為正數 x = 0 return self.var ''' # 建立染色體 def _makechromosome(self): \"makes a chromosome from randomly selected alleles.\" return [random.choice(self.alleles) for gene in range(self.length)] # 計算適應值 def evaluate(self, optimum=None): \"this method MUST be overridden to evaluate individual fitness score.\" pass # 交配方法 def crossover(self, other): \"override this method to use your preferred crossover method.\" return self._twopoint(other) # 突變方法 def mutate(self, gene): \"override this method to use your preferred mutation method.\" self._pick(gene) # sample mutation method def _pick(self, gene): \"chooses a random allele to replace this gene's allele.\" self.chromosome[gene] = random.choice(self.alleles) # sample crossover method def _twopoint(self, other): \"creates offspring via two-point crossover between mates.\" left, right = self._pickpivots() def mate(p0, p1): chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容 chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因 child = p0.__class__(chromosome) child._repair(p0, p1) return child return mate(self, other), mate(other, self) # some crossover helpers ... def _repair(self, parent1, parent2): \"override this method, if necessary, to fix duplicated genes.\" pass def _pickpivots(self): left = random.randrange(1, self.length-2) right = random.randrange(left, self.length-1) return left, right # # other methods # def __repr__(self): \"returns string representation of self\" ''' return '<%s chromosome=\"%s\" score=%s var=%s>' % \\ (self.__class__.__name__, self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome)) ''' return '<%s score=%s var=%s>' % \\ (self.__class__.__name__,self.score,self._getvar(self.chromosome)) # since the __cmp__ special function is gone use the __lt__ in stead # use the expression (a > b) - (a < b) as the equivalent for cmp(a, b) #def __cmp__(self, other): # these are for python 3 def __cmp__(self, other): if self.optimization == MINIMIZE: #return cmp(self.score, other.score) return (self.score > other.score) - (self.score < other.score) else: # MAXIMIZE #return cmp(other.score, self.score) return (other.score > self.score) - (other.score < self.score) def __lt__(self, other): return self.__cmp__(other) < 0 def __le__(self, other): return self.__cmp__(other) <= 0 def __gt__(self, other): return self.__cmp__(other) > 0 def __ge__(self, other): return self.__cmp__(other) >= 0 def copy(self): twin = self.__class__(self.chromosome[:]) twin.score = self.score return twin class Environment(object): x = [0] y = [0] def __init__(self, kind, population=None, size=100, maxgenerations=100, crossover_rate=0.90, mutation_rate=0.07, optimum=None): self.kind = kind self.size = size self.optimum = optimum self.population = population or self._makepopulation() for individual in self.population: individual.evaluate(self.optimum) self.crossover_rate = crossover_rate self.mutation_rate = mutation_rate self.maxgenerations = maxgenerations self.generation = 0 self.report() def _makepopulation(self): return [self.kind() for individual in range(self.size)] def run(self): while not self._goal(): self.step() def _goal(self): return self.generation > self.maxgenerations or \\ self.best.score == self.optimum def step(self): # this sort is not working with python 3.0, modification is needed self.population.sort() self._crossover() self.generation += 1 self.report() self.x.append(self.generation) # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值 if self.best.score <=5: self.y.append(self.best.score) else: self.y.append(5) def _crossover(self): next_population = [self.best.copy()] while len(next_population) < self.size: mate1 = self._select() if random.random() < self.crossover_rate: mate2 = self._select() offspring = mate1.crossover(mate2) else: offspring = [mate1.copy()] for individual in offspring: self._mutate(individual) individual.evaluate(self.optimum) next_population.append(individual) self.population = next_population[:self.size] def _select(self): \"override this to use your preferred selection method\" return self._tournament() def _mutate(self, individual): for gene in range(individual.length): if random.random() < self.mutation_rate: individual.mutate(gene) # # sample selection method # def _tournament(self, size=8, choosebest=0.90): competitors = [random.choice(self.population) for i in range(size)] competitors.sort() if random.random() < choosebest: return competitors[0] else: return random.choice(competitors[1:]) def best(): doc = \"individual with best fitness score in population.\" def fget(self): return self.population[0] return locals() best = property(**best()) def report(self): try: print (\"=\"*70) print (\"generation: \", self.generation) print (\"best: \", self.best) except: g.es (\"=\"*70) g.es (\"generation: \", self.generation) g.es (\"best: \", self.best) # 以上為 genetic.py 目前將兩者結合在一起 #encoding=utf8 # volume.py - useage example # # the fittest individual will have a chromosome consisting of 40 '1's # # #import genetic class Volume(Individual): optimization = MAXIMIZE def evaluate(self, optimum=None): SURFACE = 80 # self.score is the fitness value self._getvar(self.chromosome) x = self.var[0] y = self.var[1] z=(SURFACE - x*y)/(2.*(x+y)) fitness_value = x*y*z self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip class Intersect(Individual): optimization = MINIMIZE def evaluate(self, optimum=None): # self.score is the fitness value self._getvar(self.chromosome) t = self.var[0] deg = pi/180 theta = self.var[1]*deg xtarget = 0.75/2 ytarget = 0.5 x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2 y = (-3*t/2 + 123/92)*sin(theta) # 適應值 fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8) # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰 if t > 1: fitness_value += 1000 if t < 0: fitness_value += 1000 # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰 if theta > 2*pi: fitness_value += 1000 if theta < 0: fitness_value += 1000 self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip if __name__ == \"__main__\": env = Environment(Volume, size=500, maxgenerations=100) #env = Environment(Intersect, size=500, maxgenerations=100) env.run() Deap 與 Scoop Deap: https://github.com/DEAP/deap Scoop: https://en.wikipedia.org/wiki/Python_SCOOP_(software) https://groups.google.com/forum/#!topic/deap-users/v3wbky0EUf0 https://groups.google.com/forum/m/#!msg/deap-users/P4IkiE-Bvbg/xSoMDphbMR4J 平行運算 http://research.cs.wisc.edu/htcondor/ https://github.com/J-Robinson/GridGA","tags":"Simulation","url":"./first-simulation-blog.html"},{"title":"軟硬體設置","text":"紀錄電腦與網路的軟硬體相關設置 Github, Bitbucket 與 Fossil SCM Github 目前提供免費無太多限制的多人協同開放倉儲使用, 唯一的限制就是單一檔案建議不能大於 50 MB, 但是若不公開倉儲就必須付費. Bitbucket 則允許免費使用非公開的倉儲, 但是至多只允許五個帳號協同. Fossil SCM 則適合在近端或區域網路中使用, 目前 KMOLab 希望在區網中導入作為與 Github Pages 配合的工具, 使用者可以將 Fossil SCM 的 working directory 限縮在 Github 近端倉儲的特定目錄下, 且在 .gitignore 中排除 FOSSIL (under Windows) 的版次管理, 但是相關的 fossil update 與 fossil server 功能仍然必須依照特定的流程進行操作, 以避免兩套版次管理系統內容的不同步導致資料覆蓋流失. github 倉儲與 bitbucket 倉儲利用 git remote add 同步 近端則利用 Fossil SCM 進行備份 給一台電腦, 設置到能夠提供特定的機械設計服務 主題式教學的反思 數學與軟硬體設置有關嗎? 英文與軟硬體設置有關嗎? Leo Editor, Pelican 與 Reveal.js Leo Editor 是一套能夠以程式方法有效管理多元資料的文字資料編輯器, 以下就是用來管理 KMOLab Pelican 靜態網誌有關內容的畫面, 其中的 @button local-blog 是用來產生靜態網誌的指令按鈕, @button github-blog 則是用來產生嵌入 Disqus 留言系統的 Github Pages 網誌對應指令, 兩個指令的差別在於使用不同的設定檔案, 使用者可以先利用近端的按鈕, 建立網誌後在近端以另一個 https-server 按鈕建立 https 伺服, 用瀏覽器檢查所產生的網誌內容, 一旦要送到 Github 倉儲, 必須再利用遠端按鈕產生另外一組網誌與搜尋用 .json 檔案後, 再提交推送到倉儲. 在這個過程中, 使用者依照 Pelican 的特定 Markdown 檔案編寫網誌內容外, Leo Editor 專案檔中也可以放入其他有關的註記與設定檔案編輯用的節點. 若需要在 Pelican 的環境中修改設定, 都可以全部在一個 Leo Editor 專案檔中完成. Leo Editor 另外一項有用的特定就是能夠利用從屬節點關係與內文指令來表示複雜的 html 檔案, 如下圖所示, 各段落的超文件標註可以利用節點加以切割, 使用者在編寫 reveal.js 投影片時, 可以只集中在特定簡報內容的編寫, 並且透過節點的複製與搬移, 甚至使用 Leo Editor 的節點 clone 功能, 同步相同內容但是同時出現在不同位置的節點. Pelican Blog 共用設定檔案: pelicanconf.py #!/usr/bin/env python # -*- coding: utf-8 -*- # from __future__ import unicode_literals AUTHOR = 'KMOL' SITENAME = 'KMOLab 機械設計工程' # 不要用文章所在目錄作為類別 USE_FOLDER_AS_CATEGORY = False #PATH = 'content' #OUTPUT_PATH = 'output' TIMEZONE = 'Asia/Taipei' DEFAULT_LANG = 'en' # Feed generation is usually not desired when developing FEED_ALL_ATOM = None CATEGORY_FEED_ATOM = None TRANSLATION_FEED_ATOM = None AUTHOR_FEED_ATOM = None AUTHOR_FEED_RSS = None # Blogroll LINKS = (('Pelican', 'http://getpelican.com/'), ('pelican-bootstrap3', 'https://github.com/DandyDev/pelican-bootstrap3/'), ('pelican-plugins', 'https://github.com/getpelican/pelican-plugins'), ('Tipue search', 'https://github.com/Tipue/Tipue-Search'),) # Social widget #SOCIAL = (('You can add links in your config file', '#'),('Another social link', '#'),) DEFAULT_PAGINATION = 10 # Uncomment following line if you want document-relative URLs when developing #RELATIVE_URLS = True # 必須絕對目錄或相對於設定檔案所在目錄 PLUGIN_PATHS = ['plugin'] PLUGINS = ['summary', 'tipue_search', 'sitemap'] # for sitemap plugin SITEMAP = { 'format': 'xml', 'priorities': { 'articles': 0.5, 'indexes': 0.5, 'pages': 0.5 }, 'changefreqs': { 'articles': 'monthly', 'indexes': 'daily', 'pages': 'monthly' } } # search is for Tipue search DIRECT_TEMPLATES = (('index', 'tags', 'categories', 'authors', 'archives', 'search')) # for pelican-bootstrap3 theme settings #TAG_CLOUD_MAX_ITEMS = 50 DISPLAY_CATEGORIES_ON_SIDEBAR = True DISPLAY_RECENT_POSTS_ON_SIDEBAR = True DISPLAY_TAGS_ON_SIDEBAR = True DISPLAY_TAGS_INLINE = True TAGS_URL = \"tags.html\" CATEGORIES_URL = \"categories.html\" MENUITEMS = [('About', '/blog/pages/about/')] #SHOW_ARTICLE_AUTHOR = True #MENUITEMS = [('Home', '/'), ('Archives', '/archives.html'), ('Search', '/search.html')] 遠端 publishconf.py #!/usr/bin/env python # -*- coding: utf-8 -*- # from __future__ import unicode_literals # This file is only used if you use `make publish` or # explicitly specify it as your config file. import os import sys sys.path.append(os.curdir) from pelicanconf import * # 因為 publishconf.py 在 pelicanconf.py 之後, 因此若兩處有相同變數的設定, 將以較後讀入的 publishconf.py 中的設定為主. # 將所有靜態 html 檔案移到 blog 子目錄 SITEURL = 'https://kmolab.github.io/blog' # 此設定用於將資料送到 gh-pages, 因此使用絕對 URL 設定 RELATIVE_URLS = False # 為了要讓 local 與 gh-pages 上都能夠使用 Tipue search, 可能要採用不同的 theme THEME = 'theme/pelican-bootstrap3' #BOOTSTRAP_THEME = 'readable' #BOOTSTRAP_THEME = 'readable-old' BOOTSTRAP_THEME = 'united' #PYGMENTS_STYLE = 'paraiso-drak' #PYGMENTS_STYLE = 'fruity' # 為了同時兼容 render_math, 必須放棄 fruity PYGMENTS_STYLE = 'monokai' FEED_ALL_ATOM = 'feeds/all.atom.xml' CATEGORY_FEED_ATOM = 'feeds/%s.atom.xml' DELETE_OUTPUT_DIRECTORY = True # Following items are often useful when publishing DISQUS_SITENAME = \"kmolabmde\" #GOOGLE_ANALYTICS = \"\" # 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定 DEFAULT_DATE = 'fs' # 遠端的 code hightlight #MD_EXTENSIONS = ['fenced_code', 'extra', 'codehilite(linenums=True)'] MARKDOWN = { 'extension_configs': { 'markdown.extensions.codehilite': {'css_class': 'highlight'}, 'markdown.extensions.extra': {}, 'markdown.extensions.meta': {}, }, 'output_format': 'html5', } # 若要依照日期存檔呼叫 #ARTICLE_URL = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/' #ARTICLE_SAVE_AS = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' PAGE_URL = 'pages/{slug}/' PAGE_SAVE_AS = 'pages/{slug}/index.html' SHOW_ARTICLE_AUTHOR = True local_publishconf.py #!/usr/bin/env python # -*- coding: utf-8 -*- # from __future__ import unicode_literals # This file is only used if you use `make publish` or # explicitly specify it as your config file. import os import sys sys.path.append(os.curdir) from pelicanconf import * # 因為 publishconf.py 在 pelicanconf.py 之後, 因此若兩處有相同變數的設定, 將以較後讀入的 publishconf.py 中的設定為主. # 請注意, 為了在近端讓 Tipue search 傳回的搜尋結果連結正確, 必須使用 ./ SITEURL = './' # 此設定用於近端靜態網頁查驗, 因此使用相對 URL RELATIVE_URLS = True # 為了要讓 local 與 gh-pages 上都能夠使用 Tipue search, 可能要採用不同的 theme THEME = 'theme/pelican-bootstrap3_local' #BOOTSTRAP_THEME = 'readable' #BOOTSTRAP_THEME = 'readable-old' BOOTSTRAP_THEME = 'united' #PYGMENTS_STYLE = 'paraiso-drak' #PYGMENTS_STYLE = 'fruity' # 為了同時兼容 render_math, 必須放棄 fruity PYGMENTS_STYLE = 'monokai' FEED_ALL_ATOM = 'feeds/all.atom.xml' CATEGORY_FEED_ATOM = 'feeds/%s.atom.xml' DELETE_OUTPUT_DIRECTORY = True # Following items are often useful when publishing #DISQUS_SITENAME = \"kmolabmde\" #GOOGLE_ANALYTICS = \"\" # 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定 DEFAULT_DATE = 'fs' # 近端的 code hightlight #MD_EXTENSIONS = ['fenced_code', 'extra', 'codehilite(linenums=True)'] MARKDOWN = { 'extension_configs': { 'markdown.extensions.codehilite': {'css_class': 'highlight'}, 'markdown.extensions.extra': {}, 'markdown.extensions.meta': {}, }, 'output_format': 'html5', } # 若要依照日期存檔呼叫 #ARTICLE_URL = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' #ARTICLE_SAVE_AS = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' PAGE_URL = 'pages/{slug}/' PAGE_SAVE_AS = 'pages/{slug}/index.html' SHOW_ARTICLE_AUTHOR = True 區網中的 IPv4 與 IPv6 WWW Server Pelican 在近端產生 weblog 後, 若要在近端以 https 檢視結果, 就必須同時建立 https Server.","tags":"Setup","url":"./first-setup-blog.html"}]}