var tipuesearch = {"pages":[{"title":"About","text":"機械設計工程系 KMOLab 倉儲 KMOLab 倉儲: https://github.com/kmolab/kmolab.github.io KMOLab 投影片: https://kmolab.github.io KMOLab 網誌: https://kmolab.github.io/blog Contact: kmolab At mde dot tw KMOLab 信念 二十一世紀的科技大學, 在培育具世界觀與在地文化素養, 能適應環境並成功面對挑戰之專業人才. 所謂專業, 即具有專長, 能夠就業之謂. 所謂文化者, 因思考及概念而有之教化. 所謂素養, 即平日的涵養. Excellence is an art won by training and habituation. We do not act rightly because we have virtue or excellence, but we rather have those because we have acted rightly. We are what we repeatedly do. Excellence, then, is not an act but a habit. — Aristotle (384 BC – March 7, 322 BC) 卓越須經由訓練與習慣養成才能獲得。並非具備品德或卓越能讓人舉止得宜，反而是舉止得宜能讓人卓越。經過切身重複實作，才可體會，卓越並非一種作為，而是習慣。 — 亞理士多德 (西元前 384 年 – 西元前 322 年 3 月 7 日) 體魄康強, 精神活潑, 舉止端莊, 人格健全, 便是大學生的風度. 不倦的追求真理, 熱烈的愛護國家, 積極的造福人類, 才是大學生的職志. — 羅家倫 (1928) KMOLab 標誌","tags":"misc","url":"https://kmolab.github.io/blog/pages/about/"},{"title":"本站網址改為 lab.kmol.info","text":"目前的網址為 kmolab.github.io, 從今起希望改為 lab.kmol.info DNS 設定 首先必須先在 DNS 伺服器中, 新增 CNAME 類型, 主機選擇 lab, 指向則設為 kmolab.github.io 修改 publishconf.py 接下來必須修改 publishconf.py, 將 SITEURL 設為 'https://kmolab.github.io/blog' Github 倉儲設定 倉儲中新增一個 CNAME 檔案, 內容為 lab.kmol.info, 且進入倉儲 settings 查驗是否 Custom domain 也是設為 lab.kmol.info, 透過以上設定就可以將 http://kmolab.github.io 轉為 http://lab.kmol.info","tags":"Misc","url":"https://kmolab.github.io/blog/use-blog-kmol-info-as-domain-name.html"},{"title":"2017 KMOLab 總結","text":"2017 年在兩個禮拜前結束, KMOLab 也在秋季學期完成了計算機程式與電腦輔助設計實習的課程. 從 PyQt5 事件導向教起 原本只教導基本 Python3 語法的計算機程式課程, 首度以 PyQt5 的物件導向與事件導向為課程主體, 然後讓學員從中了解各種語法的使用時機. 儘管相較於一般工學院科系的計算機程式課程, 從 C++ 或 C 的內容學起, 有很大的差異, 但是出發點在於: 要讓大一的機械設計工程系學生儘快了解, 電腦程式語言該如何應用, 就必須把握機會, 在學生迷失於各種程式語法之前, 設法讓各學員提起更大的學習動機. 這著險棋因為有 Eric6 與 Qt Designer 的協助, 才值得一試, 從基本視窗按鈕元件與 lineEdit 元件的置入, 到對話框布局的配置, 因為都採用 Qt Designer 的滑鼠互動操作, 相信沒有太大的難度, 但是當 .ui XML 檔案轉為 Python3 原始碼之後, 到配合對話框建立與視窗元件互動的程式邏輯編寫, 就在在考驗著每一位程式初學者的耐性與學習動機. 過程中, 利用 PyQt5 建立了一個簡單的電腦輔助設計實習相關的機電系統控制介面程式, 用來控制 V-rep 鋼珠軌道運動模擬系統的視窗程式, 如下列影片所示, 希望以此為例說明在隨後的課程中, 如何使用 PyQt5 程式, 協助完成構想中的機電資產品設計: 上述這個簡單的視窗程式, 與計算機程式中所建立的簡易計算機程式, 非常類似, 僅使用了按鈕與 lineEdit 元件, 且利用 V-rep 的 Python remote API 模式編寫, 最大的教學目標是希望大一計算機程式課程學生, 到了大二上電腦輔助設計實習課程時, 能夠運用 PyQt5 建立監控用的視窗程式, 實際用來控制虛擬的 V-rep 機電系統, 或者是控制根據模擬設計過程所完成的實體系統. 全面採用 Fossil SCM 2017 Fall KMOLab 課程的另外一個特點是, 在兩門課程初期, 利用下列 Python 程式, 為每一位學員建立區域網路 Fossil SCM 主機上的倉儲帳號: import os import string import random # 使用 Gmail 寄信必須導入下列模組 import smtplib import re from email.mime.text import MIMEText from email.header import Header # 用來以亂數建立密碼的函式 def id_generator(size=6, chars=string.ascii_uppercase + string.digits): ''' source: https://stackoverflow.com/questions/2257441/random-string-generation-with-upper-case-letters-and-digits-in-python ''' return ''.join(random.choice(chars) for _ in range(size)) # 讀取學員名單, 逐一取得學員學號, 學員名單, 檢查點 1/7 student_data = open(\"2017fall_list/1b.txt\").read() student_list = student_data.splitlines() # 利用 gmail smtp 功能寄信 server = smtplib.SMTP('smtp.gmail.com:587') server.ehlo() server.starttls() # 以下必須準備好對應郵件帳號與密碼的外部檔案, 所提供的寄信帳號, 是否可以寄信, 檢查點 2/7 ''' 寄信之前必須到 https://www.google.com/settings/security/lesssecureapps 修改權限, 改為較低安全權限 否則無法使用程式寄信! ''' # 從外部檔案讀取要用來寄信的 gmail 帳號與密碼 # mail.txt 格式為: 電子郵箱,對應密碼, 以逗點隔開, 檢查點 3/7 email_data = open(\"z:/2017fall/mail.txt\").read() email, email_password= email_data.split(\",\") print(email, email_password) # 是否登入所提供寄信的電子郵箱, 4/7 server.login(email, email_password) # 不同課程名稱, 與對應主機名稱, 必須配合修改 5/7 course_title = \"計算機程式\" fossil_server = \"cpb.kmol.info\" for student_num in student_list: username = student_num repository = username + '.fossil' # 利用所提供的字串, 以亂數組成六個字元的密碼 password = id_generator(6, \"23456789abcdef\") print(student_num, \", \" , password) # 執行 dos command 指令, 建立倉儲 os.system(\"fossil init -A \" +username + \" \" + repository) print(\"已經建立倉儲 \" + repository) # 執行 dos command 指令, 修改使用者密碼 os.system(\"fossil user password \" + username + \" \" + password + \" -R \" + repository) print(\"已經修改密碼\") # 利用 Gmail 寄信, 告知各學員倉儲連結與帳號密碼 # 每一位學員收到的 output 都從這裡 reset output = \"\" # 若學號欄為空, 則不寄信 if student_num != \"\": # output 為寄給每一位學員的資料表格 mail_content = student_num+' 您好: 您在 '+course_title+' 課程中的區域網路倉儲: https://'+fossil_server+'/'+student_num+' ' mail_content += '管理帳號為:'+ student_num + ' 管理密碼為: '+ password+' ' print(student_num) print(mail_content) # 至此 mail_content 已經確定 # 在測試與實際寄送資料, 也必須配合修改, 檢查點 6/7 receiver_email = student_num + \"@gm.nfu.edu.tw\" # 測試用 #receiver_email = student_num+\"@mde.tw\" # 列出收信人 email 位址 #print(receiver_email) #message= MIMEText(mail_content,'plain','UTF-8') # 以 html 格式寄信 message= MIMEText(mail_content,'html','UTF-8') message['Subject'] = Header(course_title+\" Fossil SCM 帳號通知\", 'UTF-8') # 可以先不寄信, 確定格式正確後再開啟, 是否實際寄出信件, 檢查點 7/7 server.sendmail(\"gmail_address\", receiver_email, message.as_string()) server.quit() 由於先前的 KMOLab 課程, 都是在第一時間就導入 Github 帳號與用法教學, 好處是無需自行維護實體伺服器, 但是缺點則是 Git 的 Windows client 指令依賴一個大約 200 MB 目錄中的許多套件工具, 與初學者的距離較遠, 而 Fossil SCM 的 client 程式只有一個 6MB 的 fossil.exe 檔案, 且若在進階的計算機程式課程中可以直接利用可攜的 MSYS2 視窗環境自行從 Fossil SCM 網站中下載原始碼, 然後自行編譯出內含 https 協定連線的 fossil.exe, 這可以是一位大一機械設計工程系學生自行利用一個 32 GB USB 3.0 隨身碟, 自行打造 Windows 視窗環境下工具的第一步, 因此才從 2017 Fall 開始決定全面導入 Fossil SCM . 另外一個導入 Fossil SCM 的好處是, 其中大量使用 SQLite 的 SQL 語法存取資料 (因為都是由 D. Richard Hipp 建立), 因此也讓學生有機會及早一窺 SQL 語言的用法. 機電資導向的電腦輔助設計實習 過去的電腦輔助設計實習課程, 頂多只是利用機械類電腦輔助設計套件 (例如: PTC Creo, Solidworks, Autodesk Inventor, Siemens NX 或 Simens Solid Edge 等) 建立相關零組件, 或者利用 PTC Creo 應用程式延伸介面中的 Pro/Web.Link 程式架構, 直接在嵌入的 Internet Explorer 瀏覽器中, 進行 Javascript 的程式化參數零組件應用, 雖然可以利用瀏覽器中的 html 表單, 達到設計流程中的網際客製化, 但是隨著 Onshape 在 2015 年起提供教育界免費使用後, 連可以簡單放入隨身碟, 以網路取得認證的 PTC Creo 容量都超過 5GB 來看, 都嫌笨重, 更不用提其他無法輕易放入隨身碟中的固定式機械類電腦輔助設計套件, 在輕薄短小, 敏捷協同過程中所帶來的不便. 因為在一般的機械概念設計初期, 通常需要進行機構的結構設計, 而這些套件卻無法簡易讓初級使用者快速驗證目標機構的可行性, 因此在 2013 年 Solvespace 開源之後, KMOLab 就開始在課程中導入, 動機與採用 Fossil SCM 相同, 使用者可以利用 MSYS2 可攜套件, 在 Windows 10 64 位元環境中, 自行從 C++11 的原始碼編譯出所需的 3.0 版 solvespace.exe, 含執行時所需的 libwinpthread-1.dll 與 d3dcompiler_43.dll, 總容量大約只有 20 MB, 若採用官方以 Visual Studio 編譯的 2.0 版 solvespace.exe, 更只需要約 7 MB, 直接放在隨身碟中, 使用非常方便. 電腦輔助設計實習課程中結合 Solvespace 與 V-rep 的過程可以參考下列影片: 至於結合 Solvespace , Onshape 與 V-rep 的教學影片範例如下: 而實際從設計, 模擬到實體機電系統測試的範例可參考: 從概念轉為知識, 用知識解題 最後, 在 2017 Fall 教學的最後階段, KMOLab 還導入了一項源自法國的 C-K 設計理論 , C 代表 Concept 指設計過程中的許多概念, 而 K 則是 Knowledge, 也就是設計者已經掌握, 可以用來解決問題的知識, 這個設計理論中最重要的概念是, 沒有所謂愚笨或可笑的設計概念, 而應當視為閱聽者在面對這些概念時, 還不具備實現這些概念所需的知識. 簡言之, C-K 設計理論 闡述設計是可以被教導的, 而且可以引用數學原理, 從概念中衍生出更多概念, 將概念轉化為知識, 利用知識推演出更多知識, 同時, 許多知識隨著時空環境的變化, 也可能會轉為概念, 因為已經無法解決當時所面臨的實際問題. 在 C-K 設計理論 的引領下, 任何一個從事機械設計流程的成員, 都不再會因為掌握一些片段知識而自滿, 因為若這些知識沒有持續改進, 未來將無法用來解題, 同時, 初學者也不會因為在協同設計過程中, 擔心提出所謂離譜可笑的概念, 因為理論上所有的概念都可能被實現, 就好像對於一個在數學理論上擁有無限大知識的成員, 就學理上, 根本沒有解決不了的問題, 呵呵, 這確實有些抽象. 歡迎各位來到 2018 年, 一個深度學習與智慧口號滿天的歷史元年, 我們有整整一年的時間來探討, 大家所擁有的所謂深度學習與智慧機械, 到底是概念還是真能用來解決問題的知識.","tags":"Course","url":"https://kmolab.github.io/blog/Year-2017-Conclusion.html"},{"title":"網頁上的數學方程式","text":"利用 Mathjax 可以利用 LaTeX 語法，在網頁上編寫數學方程式. 數學方程式 當 $a \\ne 0$, 一元二次方程式 (ax&#94;2 + bx + c = 0) 有兩組解, 可以寫成: $$x = {-b \\pm \\sqrt{b&#94;2-4ac} \\over 2a}.$$ 以上的原始 Markdown 檔案為: 當 $a \\ne 0$, 一元二次方程式 \\(ax&#94;2 + bx + c = 0\\) 有兩組解, 可以寫成: $$x = {-b \\pm \\sqrt{b&#94;2-4ac} \\over 2a}.$$ [Mathjax]:https://www.mathjax.org 機械設計方法與表達 假如您真正將在機械設計工程系所學, 用在解決實務問題, 就會發現整個過程都在與概念及知識混戰, 而概念與知識的交互作用, 正是所謂知識經濟的重要特徵, 概念可以通過驗證而成為知識, 用來解決問題, 而概念可能衍生出更多概念, 當知識在實務執行過程中, 因為各種原因而無法用來解決問題時, 就會轉化成為團隊間的概念, 而特定知識的運用與推演, 更會產生更多有用的知識. 上面與概念及知識相關的說明, 就是來自 C-K 設計理論 . 以上述利用 LaTeX 語法, 在網頁中產生數學方程式的概念, 來自於工程師設計表達過程中的需求, 而這些需求最早的\"知識\", 是將方程式事先做成圖形檔案, 然後再以 img 標註引入網頁, 但是這樣的知識很快受到挑戰, 因為整體流程非常沒有彈性, 並非直接從網頁中的文字\"自動\"轉為可視的數學公式, 因此早先的知識在 Javascript 的置入後, 由使用者編寫 LaTeX 語法, 然後再由程式方法在網頁中即時訂製出所要的數學方程式. 與數學方程式在網頁中的表達需求相同的, 是在網頁中正確引用各種程式碼, 在此我們採用的是舊版的 Syntaxhighlighter , 也是透過 Javascript 解讀所要引用的程式語法, 然後再利用設定顯示出對應的行號. 上述用來顯示四行 LaTeX 方程式與 Markdown 引用網址的原始內容, 就是應用之一. 組成內容與狀態的版次決定一切 當上述引用 Syntaxhighlighter 與 Mathjax 的過程中, 非常重要的一點就是這兩套 Javascript 程式碼, 在不斷更新的情況下, 不同版次的組成內容各不相同, 使用的方法也不一樣, 因此我們說事物組成內容與狀態的版次決定一切, 當許多問題的解決與討論, 在各自不知彼此立足點的組成內容與狀態版次的情況下, 許多無謂紛爭就會發生, 解決方法也比相對難以找到. 以我們目前在使用的 Leo Editor 來說, 可以在 Python2 或 Python3 的環境中使用, 並且需要安裝 PyQt 第四版或第五版模組才能啟動. 但是隨著 Python2 的生命週期即將抵達終點, 而且 Leo Editor 及 PyQt 幾乎隨時都在更動改版中, 因此假如使用者的操作系統、 Leo Editor 、 PyQt 與其他使用者用來建置網頁或程式的所有套件都能\"自動\"感知組成內容, 自動調適狀態, 自動搭配改版, 使用者就能高枕無憂, 永續使用這一系列工具, 問題是整個過程中牽涉到如何收費, 這些工具套件如何正確判斷使用者的需求, 倘若因此造成損失, 該由誰負責\"賠償\"或者恢復原狀, 重點在於哪一個才是原狀? 以過去三十幾年的電腦與網路使用歷程來看, 第一階段的電腦輔助, 從旁協助的角色, 早已提升到自動附加的半自主角色, 例如: Windows 10 的自主更新, 已經無需使用者同意, 眼前能夠想像的是在十年內, 電腦與網路全面自主為人類創造價值的世代, 希望屆時使用者不僅只是整體社會運作的組成元件 , 更是主導運作狀態的發號者.","tags":"Course","url":"https://kmolab.github.io/blog/Math-Equation-On-Web-Page.html"},{"title":"Cango Javascript 程式庫繪圖","text":"利用 Cango 與 Brython 進行網際繪圖 window.onload=function(){ brython({debug:1, pythonpath:['./../data/py']}); } function doSave(storage_id, filename){ var blob = new Blob([localStorage[storage_id]], {type: \"text/plain;charset=utf-8\"}); filename = document.getElementById(filename).value saveAs(blob, filename+\".py\"); } from browser import alert from browser import window import math # Javascript 物件 cango = window.Cango.new path = window.Path.new shape = window.Shape.new # Javascript 變數 shapedefs = window.shapeDefs cgo = cango(\"plotarea\") cgo.gridboxPadding(10, 10, 5, 7) # 設定座標系統 # cgo.setWorldCoordsRHC(xmin, ymin, xmax-xmin); cgo.setWorldCoordsRHC(-40, -50, 800, 300) # 畫軸線 cgo.drawAxes(-40, 750, -80, 710, { 'xOrigin':0, 'yOrigin':0, \"strokeColor\":\"#aaaaaa\", \"fillColor\": \"#aaaaaa\", \"xTickInterval\": 40, \"xLabelInterval\": 40, \"yTickInterval\": 40, \"yLabelInterval\": 40}) deg = math.pi/180 # 將繪製鏈條輪廓的內容寫成 class 物件 class chain(): # 輪廓的外型設為成員變數 chamber = \"M -6.8397, -1.4894 \\ A 7, 7, 0, 1, 0, 6.8397, -1.4894 \\ A 40, 40, 0, 0, 1, 6.8397, -18.511 \\ A 7, 7, 0, 1, 0, -6.8397, -18.511 \\ A 40, 40, 0, 0, 1, -6.8397, -1.4894 z\" cgoChamber = window.svgToCgo2D(chamber) # 利用鏈條起點與終點定義繪圖, 使用內定的 color, border 與 linewidth 變數 def basic(self, x1, y1, x2, y2, color=\"green\", border=True, linewidth=4, scale=3): self.x1 = x1 self.y1 = y1 self.x2 = x2 self.y2 = y2 self.color = color self.border = border self.linewidth = linewidth self.scale = scale # 注意, cgoChamber 為成員變數 # 新的 shape 物件函式 cmbr = shape(self.cgoChamber, { \"fillColor\": self.color, \"border\": self.border, \"strokeColor\": \"tan\", \"lineWidth\": self.linewidth }) # hole 為原點位置 # 新的 path 函式 hole = path(shapedefs.circle(4)) cmbr.appendPath(hole) # 複製 cmbr, 然後命名為 basic1 basic1 = cmbr.dup() # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角 basic1.rotate(math.atan2(self.y2-self.y1, self.x2-self.x1)/deg-90) # 放大 scale 倍 basic1.translate(self.x1, self.y1) basic1.scale(self.scale) cgo.render(basic1,False) # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數 def basic_rot(self, x1, y1, rot, color=\"green\", border=True, linewidth=4, scale=3): self.x1 = x1 self.y1 = y1 self.rot = rot self.color = color self.border = border self.linewidth = linewidth self.scale = scale # 注意, cgoChamber 為成員變數 cmbr = shape(self.cgoChamber, { \"fillColor\": self.color, \"border\": self.border, \"strokeColor\": \"tan\", \"lineWidth\": self.linewidth }) # hole 為原點位置 hole = path(shapedefs.circle(4)) cmbr.appendPath(hole) # 根據旋轉角度, 計算 x2 與 y2 x2 = self.x1 + 20*math.cos(self.rot*deg) y2 = self.y1 + 20*math.sin(self.rot*deg) # 複製 cmbr, 然後命名為 basic1 basic1 = cmbr.dup() # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量轉角 basic1.rotate(self.rot-90) # 放大 scale 倍 basic1.translate(self.x1, self.y1) basic1.scale(self.scale) cgo.render(basic1, False) return x2, y2 # 利用 chain class 建立案例, 對應到 mychain 變數 mychain = chain() # 畫 A # 左邊兩個垂直單元 x1, y1 = mychain.basic_rot(0, 0, 90) x2, y2 = mychain.basic_rot(x1, y1, 90) # 左斜邊兩個單元 x3, y3 = mychain.basic_rot(x2, y2, 80) x4, y4 = mychain.basic_rot(x3, y3, 71) # 最上方水平單元 x5, y5 = mychain.basic_rot(x4, y4, 0) # 右斜邊兩個單元 x6, y6 = mychain.basic_rot(x5, y5, -71) x7, y7 = mychain.basic_rot(x6, y6, -80) # 右邊兩個垂直單元 x8, y8 = mychain.basic_rot(x7, y7, -90) x9, y9 = mychain.basic_rot(x8, y8, -90) # 中間兩個水平單元 x10, y10 = mychain.basic_rot(x8, y8, -180) mychain.basic(x10, y10, x1, y1, color=\"red\") # 畫 B # 左邊四個垂直單元 x1, y1 = mychain.basic_rot(0+ 65, 0, 90) x2, y2 = mychain.basic_rot(x1, y1, 90) x3, y3 = mychain.basic_rot(x2, y2, 90) x4, y4 = mychain.basic_rot(x3, y3, 90) # 上方一個水平單元 x5, y5 = mychain.basic_rot(x4, y4, 0) # 右斜 -30 度 x6, y6 = mychain.basic_rot(x5, y5, -30) # 右上垂直向下單元 x7, y7 = mychain.basic_rot(x6, y6, -90) # 右斜 240 度 x8, y8 = mychain.basic_rot(x7, y7, 210) # 中間水平 mychain.basic(x8, y8, x2, y2) # 右下斜 -30 度 x10, y10 = mychain.basic_rot(x8, y8, -30) # 右下垂直向下單元 x11, y11 = mychain.basic_rot(x10, y10, -90) # 右下斜 240 度 x12, y12 = mychain.basic_rot(x11, y11, 210) # 水平接回起點 mychain.basic(x12,y12, 0, 0, color=\"red\") # 畫 C # 上半部 # 左邊中間垂直起點, 圓心位於線段中央, y 方向再向上平移兩個鏈條圓心距單位 x1, y1 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), 90) # 上方轉 80 度 x2, y2 = mychain.basic_rot(x1, y1, 80) # 上方轉 30 度 x3, y3 = mychain.basic_rot(x2, y2, 30) # 上方水平 x4, y4 = mychain.basic_rot(x3, y3, 0) # 下半部, 從起點開始 -80 度 x5, y5 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), -80) # 下斜 -30 度 x6, y6 = mychain.basic_rot(x5, y5, -30) # 下方水平單元 x7, y7 = mychain.basic_rot(x6, y6, -0, color=\"red\") # 畫 D # 左邊四個垂直單元 x1, y1 = mychain.basic_rot(0+65*3, 0, 90) x2, y2 = mychain.basic_rot(x1, y1, 90) x3, y3 = mychain.basic_rot(x2, y2, 90) x4, y4 = mychain.basic_rot(x3, y3, 90) # 上方一個水平單元 x5, y5 = mychain.basic_rot(x4, y4, 0) # 右斜 -40 度 x6, y6 = mychain.basic_rot(x5, y5, -40) x7, y7 = mychain.basic_rot(x6, y6, -70) # 右中垂直向下單元 x8, y8 = mychain.basic_rot(x7, y7, -90) # -110 度 x9, y9 = mychain.basic_rot(x8, y8, -100) # -150 x10, y10 = mychain.basic_rot(x9, y9, -150) # 水平接回原點 mychain.basic(x10, y10, 0+65*3, 0, color=\"red\") from browser import document as doc import ace # Brython 3.3.4 內建的 container 名稱為 'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id Ace = ace.Editor(editor_id=\"can1_editor\", console_id=\"can1_console\", container_id=\"can1_container\", storage_id=\"can1_py_src\" ) Ace.editor.setValue('''#Cango 繪圖 from browser import window import math cos30 = math.cos(30*math.pi/180) sin30 = math.sin(30*math.pi/180) # Javascript 物件 cango = window.Cango.new path = window.Path.new shape = window.Shape.new # Javascript 變數 shapedefs = window.shapeDefs g1 = cango(\"can1_container\") g1.clearCanvas() g1.gridboxPadding(10, 10, 5, 7) g1.fillGridbox(\"lightgreen\") g1.setWorldCoordsRHC(0, 0, 80) g1.drawText(\"gc.setWorldCoordsRHC() 設為 Y 向上為正\", {'x':3, 'y':52, 'fontSize': 30, 'fillColor':\"black\"}) g1.drawText(\"X\", {'x':60, 'y':2, 'fontSize': 30, 'fontWeight': 800, 'lorg': 9, 'fillColor': \"black\"}); g1.drawText(\"Y\", {'x':2, 'y':30, 'fontSize': 30, 'fontWeight': 800, 'lorg': 1, 'fillColor': \"black\"}); g1.drawArrow(60, 0, {'shaftWidth':2.5, 'fillColor':'black'}); g1.drawArrow(0, 30, {'shaftWidth':2.5, 'fillColor':'black'}); g1.drawPath([\"M\", 0,0, \"L\", 35*cos30, 35*sin30, 0, 0]); g1.drawArrowArc(25, 0, 30, {'clockwise':False, 'shaftWidth':2.5, 'fillColor':'black'}); ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['can1_run'].bind('click', Ace.run) doc['can1_show_console'].bind('click', Ace.show_console) doc['can1_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 from browser import document as doc import ace # Brython 3.3.4 內建的 container 名稱為 'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id Ace = ace.Editor(editor_id=\"can2_editor\", console_id=\"can2_console\", container_id=\"can2_container\", storage_id=\"can2_py_src\" ) Ace.editor.setValue('''#Cango 繪圖 from browser import window import math cos30 = math.cos(30*math.pi/180) sin30 = math.sin(30*math.pi/180) # Javascript 物件 cango = window.Cango.new path = window.Path.new shape = window.Shape.new # Javascript 變數 shapedefs = window.shapeDefs g1 = cango(\"can2_container\") g1.clearCanvas() g1.gridboxPadding(10, 10, 5, 7) g1.fillGridbox(\"lightpink\") g1.setWorldCoordsSVG(0, 0, 100) g1.drawText(\"gc.setWorldCoordsSVG() 設為 Y 向下為正\", {'x':2, 'y':-6, 'fontSize': 30, 'fillColor':\"black\"}) g1.drawText(\"X\", {'x':60, 'y':2, 'fontSize': 30, 'fontWeight': 800, 'lorg': 3, 'fillColor': \"black\"}); g1.drawText(\"Y\", {'x':2, 'y':30, 'fontSize': 30, 'fontWeight': 800, 'lorg': 7, 'fillColor': \"black\"}); g1.drawArrow(60, 0, {'shaftWidth':2.5, 'fillColor':'black'}); g1.drawArrow(0, 30, {'shaftWidth':2.5, 'fillColor':'black'}); g1.drawPath([\"M\", 0,0, \"L\", 35*cos30, 35*sin30, 0, 0]); g1.drawArrowArc(25, 0, 30, {'clockwise':False, 'shaftWidth':2.5, 'fillColor':'black'}); ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['can2_run'].bind('click', Ace.run) doc['can2_show_console'].bind('click', Ace.show_console) doc['can2_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 from browser import document as doc import ace # Brython 3.3.4 內建的 container 名稱為 'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id Ace = ace.Editor(editor_id=\"can3_editor\", console_id=\"can3_console\", container_id=\"can3_container\", storage_id=\"can3_py_src\" ) Ace.editor.setValue('''#Cango Bezier 繪圖 from browser import window # Javascript 物件 cango = window.Cango.new path = window.Path.new shape = window.Shape.new group = window.Group.new # Javascript 變數 shapedefs = window.shapeDefs g1 = cango(\"can3_container\") g1.clearCanvas() g1.gridboxPadding(10, 10, 5, 7) g1.fillGridbox(\"lightgreen\") g1.setWorldCoordsRHC(-100, -100, 400) x1 = 40 y1 = 20 cx1 = 90 cy1 = 120 x2 = 120 y2 = 100 cx2 = 130 cy2 = 20 cx3 = 150 cy3 = 120 x3 = 180 y3 = 60 def dragC1(mousePos): global cx1, cy1 cx1 = mousePos.x cy1 = mousePos.y drawCurve() def dragC2(mousePos): global cx2, cy2 cx2 = mousePos.x cy2 = mousePos.y drawCurve() def dragC3(mousePos): global cx3, cy3 cx3 = mousePos.x cy3 = mousePos.y drawCurve() def drawCurve(): qbez = path(['M', x1, y1, 'Q', cx1, cy1, x2, y2], { 'strokeColor':'blue'}) cbez = path(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], { 'strokeColor':'green'}) L1 = path(['M', x1, y1, 'L', cx1, cy1, x2, y2], { 'strokeColor':\"rgba(0, 0, 0, 0.2)\", 'dashed':[4]}) L2 = path(['M', x2, y2, 'L', cx2, cy2], { 'strokeColor':\"rgba(0, 0, 0, 0.2)\", 'dashed':[4]}) L3 = path(['M', x3, y3, 'L', cx3, cy3], { 'strokeColor':\"rgba(0, 0, 0, 0.2)\", 'dashed':[4]}) c1.transform.translate(cx1, cy1) c2.transform.translate(cx2, cy2) c3.transform.translate(cx3, cy3) grp = group(qbez, cbez, L1, L2, L3, c1, c2, c3) g1.render(grp, True) g1.clearCanvas(\"lightyellow\") g1.deleteAllLayers() g1.setWorldCoordsRHC(0, 0, 200) c1 = shape(shapedefs.circle(6), {'fillColor':'red'}) c1.enableDrag(None, dragC1, None) c2 = shape(shapedefs.circle(6), {'fillColor':'red'}) c2.enableDrag(None, dragC2, None) c3 = shape(shapedefs.circle(6), {'fillColor':'red'}) c3.enableDrag(None, dragC3, None); drawCurve() ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['can3_run'].bind('click', Ace.run) doc['can3_show_console'].bind('click', Ace.show_console) doc['can3_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除","tags":"Course","url":"https://kmolab.github.io/blog/cango-brython-svg-canvas.html"},{"title":"Brython 3.3.4 程式環境","text":"利用 Brython 與 Ace 編輯器, 建立瀏覽器上的簡單 Python3 程式練習環境. canvas { border: 1px solid black; } window.onload=function(){ brython({debug:1, pythonpath:['./../data/py']}); } function doSave(storage_id, filename){ var blob = new Blob([localStorage[storage_id]], {type: \"text/plain;charset=utf-8\"}); filename = document.getElementById(filename).value saveAs(blob, filename+\".py\"); } 編寫 Python3 程式邏輯之前必須先了解基本的程式語法, 其中包括: Python3 變數命名規則與關鍵字 Python 英文變數命名規格 變數必須以英文字母大寫或小寫或底線開頭 變數其餘字元可以是英文大小寫字母, 數字或底線 變數區分英文大小寫 變數不限字元長度 不可使用關鍵字當作變數名稱 使用者可以利用以下程式列出所使用 Python 的版次與關鍵字: from browser import document as doc import ace # Brython 3.3.4 內建的 container 名稱為 'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id Ace = ace.Editor(editor_id=\"kw_editor\", console_id=\"kw_console\", container_id=\"kw__container\", storage_id=\"kw_py_src\" ) Ace.editor.setValue('''# 導入 sys 模組 import sys # 導入 keyword 模組 import keyword # 利用 sys 模組中的 version_info 印出 Python 版次 print(\"Python version: \", sys.version_info) # 利用 keyword 模組中的 kwlist 印出關鍵字 print(\"Python keywords: \", keyword.kwlist) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['kw_run'].bind('click', Ace.run) doc['kw_show_console'].bind('click', Ace.show_console) doc['kw_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 Python3 的程式關鍵字, 使用者命名變數時, 必須避開下列保留字. Python keywords: ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 選擇好的變數名稱: 使用有意義且適當長度的變數名稱， 例如: 使用 length 代表長度, 不要單獨使用 l 或 L, 也不要使用 this_is_the_length 程式前後變數命名方式盡量一致, 例如: 使用 rect_length 或 RectLength 用底線開頭的變數通常具有特殊意義 print() 函式用法 print() 為 Python 程式語言中用來列印數值或字串的函式, 其中有 sep 變數定義分隔符號, ｓep 內定為 \",\", end 變數則用來定義列印結尾的符號, end 內定為跳行符號. for 迴圈用法與 Python 的縮排規定 重複迴圈用法, 使用者可以透過下列程式編輯區練習 for 迴圈與 print() 函式的用法. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"editor\", console_id=\"console\", container_id=\"first_container\", storage_id=\"py_src\" ) Ace.editor.setValue('''#ex1 簡單的 for 迴圈範例 for i in range(10): print(i) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['run'].bind('click', Ace.run) doc['show_console'].bind('click', Ace.show_console) doc['clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 下列的 Brython turtle 網際繪圖程式僅提供參考, 可以用來練習 Python3 程式語法. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"turtle_editor\", console_id=\"turtle_console\", container_id=\"container\", storage_id=\"turtle_py_src\" ) Ace.editor.setValue('''import turtle t=turtle.Turtle() t.penup() t.left(45) t.backward(125) t.right(45) t.pendown() for c in ['red', 'green', 'yellow', 'blue']: t.color(c) t.forward(75) t.left(90) t1=turtle.Turtle(\"turtle\") t1.penup() t1.pendown() t1.width(3) for c in ['red', 'blue', 'yellow', 'green', 'purple', 'brown']: t1.color(c) t1.forward(50) t1.left(60) t1.penup() t1.left(60) t1.backward(120) t1.pendown() t1.color('red') t1.write(\"I love Brython!!\") turtle._Screen().end() ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) doc['turtle_run'].bind('click', Ace.run) doc['turtle_show_console'].bind('click', Ace.show_console) doc['turtle_clear_console'].bind('click', Ace.clear_console) doc['turtle_clear_container'].bind('click', Ace.clear_container) Filename: .py Run Output 清除 清除畫布 函式用法與呼叫 使用者可以利用下列程式, 練習 def 函式定義與呼叫的用法. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"fun_editor\", console_id=\"fun_console\", container_id=\"fun_container\", storage_id=\"fun_py_src\" ) Ace.editor.setValue('''# 定義函式 def square_of_x(x): return x*x # 呼叫函式 y = square_of_x(3) # 列印 y 對應內容 print(y) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['fun_run'].bind('click', Ace.run) doc['fun_show_console'].bind('click', Ace.show_console) doc['fun_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 以下網際繪圖程式, 僅提供參考. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"by_editor\", console_id=\"by_console\", container_id=\"by_container\", storage_id=\"by_py_src\" ) Ace.editor.setValue('''# First of all, the import of some libraries from browser import document as doc from browser import html # All the elements will be inserted in the div with the \"container\" id container = doc['by_container'] # We create a new div element newdiv = html.DIV(id = \"new-div\") # Now we add some style newdiv.style = {\"padding\": \"5px\", \"backgroundColor\": \"#ADD8E6\"} # Now, lets add a table with a column with numbers and a # column with a word on each cell text = \"Brython is really cool\" textlist = text.split() table = html.TABLE() for i, word in enumerate(textlist): table <= html.TR(html.TD(i + 1) + html.TD(word)) # Now we add some style to the table table.style = {\"padding\": \"5px\", \"backgroundColor\": \"#aaaaaa\", \"width\": \"100%\"} # Now we add the table to the new div previously created newdiv <= table + html.BR() # a form? why not? form = html.FORM() input1 = html.INPUT(type=\"text\", name=\"firstname\", value=\"First name\") input2 = html.INPUT(type=\"text\", name=\"lastname\", value=\"Last name\") input3 = html.BUTTON(\"Button with no action!\") form <= input1 + html.BR() + input2 + html.BR() + input3 newdiv <= form + html.BR() # Finally, we will add something more 'HTML5istic', a canvas with # a color gradient in the newdiv previously created and below the form canvas = html.CANVAS(width = 300, height = 300) #canvas.style = {\"width\": \"100%\"} ctx = canvas.getContext('2d') ctx.rect(0, 0, 300, 300) grd = ctx.createRadialGradient(150, 150, 10, 150, 150, 150) grd.addColorStop(0, '#8ED6FF') grd.addColorStop(1, '#004CB3') ctx.fillStyle = grd ctx.fill() newdiv <= canvas # And finally we append the newdiv element # to the parent, in this case the div with the \"container\" id container <= newdiv ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['by_run'].bind('click', Ace.run) doc['by_show_console'].bind('click', Ace.show_console) doc['by_clear_console'].bind('click', Ace.clear_console) doc['by_clear_container'].bind('click', Ace.clear_container) Filename: .py Run Output 清除 清除畫布 以下網際動態繪圖程式, 僅提供參考. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"clock_editor\", console_id=\"clock_console\", container_id=\"clock_container\", storage_id=\"clock_py_src\" ) Ace.editor.setValue('''# First of all, the import of some libraries import time import math import datetime from browser import document as doc import browser.timer from browser import html sin,cos = math.sin,math.cos width,height = 250,250 # canvas dimensions ray = 100 # clock ray # All the elements will be inserted in the div with the \"container\" id container = doc['clock_container'] # We create a new div element newdiv = html.DIV(id = \"new-div\") # Now we add some style newdiv.style = {\"padding\": \"5px\", \"backgroundColor\": \"#ADD8E6\"} canvas = html.CANVAS(width = width, height = height) #canvas.style = {\"width\": \"100%\"} ctx = canvas.getContext('2d') def needle(angle,r1,r2,color=\"#000000\"): # draw a needle at specified angle in specified color # r1 and r2 are percentages of clock ray x1 = width/2-ray*cos(angle)*r1 y1 = height/2-ray*sin(angle)*r1 x2 = width/2+ray*cos(angle)*r2 y2 = height/2+ray*sin(angle)*r2 ctx.beginPath() ctx.strokeStyle = color ctx.moveTo(x1,y1) ctx.lineTo(x2,y2) ctx.stroke() def set_clock(): # erase clock ctx.beginPath() ctx.fillStyle = \"#FFF\" ctx.arc(width/2,height/2,ray*0.89,0,2*math.pi) ctx.fill() # redraw hours show_hours() # print day now = datetime.datetime.now() day = now.day ctx.font = \"bold 14px Arial\" ctx.textAlign = \"center\" ctx.textBaseline = \"middle\" ctx.fillStyle=\"#FFF\" ctx.fillText(day,width*0.7,height*0.5) # draw needles for hour, minute, seconds ctx.lineWidth = 3 hour = now.hour%12 + now.minute/60 angle = hour*2*math.pi/12 - math.pi/2 needle(angle,0.05,0.5) minute = now.minute angle = minute*2*math.pi/60 - math.pi/2 needle(angle,0.05,0.85) ctx.lineWidth = 1 second = now.second+now.microsecond/1000000 angle = second*2*math.pi/60 - math.pi/2 needle(angle,0.05,0.85,\"#FF0000\") # in red browser.timer.set_interval(set_clock,100) ctx.beginPath() ctx.lineWidth = 10 ctx.arc(width/2,height/2,ray,0,2*math.pi) ctx.stroke() for i in range(60): ctx.lineWidth = 1 if i%5 == 0: ctx.lineWidth = 3 angle = i*2*math.pi/60 - math.pi/3 x1 = width/2+ray*cos(angle) y1 = height/2+ray*sin(angle) x2 = width/2+ray*cos(angle)*0.9 y2 = height/2+ray*sin(angle)*0.9 ctx.beginPath() ctx.moveTo(x1,y1) ctx.lineTo(x2,y2) ctx.stroke() def show_hours(): ctx.beginPath() ctx.arc(width/2,height/2,ray*0.05,0,2*math.pi) ctx.fillStyle = \"#000\" ctx.fill() for i in range(1,13): angle = i*math.pi/6-math.pi/2 x3 = width/2+ray*cos(angle)*0.75 y3 = height/2+ray*sin(angle)*0.75 ctx.font = \"20px Arial\" ctx.textAlign = \"center\" ctx.textBaseline = \"middle\" ctx.fillText(i,x3,y3) # cell for day ctx.fillStyle = \"#000\" ctx.fillRect(width*0.65,height*0.47,width*0.1,height*0.06) show_hours() set_clock() newdiv <= canvas # And finally we append the newdiv element # to the parent, in this case the div with the \"container\" id container <= newdiv ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['clock_run'].bind('click', Ace.run) doc['clock_show_console'].bind('click', Ace.show_console) doc['clock_clear_console'].bind('click', Ace.clear_console) doc['clock_clear_container'].bind('click', Ace.clear_container) Filename: .py Run Output 清除 清除畫布 基本物件導向與案例 Python 採用類別 (class) 將案例變數 (instance variables) 與案例方法 (instance methods) 包在一起, 並用來定義一種物件 (object). 物件導向具有封裝 (encapsulation) , 繼承 (inheritance) 與多形 ( polymorphism) 等三種特性. 使用者可以利用下列程式練習 Python3 物件的定義與應用. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"oop1_editor\", console_id=\"oop1_console\", container_id=\"oop1_container\", storage_id=\"oop1_py_src\" ) Ace.editor.setValue('''# Robot class 定義 class Robot(object): def __init__(self, name, by): self._name = name self._build_year = by @property def name(self): return self._name @name.setter def name(self, newname): self._name = name @property def build_year(self): return self._build_year @build_year.setter def build_year(self, newby): self._build_year = newby x = Robot(\"bob\", 1993) x.build_year = 1993 print(x.name) print(x.build_year) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['oop1_run'].bind('click', Ace.run) doc['oop1_show_console'].bind('click', Ace.show_console) doc['oop1_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 以下平面機構動態模擬程式, 僅提供參考. from browser import document as doc import ace Ace = ace.Editor(editor_id=\"link_editor\", console_id=\"link_console\", container_id=\"fourbar\", storage_id=\"link_py_src\" ) Ace.editor.setValue('''# 導入所需模組 from browser import document as doc from browser import window from browser import timer from browser import html import math # 利用 window 擷取 PrairieDraw 程式庫變數物件, 然後以 new 方法轉為 Brython 變數 pdraw = window.PrairieDraw.new # 利用 window 擷取 PrairieDrawAnim 程式庫變數物件, 然後以 new 方法轉為 Brython 變數 PrairieDrawAnim = window.PrairieDrawAnim.new # 利用 window 擷取 sylvester 程式庫變數物件 Vector, 並將其 create 方法直接轉為 Brython 變數 # 在 sylvester 中的 $V 簡化變數無法直接在 Brython 程式中引用 vector = window.Vector.create # 在 \"fourbar\" 畫布中建立 panim 動態模擬案例 panim = PrairieDrawAnim(\"fourbar\") # 平面連桿繪圖以 t = 0 起始 t = 0 # 控制轉動方向變數 direction = True # 繪製不同 t 時間下的平面連桿 def draw(): global t, direction, fast # 設定模擬繪圖範圍 panim.setUnits(6, 6) # 設定箭頭線寬 panim.setProp(\"arrowLineWidthPx\",2) # 起始變數設定 omega = 1 length_bar1 = 1 length_bar2 = 26/18 length_bar3 = 2 length_base = 40/18 time = 0 # 畫出地面直線 G = vector([0, -0.5]) panim.ground(G, vector([0, 1]), 10) # 連桿長度與角度計算 A = t*omega # \"theta\" AD = length_bar1 #length of left bar AB = length_base #distance between two stationary pivots BC = length_bar3 #length of right bar CD = length_bar2 #length of middle bar BD = math.sqrt(AD*AD + AB*AB - 2*AD*AB*math.cos(A)) C = math.acos((BC*BC + CD*CD - BD*BD)/(2*BC*CD)) ABD = math.asin(CD * math.sin(C) / BD) DBC = math.asin(AD * math.sin(A) / BD) B = ABD + DBC D = math.pi - B - C # draw pivot pivot_left = vector([AB/-2, 0]) pivot_right = vector([AB/2, 0]) panim.pivot(vector([pivot_left.e(1), -0.5]), pivot_left, 0.5) panim.pivot(vector([pivot_right.e(1), -0.5]), pivot_right, 0.5) # 儲存轉換矩陣 panim.save() #FIRST BAR panim.translate(pivot_left) panim.rotate(A) panim.rod(vector([0,0]), vector([AD,0]), 0.25) panim.point(vector([0,0])) #SECOND BAR panim.translate(vector([AD,0])) panim.rotate(A*-1) #\"undo\" the original A rotation panim.rotate(D) #rotate by D only panim.rod(vector([0,0]), vector([CD,0]), 0.25) panim.point(vector([0,0])) #THIRD BAR panim.translate(vector([CD,0])) panim.rotate(math.pi+C) panim.rod(vector([0,0]), vector([BC,0]), 0.25) panim.point(vector([0,0])) # 回復原先的轉換矩陣 panim.restore() panim.point(vector([pivot_right.e(1), 0])) # 時間增量 if direction == True: t += 0.08 else: t += -0.08 # 先畫出 t = 0 的連桿機構 draw() # 將 anim 設為 None anim = None def launchAnimation(ev): global anim # 初始啟動, anim 為 None if anim is None: # 每 0.08 秒執行一次 draw 函式繪圖 anim = timer.set_interval(draw, 80) # 初始啟動後, 按鈕文字轉為\"暫停\" doc['power'].text = '暫停' elif anim == 'hold': # 當 anim 為 'hold' 表示曾經暫停後的啟動, 因此持續以 set_interval() 持續旋轉, 且將 power 文字轉為\"暫停\" anim = timer.set_interval(draw, 80) doc['power'].text = '暫停' else: # 初始啟動後, 使用者再按 power, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停 # 且將 anim 變數設為 'hold', 且 power 文字轉為\"繼續\" timer.clear_interval(anim) anim = 'hold' doc['power'].text = '繼續' def reverse(ev): global anim, direction # 當 anim 為 hold 時, 按鈕無效 if anim != \"hold\": if direction == True: direction = False else: direction = True doc[\"power\"].bind(\"click\", launchAnimation) doc[\"reverse\"].bind(\"click\", reverse) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['link_run'].bind('click', Ace.run) doc['link_show_console'].bind('click', Ace.show_console) doc['link_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 啟動 反向 平面機構運動模擬 以下為 Jansen's 八連桿機構的基本 Kinematic 運算, 先採用 Sympy 以符號式推導出機構端點的運動軌跡方程式後, 利用 Python 執行數值分析運算, 列出機構端點的座標. from browser import document as doc # 表示要導入 data/py/ace.py import ace Ace = ace.Editor(editor_id=\"jansen_editor\", console_id=\"jansen_console\", container_id=\"jansen_container\", storage_id=\"jansen_py_src\" ) Ace.editor.setValue('''#jansen 多連桿機構驗算 from math import pi, cos, sin, sqrt, acos radian = 180/pi degree = pi/180 #PLAP def plap(ax, ay, ac, bac, bx, by, ccw): if ccw == 1: cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay else: cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay return cx, cy #PLLP def pllp(ax, ay, ac, cb, bx, by, cw): if cw == 1: cx = -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) cy = (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) else: cx = -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) cy = (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)) return cx, cy ax = -38 ay = 0 # b 為原點 bx = 0 by = 0 cx = 0 cy = 7.8 # m 為配合 PLAP 新增固定點 mx = 30 my = 7.8 # dcm ccw 方向角度 dcm = 30*degree cd = 15 # 三角形 dcm 為 ccw plap d=(a, cd, dcm, m) dx, dy = plap(cx, cy, cd, dcm, mx, my, ccw=1) print(\"dx=\", dx, \"dy=\", dy) # 三角形 aed 為 cw pllp e=(a, ae, ed, d) ae = 41.5 ed = 50 ex, ey = pllp(ax, ay, ae, ed, dx, dy, cw=1) print(\"ex=\", ex, \"ey=\", ey) # 三角形 afe 為 cw pllp f=(a, af, fe, e) af = 40.1 fe = 55.8 fx, fy = pllp(ax, ay, af, fe, ex, ey, cw=1) print(\"fx=\", fx, \"fy=\", fy) # 三角形 dha 為 cw pllp h=(d, dh, ha, a) dh = 61.9 ha = 39.3 hx, hy = pllp(dx, dy, dh, ha, ax, ay, cw=1) print(\"hx=\", hx, \"hy=\", hy) # 三角形 hgf 為 cw pllp g=(h, hg, gf, f) hg = 36.7 gf = 39.4 gx, gy = pllp(hx, hy, hg, gf, fx, fy, cw=1) print(\"gx=\", gx, \"gy=\", gy) # 三角形 hkg 為 cw pllp k=(h, hk, kg, g) hk = 49 kg = 65.7 kx, ky = pllp(hx, hy, hk, kg, gx, gy, cw=1) print(\"kx=\", kx, \"ky=\", ky) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['jansen_run'].bind('click', Ace.run) doc['jansen_show_console'].bind('click', Ace.show_console) doc['jansen_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 以下為與上述 Jansen's 八連桿機構對應的座標驗證圖, 機構端點座標 kx= -30.81 ky= -84.02: 平面機構數目合成 itertools module implements a number of iterator building blocks. itertools.product(*iterables, repeat=1) - Cartesian product of input iterables. 根據 http://www.iftomm2015.tw/IFToMM2015CD/PDF/OS2-048.pdf (or local download ) from browser import document as doc # 表示要導入 data/py/ace.py import ace Ace = ace.Editor(editor_id=\"numsyn_editor\", console_id=\"numsyn_console\", container_id=\"numsyn_container\", storage_id=\"numsyn_py_src\" ) Ace.editor.setValue('''#數目合成 from itertools import product # NL links and NJ joints as inputs class NumberSynthesis: def __init__(self, NL, NJ): self.NL = NL self.NJ = NJ @property def Mmax(self): if self.NL <= self.NJ and self.NJ <= (2*self.NL-3): return self.NJ - self.NL + 2 elif (2*self.NL-3) <= self.NJ and self.NJ <= (self.NL*(self.NL-1)/2): return self.NL - 1 else: raise ValueError(\"incorrect number.\") @property def NLm(self): result = [] correction = lambda l: sum((i+2)*l[i] for i in range(len(l))) == 2*self.NJ for symbols in product(range(self.NL+1), repeat=self.Mmax-2): NLMmax = self.NL - sum(symbols) answer = symbols+(NLMmax,) if correction(answer) and NLMmax>=0: result.append(answer) return tuple(result) a = NumberSynthesis(9, 11) print(\"the maximum number of joints incident to a link: \", a.Mmax) print(\"link assortments of the generalized kinematic chains: \", a.NLm) ''') Ace.editor.scrollToRow(0) Ace.editor.gotoLine(0) # 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定 doc['numsyn_run'].bind('click', Ace.run) doc['numsyn_show_console'].bind('click', Ace.show_console) doc['numsyn_clear_console'].bind('click', Ace.clear_console) Filename: .py Run Output 清除 目前所在頁面, 分別利用 Brython 與 Ace 編輯器, 可直接在網誌中執行 Python3 程式, 基本架構為將 Brython 的標準輸出轉到特定 div 標註, 而 Ace 編輯器則設為與其內的程式碼相同長度, 但至多只會在頁面中顯示 20 行, 且編輯器內的程式碼使用 12 號字元. ace.py 原始碼, 位於 data/py 目錄中, 將原先只能單一呼叫的函式改為物件, 可以在同一頁面中產生案例時, 透過各標註的 id 字串區分各段程式碼, 是本課程 Python3 物件導向程式的實際應用範例, 謹提供參考. import sys import time import traceback import javascript from browser import document as doc, window, alert if hasattr(window, 'localStorage'): from browser.local_storage import storage else: storage = None class cOutput: def __init__(self, target): self.target = doc[target] def write(self, data): self.target.value += str(data) class Editor(): def __init__(self, editor_id, console_id, container_id, storage_id): self.editor_id = editor_id self.console_id = console_id self.container_id = container_id self.storage_id = storage_id self.output = '' try: self.editor = window.ace.edit(self.editor_id) session = self.editor.getSession() session.setMode(\"ace/mode/python\") self.editor.setOptions({ 'enableLiveAutocompletion': True, 'enableSnippets': True, 'highlightActiveLine': False, 'highlightSelectedWord': True, 'autoScrollEditorIntoView': True, # 'maxLines': session.getLength() 可以根據程式長度設定 editor 列數 # 設定讓使用者最多可以在畫面中顯示 20 行程式碼 'maxLines': 20, 'fontSize': '12pt' }) except: from browser import html self.editor = html.TEXTAREA(rows=20, cols=70) doc[self.editor_id] <= self.editor def get_value(): return self.editor.value def set_value(x): self.editor.value = x self.editor.getValue = get_value self.editor.setValue = set_value def run(self, *args): sys.stdout = cOutput(self.console_id) sys.stderr = cOutput(self.console_id) doc[self.console_id].value = '' src = self.editor.getValue() if storage is not None: storage[self.storage_id] = src t0 = time.perf_counter() try: #ns = {'__name__':'__main__'} # 以 self.editor_id 名稱執行程式 ns = {'__name__': self.editor_id} exec(src, ns) state = 1 except Exception as exc: traceback.print_exc(file=sys.stderr) state = 0 self.output = doc[self.console_id].value print('<completed in %6.2f ms>' % ((time.perf_counter() - t0) * 1000.0)) return state def show_console(self, ev): doc[self.console_id].value = self.output doc[self.console_id].cols = 60 doc[self.console_id].rows = 10 def clear_console(self, ev): doc[self.console_id].value = \"\" def clear_container(self, ev): doc[self.container_id].clear() # load a Python script def load_script(self, evt): _name = evt.target.value + '?foo=%s' % time.time() self.editor.setValue(open(_name).read())","tags":"Course","url":"https://kmolab.github.io/blog/brython-programming-environment.html"},{"title":"CMSimfly 與 Fossil SCM","text":"CMSimfly 是一套採用 Flask 應用程式框架編寫的網際內容管理系統 (Content Management System), Fossil SCM 則是以 ANSI C 編寫的軟體組態管理 (Software Configuration Management) 系統, 兩套程式各有不同的特色, CMSimfly 適合用來管理無版次的大型檔案, 而 Fossil SCM 則可用來記錄詳細的軟體設計開發歷程. CMSimfly 與 Fossil SCM 安裝規劃 CMSimfly 採用 Python3 與 Flask 編寫, 可以採用 uwsgi 模組啟動, 預計網際前端透過 Nginx https 埠號 8443 承接來自瀏覽器的請求, 而 Fossil SCM 的 http port 80 前端則由 Nginx 承接後, 直接跳轉 Stunnel 所代理的 https 服務. 因此當使用者以瀏覽器 http 連線, 伺服器會馬上跳轉 https 的 Fossil SCM, 假如要連結 CMSimfly, 則必須以 https 8443 連線. uwsgi 有多種啟動方式, 在此希望透過 Emperor 的多應用程式的模式啟動, 基本架構是, uwsgi 指令在 /etc/rc.local 中以 exec 執行, 可以在伺服器開機時執行, 而 uwsgi Emperor 中指定以一般用戶身分執行, 實際封包在內部網路的 8081 啟動, 之後透過 /etc/nginx/sites-available/default 中的 server 設定, 只接受 8443 埠號的 IPv4 與 IPv6 網際瀏覽器請求. CMSimfly 安裝設定 根據 uwsgi 與 Emperor 的啟動, 伺服器所需模組, 包括 pip3, Flask, python3 開發環境, uwsgi, nginx 與 uwsgi-plugin-python3 模組: sudo apt install python3-pip sudo pip3 install Flask sudo apt install build-essential python3-dev sudo pip3 install uwsgi sudo apt install nginx uwsgi-plugin-python3 而 /etc/nginx/sites-available/default 的設定 server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://my.server.host.name; } server { listen 8443 ssl; listen [::]:8443 ssl; location /static { alias /home/user/cmsimfly/static/; } location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8081; } server_name my.server.host.name; ssl on; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } 位於 /home/user/uwsgi_ini/ 目錄下的 uwsgi.ini 檔案設定: [uwsgi] socket = 127.0.0.1:8081 uid = user gid = user plugins-dir = /usr/lib/uwsgi/plugins/ plugin = python3 master = true process = 4 threads = 2 chdir = /home/user/cmsimfly wsgi-file = /home/user/cmsimfly/wsgi.py 假如希望額外啟動其他的 uwsgi 程式, 例如第二組 CMSimfly 或其他對應的 Flask 應用程式, 則需要在 /etc/nginx/sites-available/default 增加另外一組 server 設定, 主要在選定內部網路的特定埠號, 例如: 127.0.0.1:8082, 編寫 default 設定檔案成為: server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://my.server.host.name; } server { listen 8443 ssl; listen [::]:8443 ssl; location /static { alias /home/user/cmsimfly/static/; } location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8081; } server_name my.server.host.name; ssl on; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } server { listen 9443 ssl; listen [::]:9443 ssl; location /static { alias /home/user/cmsimfly2/static/; } location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8082; } server_name my.server.host.name; ssl on; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } 然後在 /home/user/uwsgi_ini 目錄中, 再配合增加一組 uwsgi2.ini, 內容為: [uwsgi] socket = 127.0.0.1:8082 uid = user gid = user plugins-dir = /usr/lib/uwsgi/plugins/ plugin = python3 process = 4 threads = 2 chdir = /home/user/cmsimfly2 wsgi-file = /home/user/cmsimfly2/wsgi.py /etc/nginx/sites-available/default 與 /home/user/uwsgi_ini/uwsgi2.ini 設定修改後, 只要透過 /etc/init.d/nginx restart 重新啟動 Nginx, 並且重新執行 uwsgi 指令, 意即, uwsgi --emperor /home/user/uwsgi_ini, 納入 /home/user/uwsgi_ini/uwsgi.ini 與 /home/user/uwsgi_ini/uwsgi2.ini 的多 uwsgi Emperor 架構應用程式即可在 https://my.sever.host.name:9443 多一組 CMSimply 網際內容管理的伺服. 若要讓伺服器在開機時執行 uwsgi, 則需要在/etc/rc.local 加入: exec uwsgi --emperor /home/user/uwsgi_ini 過程中若需要重新啟動 nginx, 以 /etc/init.d/nginx restart 執行. Fossil SCM 與 Stunnel 聯合啟動 因為在 Nginx /etc/nginx/sites-available/default 中已經將 port 80 的回應處理直接透過 http 301 狀態碼的宣告, 永久轉接到 https://my.server.host.name, 因此只要透過 Stunnel 代理在標準的 IPv4 與 IPv6 網路協定中, 以 https 啟動 Fossil SCM 即可. 首先要安裝 Stunnel 與 Fossil SCM: sudo apt update sudo apt install stunnel4 -y sudo apt install fossil 讓 Stunnel 開機時啟動: /etc/default/stunnel4 檔案設定, 將原先內定的 ENABLED=0 改為 1: ENABLED=1 因為要以 https 設定 /etc/stunnel/stunnel.conf, 因此 /etc/stunnel 目錄中需要 stunnel.crt 與 stunnel.key. 在 /etc/stunnel 目錄中執行 openssl 指令: sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout stunnel.key -out stunnel.crt 然後設定 /etc/stunnel/stunnel.conf: [https] accept = your.ipv4.ip:443 accept = :::443 cert = /etc/stunnel/localhost.crt key = /etc/stunnel/localhost.key exec = /usr/bin/fossil execargs = /usr/bin/fossil http /home/user/ --https --nojail --notfound default 重新啟動 stunnel 時, 執行 /etc/init.d/stunnel4","tags":"Research","url":"https://kmolab.github.io/blog/cmsimfly-and-fossil-on-same-machine.html"},{"title":"2017 Fall 主機設定","text":"在 2017 年 Spring, 電腦輔助設計室購入兩台 HP 伺服器, 分別是 HPE ProLiant ML10 Gen9 Server 與 HPE ProLiant ML350 Gen9 Server , 操作系統為 Ubuntu 16.04, 根據 Ubuntu LTS 通告 , 使用週期可至 2021 年, 預計在 2019 年 Spring 由新伺服器接手提供服務. 近端、區網與雲端其實是同一端 自 2017 年 10 月起, 已經沒有免費的 OpenShift 雲端服務可以使用, 遠端較穩定的 html + javascript hosting 只剩下 Github Pages, 但是就課程與研究所需的近端、區網與雲端上的各項服務而言, 雲端的免費套餐終將越來越縮水的情況下, 強化近端與區網上的軟硬體服務, 將會更加重要. 這個學期工作站室的伺服器, 將全面使用 Fossil SCM 管理所有的課程與研究專案, 每一位上課的學員都將在近端與區網擁有一個 Fossil 倉儲, 用來存放與課程相關的所有內容. Github 與 Bitbuckert 等雲端免費方案仍然扮演重要角色, 只是在無廣域網路連線與區域網路連線的情況下, 各學員的各項課程內容演練與操作資料提交, 將能在隨身的可攜系統上完成, 之後再配合區網與雲端網路的連線, 設法在分組協同的模式下, 將近端資料同步到區網與雲端主機. 因此 2017 Fall 起, 如何在近端、區網與雲端不同硬體環境下, 保持倉儲資料版本的同步, 就是另外一個重點. 主機設定 接下來, 我們透過 https://cadpb.kmol.info/40523201 學員倉儲, 來說明提供 Fossil SCM 服務的主機如何設定. 首先當然是要先掌握 kmol.info 網域的主導權, 透過網域 DNS 的控管, 讓區域網路中的主機可以在 A 與 AAA 設定下的 IPv4 與 IPv6 網址呼應, 例如: cadpb.kmol.info 指的就是 cadp 電腦輔助設計實習課程中的 b 班所使用的伺服器名稱. 如前所述, 這些伺服器都是安裝 Ubuntu 16.04 Server 操作系統 + OpenSSH, 目的是希望在 Self-signed Certificate 的模式下運作. 接著必須根據 多 Fossil SCM 倉儲主機 的架構, 分別安裝 Fossil SCM 與 Stunnel. 其中, 特別將 Fossil SCM 伺服的目錄指向 /home/cadpa2017, 表示各操作系統帳號所有人, 可以自行利用 fossil 指令, 建立多個倉儲, 此一模式就是同一台主機可以透過網域來界定上課班級, 操作系統帳號可以界定大分組名稱, 而採用學號的倉儲名稱則可以用來界定參與協同的所有者. 因此, 一旦各倉儲所有者掌握管理該 .fossil 檔案的總管理權之後, 可以將其他學員納入自己所掌控的 .fossil users 中, 視實際需求賦於各帳號不同權限. 且可透過制式的 URL, 在得知各班各分組的成員學號情況下, 連結至各學員的倉儲中進行資料檢視. 機械設計專案的資料格式 由於設計是一種利用口語、文字、2D、3D、數學與實體等形式, 所完成的明確與具體表達, 過程中必須仔細思考、多方考量, 而且在不同時段與多人協同合作的結果, 將會產生許多不同的資料版本. 加上二十一世紀的機械可說是各種固體、流體與軟體元件精巧組合而成, 能達成特定功能之器物. 因此機械設計專案過程所產生的各種資料及版本, 更需要特別關注並竭力保存, 以便讓新舊學員在自學、執行與想像的創造力發揮階段, 擁有可持續改進的工具之外, 也能有保有多元開放的完整學習資料. 在這樣對於機械設計表達、內容物與創造流程的認知下, 我們會希望學員在口語表達階段除了錄音之外, 能夠利用 Reveal.js 投影片寫下文字資料, 能儘量採用開放的設計格式, 在 Fossil SCM 倉儲中保留可以持續追蹤的文字資料格式, 2D/3D 的末端二位元檔案, 並非版次管理系統所關注並保留的重點, 學員該紀錄的是, 各種末端檔案是在何種情況下, 根據哪些約束條件, 用甚麼方法產生, 隨後的使用者在檢視歷史資料的同時, 應該可以根據這些較能持續改進的文字資料, 配合不同的情況, 使用不同的工具, 建立其所需的二位元末端檔案. 換言之, 一個多元開放的機械設計專案, 在導入各種軟硬體組態管理的時間點, 必須全面檢視所用的工具, 所處的環境, 盡量採用能持續改進的專案資料格式, 而非只儲存不知前因與狀況下所產生的封閉格式檔案. 文字、大綱與程式 當上述 Fossil SCM 主機的設定, 可以讓各學員個別管理 .fossil 倉儲檔案之後, 利用瀏覽器介面可以控管 users, 可以利用 wiki 建立快寫網頁, 可以將各種影片檔案以 attach 方式附加在 wiki 頁面中, 也可以在專案進行過程利用 tickets 追蹤設計問題, 並在專案階段性任務完成時, 以 technote 紀錄成果. 除了利用瀏覽器介面維護的協同內容之外, 機械設計過程中採 Pelican Blog 紀錄的網誌, 採 Reveal.js 格式的簡報網頁, 以及各種計算機程式檔案, 則必須在文字、大綱與程式架構下來進行管理. 在此我們所採用的管理工具為 Leo Editor, SciTE 與 Eric6. Leo Editor 是一套採用 Python3 + PyQt5 所編寫的大綱管理套件, 其任務是負責利用大綱架構管理鬆散的 Pelican Blog, 並且利用 button 執行操作系統指令, 還肩負透過 Python3 程式碼所組成的 button, 在近端啟動 IPv4 與 IPv6 WWW 伺服模擬環境, 能讓學員在近端檢視所有之後要推送到區網與雲端中的網誌與投影片內容. SciTE 則提供文字編輯以及 Python3 與 ANSI C 程式執行環境, 而 Eric6 則用於 PyQt5 程式的開發. 純 IPv6 主機設定 目前在系主幹上的電腦已經可以選擇透過 IPv6 DHCP 或自行設定 IPv6 位址連線上網. 在安裝 Ubuntu 16.04 Server 時, 選擇安裝 OpenSSH 模組, 之後則必須透過 IPv4/IPv6 雙支援的 Squid Proxy Server 才可以利用 apt 維護系統所安裝的套件. apt Proxy 的設定必須在 /etc/apt/atp.conf 中納入: Acquire::http::Proxy \"http://[2001:288:6004:17::87]:3128\"; 直接存檔後, apt 指令就可以透過 Proxy Server 連接到只支援 IPv4 網路協定的電腦. Ubuntu Server 安裝後, 若希望安裝 ubuntu-desktop: sudo apt install ubuntu-desktop 接著必須在 Firefox 瀏覽中設定 Proxy Server 代理主機, 否則無法連到只支援 IPv4 網路協定的網站. 其中 Firefox 的 Proxy Server 設定, Proxy Server 的 IPv6 網址無需中括號. 其次若希望採用自訂的 IPv6 網路設定, 可以修改 /etc/network/interfaces 檔案 啟用 inet6 static or auto address 2001... netmask 64 gateway 2001... dns-nameservers 2001:b000:168::1 最後則安裝設定中文輸入法: sudo apt install fcitx fcitx-chewing 然後修改系統的 language support 將輸入法改為 fcitx 設定後, 必須登出再登入, 讓設定生效, input method 則選擇 chewing. 各階段設定檔案 Stunnel 的設定, 目的在與 Fossil SCM 結合, 提供 https 的連線代理. /etc/stunnel/stunnel.conf [https] accept = your_IPv4_ip:443 accept = :::443 cert = /etc/stunnel/localhost.crt key = /etc/stunnel/localhost.key exec = /usr/bin/fossil execargs = /usr/bin/fossil http /home/ --https --nojail --notfound user/default 因為 Fossil SCM 加上 Stunnel 設定時, 已經將連線協定設為 HTTPS, 因此 http 伺服則交由 nginx 回應: sudo apt install nginx 之後再些改 /etc/ nginx/site-available/default nginx return 301 設定: server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 301 https://hp.kmol.info; }","tags":"Research","url":"https://kmolab.github.io/blog/2017fall-srver-setup.html"},{"title":"2017 Fall 即將開學","text":"再過幾天, 2017 Fall 學期即將開始, 去年 copy.com 免費雲端磁碟停止提供服務, 這個月底 OpenShift 的 online 2 免費帳號也將走入歷史, 可以預期, 之後 Github 與 Bitbucket 的免費方案也將會越來越限縮, 或許就連 Onshape 與 V-rep 目前所提供的免費教育授權, 也會步上相同後塵. 課程工具檢討 以機械設計工程師的培訓角度而言, 除了第三方的雲端系統外, 還有自建的廣域網路上的伺服器, 區域網路上的伺服器, 以及單機隨身系統上的伺服器. 其中自建的三種伺服器都能從 http://service.mde.tw/public/python2017fall_36.7z 隨身系統中所提供的工具進行配置與模擬. 可攜隨身系統中最重要的工具為 Python3 程式環境, 搭配 SCiTE, TinyC, Leo Editor, Pelican, Reveal.js, Eric6 IDE, 以及 Flask 與 Brython, 使用者可以編寫 PyQt5 套件, 可以練習以 ANSI C 建立簡單的動態連結程式庫, 配合 Python3 主程式使用. 也能建立整合網際前後端的 Python3 程式, 同時納入網誌與網際投影片系統. 這些工具在從事各種機械設計產品開發時, 所產生的資料版本, 自 2017 Spring 起, 已經同時採用 Github 與 Fossil SCM 進行管理, 2017 Fall 將會更側重 Fossil SCM 的運用, 除了讓同一倉儲, 在兩套遠端不同分散式資料版次管理系統保持同步外, 近端也會擁有一套備份, 可以簡單地利用 fossil ui 進行檢視, 或者結合 Stunnel, 讓近端的倉儲管理與遠端模式相同. 至於用來執行 Fossil SCM 伺服器的主機, 目前使用的是接近淘汰的機種, 這學期將要測試一台電腦能夠承受幾名學員同步提交推送資料, 最終, 學員必須要學會如何將 Pelican Blog, Reveal.js 投影片版本資料, 同時放到 Github 與區域網路上的 Fossil SCM 伺服器. CAD 的工具目前採用單機上輕量的 Solvespace 與雲端上的 OnShape, Solvespace 是一套採 C++11 編寫的 GPL 授權參數式電腦輔助設計套件, 永續使用較無問題, OnShape 在協同產品上的設計功能, 有其獨特性, 因此將繼續採用. V-rep 也提供 GPL 使用授權, 2017 Fall 起將要自行編譯使用. 2017 Fall 區網主機 主要伺服器可以從 http://mde.tw 進入. 2017 Fall 區網課程網頁: https://mde1a1.kmol.info/2017fall Github 與 Fossil SCM 同步倉儲: https://mde1a1.kmol.info/pymcadp","tags":"Course","url":"https://kmolab.github.io/blog/2017fall-semester-starts.html"},{"title":"Sunset of OpenShift Online 2 Platform","text":"OpenShift 在 2017.08.25 於 https://blog.openshift.com/migrate-to-v3-v2-eol/ 宣布, 先前所推出的 Online 2 Platform, 將要在 2017.09.30 走入歷史. 為了因應這個變化, 許多過去所建立的網站資料將要轉到 Github 與 Fossil SCM. https://wordpress-2015course.rhcloud.com/ 有用的連結 Free Math Books http://www.openculture.com/free-math-textbooks Kinematic Synthesis of Linkage http://ebooks.library.cornell.edu/k/kmoddl/toc_hartenberg1.html the kinematic models for design http://ebooks.library.cornell.edu/k/kmoddl/about.html CSS 與 Div 取代 Table https://sofree.cc/css-table/ http://www.flycan.com/article/css/css-float-442.html 以 http://2016spring-cadlab.rhcloud.com 取出舊版程式? cadlab At mde 備份: https://wordpress-2015course.rhcloud.com/?p=4579 Product Design Modeling using CAD/CAE How to be a star engineer http://ieeexplore.ieee.org/document/795608/","tags":"Course","url":"https://kmolab.github.io/blog/sunset-of-openshift-online2.html"},{"title":"Calculator in PyQt5 and Eric6","text":"根據 http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html 的說明, 利用 Eric6 與 PyQt5 開發簡單的計算器視窗程式. Flask 與 Javascript 建立簡單計算器: Buttons are grouped in categories according to their behavior. For example, all the digit buttons (labeled 0 to 9) append a digit to the current operand. For these, we connect multiple buttons to the same slot (e.g., digitClicked()). The categories are digits, unary operators (Sqrt, x², 1/x), additive operators (+, -), and multiplicative operators (×, ÷). The other buttons have their own slots. The private createButton() function is used as part of the widget construction. abortOperation() is called whenever a division by zero occurs or when a square root operation is applied to a negative number. calculate() applies a binary operator (+, -, ×, or ÷). These variables, together with the contents of the calculator display (a QLineEdit), encode the state of the calculator: sumInMemory contains the value stored in the calculator's memory (using MS, M+, or MC). sumSoFar stores the value accumulated so far. When the user clicks =, sumSoFar is recomputed and shown on the display. Clear All resets sumSoFar to zero. factorSoFar stores a temporary value when doing multiplications and divisions. pendingAdditiveOperator stores the last additive operator clicked by the user. pendingMultiplicativeOperator stores the last multiplicative operator clicked by the user. waitingForOperand is true when the calculator is expecting the user to start typing an operand. Additive and multiplicative operators are treated differently because they have different precedences. For example, 1 + 2 ÷ 3 is interpreted as 1 + (2 ÷ 3) because ÷ has higher precedence than +. The table below shows the evolution of the calculator state as the user enters a mathematical expression. Waiting for Operand? 等待運算處理對象? Add. Op. - 加或減運算元,若隨後無乘與除等優先運算元, 且按下等於或接著按加或減運算元, 則前段隨即完成運算後列在 Sum so Far 欄位. Mul. Op. - 乘或除運算元, 屬於優先運算元, 因此若輸入已經滿足運算數接優先運算元, 再接其他運算元則 將局部優先運算所需的前方運算數, 放入 Factor so Far, 而前面未處理的加或減運算數, 則放入 Sum so Far. User Input Display Sum so Far Add. Op. Factor so Far Mult. Op. Waiting for Operand? 0 0 true 1 1 0 false 1 + 1 1 + true 1 + 2 2 1 + false 1 + 2 ÷ 2 1 + 2 ÷ true 1 + 2 ÷ 3 3 1 + 2 ÷ false 1 + 2 ÷ 3 - 1.66667 1.66667 - true 1 + 2 ÷ 3 - 4 4 1.66667 - false 1 + 2 ÷ 3 - 4 = -2.33333 0 true Unary operators, such as Sqrt, require no special handling; they can be applied immediately since the operand is already known when the operator button is clicked. Finally, we declare the variables associated with the display and the buttons used to display numerals. In the constructor, we initialize the calculator's state. The pendingAdditiveOperator and pendingMultiplicativeOperator variables don't need to be initialized explicitly, because the QString constructor initializes them to empty strings. We create the QLineEdit representing the calculator's display and set up some of its properties. In particular, we set it to be read-only. We also enlarge display's font by 8 points. For each button, we call the private createButton() function with the proper text label and a slot to connect to the button. The layout is handled by a single QGridLayout. The QLayout::setSizeConstraint() call ensures that the Calculator widget is always shown as its optimal size (its size hint), preventing the user from resizing the calculator. The size hint is determined by the size and size policy of the child widgets. Most child widgets occupy only one cell in the grid layout. For these, we only need to pass a row and a column to QGridLayout::addWidget(). The display, backspaceButton, clearButton, and clearAllButton widgets occupy more than one column; for these we must also pass a row span and a column span. Pressing one of the calculator's digit buttons will emit the button's clicked() signal, which will trigger the digitClicked() slot. First, we find out which button sent the signal using QObject::sender(). This function returns the sender as a QObject pointer. Since we know that the sender is a Button object, we can safely cast the QObject. We could have used a C-style cast or a C++ static_cast<>(), but as a defensive programming technique we use a qobject_cast(). The advantage is that if the object has the wrong type, a null pointer is returned. Crashes due to null pointers are much easier to diagnose than crashes due to unsafe casts. Once we have the button, we extract the operator using QToolButton::text(). The slot needs to consider two situations in particular. If display contains \"0\" and the user clicks the 0 button, it would be silly to show \"00\". And if the calculator is in a state where it is waiting for a new operand, the new digit is the first digit of that new operand; in that case, any result of a previous calculation must be cleared first. At the end, we append the new digit to the value in the display. The unaryOperatorClicked() slot is called whenever one of the unary operator buttons is clicked. Again a pointer to the clicked button is retrieved using QObject::sender(). The operator is extracted from the button's text and stored in clickedOperator. The operand is obtained from display. Then we perform the operation. If Sqrt is applied to a negative number or 1/x to zero, we call abortOperation(). If everything goes well, we display the result of the operation in the line edit and we set waitingForOperand to true. This ensures that if the user types a new digit, the digit will be considered as a new operand, instead of being appended to the current value. The additiveOperatorClicked() slot is called when the user clicks the + or - button. Before we can actually do something about the clicked operator, we must handle any pending operations. We start with the multiplicative operators, since these have higher precedence than additive operators: If × or ÷ has been clicked earlier, without clicking = afterward, the current value in the display is the right operand of the × or ÷ operator and we can finally perform the operation and update the display. If + or - has been clicked earlier, sumSoFar is the left operand and the current value in the display is the right operand of the operator. If there is no pending additive operator, sumSoFar is simply set to be the text in the display. Finally, we can take care of the operator that was just clicked. Since we don't have the right-hand operand yet, we store the clicked operator in the pendingAdditiveOperator variable. We will apply the operation later, when we have a right operand, with sumSoFar as the left operand. The multiplicativeOperatorClicked() slot is similar to additiveOperatorClicked(). We don't need to worry about pending additive operators here, because multiplicative operators have precedence over additive operators. Like in additiveOperatorClicked(), we start by handling any pending multiplicative and additive operators. Then we display sumSoFar and reset the variable to zero. Resetting the variable to zero is necessary to avoid counting the value twice. The pointClicked() slot adds a decimal point to the content in display. The changeSignClicked() slot changes the sign of the value in display. If the current value is positive, we prepend a minus sign; if the current value is negative, we remove the first character from the value (the minus sign). The backspaceClicked() removes the rightmost character in the display. If we get an empty string, we show \"0\" and set waitingForOperand to true. The clear() slot resets the current operand to zero. It is equivalent to clicking Backspace enough times to erase the entire operand. The clearAll() slot resets the calculator to its initial state. The clearMemory() slot erases the sum kept in memory, readMemory() displays the sum as an operand, setMemory() replace the sum in memory with the current sum, and addToMemory() adds the current value to the value in memory. For setMemory() and addToMemory(), we start by calling equalClicked() to update sumSoFar and the value in the display. The private createButton() function is called from the constructor to create calculator buttons. The private abortOperation() function is called whenever a calculation fails. It resets the calculator state and displays \"####\". The private calculate() function performs a binary operation. The right operand is given by rightOperand. For additive operators, the left operand is sumSoFar; for multiplicative operators, the left operand is factorSoFar. The function return false if a division by zero occurs.","tags":"Course","url":"https://kmolab.github.io/blog/calculator-pyqt5-eric6.html"},{"title":"Create a Multi-repository Fossil SCM Server","text":"In order to create a multi-repository Fossil SCM server on Ubuntu 16.04 environment, three steps are needed. Step 1: install Stunnel and Fossil SCM sudo apt update sudo apt install stunnel4 -y sudo apt install fossil Edit /etc/environment file and add the following setup to allow only the https connections: HTTPS=on Edit /etc/default/stunnel4 file and modified the ENABLED value from 0 to 1 to get stunnel service running when the computer startup: ENABLED=1 Step 2: Stunnel setup Change directory to /etc/stunnel/ and use the following command to generate localhost.key and localhost.crt files. sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt edit stunnel.conf configuration file under /etc/stunnel/ as follows: [https] accept = your_IPv4_ip:443 accept = :::443 cert = /etc/stunnel/localhost.crt key = /etc/stunnel/localhost.key exec = /usr/bin/fossil execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound default which means the IPv4 and IPv6 requests are both accepted under port 443. And /home/user/repository/ is used to store the Fossil SCM repo files. The default repo file is /home/user/repository/default.fossil The setting of \"--notfound default\" means if the repository file is not specified, connection URL is default which is a relative directory associated with the server main URL. Step 3: create Fossil SCM repositories Change directory to /home/user/repository and use \"fossil init default.fossil\" command to create the default repository. If more repository is needed, also use \"fossil init other.fossil\" to create other.fossil repository under /home/user/repository. After the setup use \"/etc/init.d/stunnel4 restart\" command to restart the Stunnel service. Use https://site-url:443/ to connect to default.fossil and use https://site-url:443/other to connect to other.fossil.","tags":"Course","url":"https://kmolab.github.io/blog/create-a-multi-repository-fossil-scm-server.html"},{"title":"2015 Fall CADP W16","text":"根據 Nutcracker 機構 的尺寸規格, 請設法算出 Piston 零件的有效運動範圍. 計算 Piston 不發生干涉的有效行程, 可採如下方法: 實際利用 Onshape 中的組立, 移動 piston 零件, 靠目測概略決定 piston 的有效行程. (目測法, 只能得到大概的行程範圍) 利用 Solvespace 繪製 2D 約束圖, 然後利用約束點在線或圓上的方式, 以圖解法解出有效行程, 如下圖一, 圖二與圖三所示. (圖解法, 利用 Solvespace 既有的約束條件設定完成計算) 利用 Jupyter 與 Python3 的 sympy 模組, 先進行符號式推導, 然後再利用數值分析解出 piston 的有效行程, 機構各點標示如下圖四所示, 計算出 的 theta 轉角為 105.7, 如下圖五所示. (以自行編寫的 sympy 程式解題, 透過 Jupyterhub 可以有效進行協同設計運算) 除了上述的目測, 圖解與符號式結合數值分析法之外, 也可以採用 基因演算法解題 , 計算出的 theta 轉角為 105.7, 如下圖六所示. (利用演化法解題, 可以在單機運算, 也可以在 Jupyterhub 平台 上進行運算) 圖一: 利用 Solvespace 中的繪圖約束條件找出右邊的極限點距離 Onshape Piston 組立原點 0.5 圖二: 利用 Solvespace 中的繪圖約束條件找出左邊的極限點距離 Onshape Piston 組立原點 2.23 圖三: 當 piston 位於左邊極限點時, AB 轉角為 105.37 度 圖四: Jupyter 計算分析時機構各點標示圖 圖五: 利用 Jupyter 符號式結合數值分析法所得結果 圖六: 利用基因演算解題, 所得到的結果, 當 piston 位於左邊極限點時, AB 轉角為 105.7 度 若採用 deap 與 numpy 解題 (AB 轉角極限為 105.71 度): # 這裡採用 numpy 與 deap 模組解題, 使用 Genetic Algorithm 模式 # 解的問題為 Nutcracker 左邊 connect 轉角極限 import random import array from deap import base from deap import creator from deap import tools import numpy # for evalIntersect 函式中的 sqrt, sin, cos, pi from math import * # 1/4 最小化題目 type of problem creator.create(\"FitnessMin\", base.Fitness, weights=(-1.0,)) creator.create(\"Individual\", array.array, typecode='d', \\ fitness=creator.FitnessMin) # 2/4 initilization # 兩個變數題目 NDIM = 2 toolbox = base.Toolbox() toolbox.register(\"attr_float\", random.uniform, 0, 5) toolbox.register(\"individual\", tools.initRepeat, creator.Individual, toolbox.attr_float, NDIM) toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual) # 3/4 選擇 operator step3/4 toolbox.register(\"select\", tools.selRandom, k=3) # 也可以採用下列設定 #toolbox.register(\"mate\", tools.cxTwoPoint) #toolbox.register(\"mutate\", tools.mutGaussian, mu=0, sigma=1, indpb=0.1) #toolbox.register(\"select\", tools.selTournament, tournsize=3, k=3) def evalIntersect(individual): t = individual[0] deg = pi/180 theta = individual[1]*deg xtarget = 0.75/2 ytarget = 0.5 x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 \\ + 529)/92 + 3*cos(theta)/2 y = (-3*t/2 + 123/92)*sin(theta) # 適應值 fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8) # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰 if t > 1: fitness_value += 1000 if t < 0: fitness_value += 1000 # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰 if theta > 2*pi: fitness_value += 1000 if theta < 0: fitness_value += 1000 return fitness_value, toolbox.register(\"evaluate\", evalIntersect) # 以上到 evaluate 為止, 為定義 operators # 4/4 以下則為 Algorithms def main(): # Differential evolution parameters CR = 0.25 F = 1 MU = 300 NGEN = 200 pop = toolbox.population(n=MU); hof = tools.HallOfFame(1) stats = tools.Statistics(lambda ind: ind.fitness.values) stats.register(\"avg\", numpy.mean) stats.register(\"std\", numpy.std) stats.register(\"min\", numpy.min) stats.register(\"max\", numpy.max) # Evaluate the individuals fitnesses = toolbox.map(toolbox.evaluate, pop) for ind, fit in zip(pop, fitnesses): ind.fitness.values = fit for g in range(1, NGEN): for k, agent in enumerate(pop): a,b,c = toolbox.select(pop) y = toolbox.clone(agent) index = random.randrange(NDIM) for i, value in enumerate(agent): if i == index or random.random() < CR: y[i] = a[i] + F*(b[i]-c[i]) y.fitness.values = toolbox.evaluate(y) if y.fitness > agent.fitness: pop[k] = y hof.update(pop) print(\"Best individual is \", hof[0], hof[0].fitness.values[0]) if __name__ == \"__main__\": main() 上述課程資料與 Wordpress 網頁 上的資料內容相同, Ｗordpress 網站屬於動態的網誌, 而 http://chiamingyen.github.io/kmolab/ 則是靜態網誌系統, 採用靜態網誌的優點如下: 比較安全 比較不會過時 部署成本比較低 可在各種平台上使用 各階段改版資料均有紀錄 以下為參考用的 GA 解 Nutcracker 題目的程式碼: #encoding=utf8 # genetic.py # import random import operator # for Intersect from math import * MAXIMIZE, MINIMIZE = 11, 22 class Individual: chromosome = None score = None # Here the size of var depends on var_number var = [] var_number = 2 for i in range(var_number): var.append(0) alleles = (0,1) # 以下為參數可負數時的編碼考量 #前10為小數,後10為整數,第21則為正負號 #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號. #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號 #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號 # -1023 ~ 1023 #length = 21*var_number,若接受負數參數,則必須同步修改 20->21 length = 20*var_number seperator = '' optimization = MINIMIZE def __init__(self, chromosome=None): self.chromosome = chromosome or self._makechromosome() self.score = None # set during evaluation def _getvar(self,chromosome=None): x = 0 for i in range(0,self.var_number): for j in range(i*20,i*20+10): x +=self.chromosome[j]<<(j-(i*20)) if (x>999): x=999 x/=1000. for j in range(i*20+10,i*20+20): x +=self.chromosome[j]<<(j-(i*20+10)) self.var[i] = x return self.var ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings #for design variable -1023 ~1023 for i in range(self.var_number): x = 0 for j in range(i*21,i*21+10): x +=self.chromosome[j]<<(j-(i*21)) if (x>999): x=999 x/=1000. for j in range(i*(21)+10,i*(21)+20): x +=self.chromosome[j]<<(j-(i*21+10)) if(self.chromosome[i*(21)+20] == 1): self.var[i] = -x else: self.var[i] = x x = 0 return self.var ''' def _makechromosome(self): \"makes a chromosome from randomly selected alleles.\" return [random.choice(self.alleles) for gene in range(self.length)] def evaluate(self, optimum=None): \"this method MUST be overridden to evaluate individual fitness score.\" pass def crossover(self, other): \"override this method to use your preferred crossover method.\" return self._twopoint(other) def mutate(self, gene): \"override this method to use your preferred mutation method.\" self._pick(gene) # sample mutation method def _pick(self, gene): \"chooses a random allele to replace this gene's allele.\" self.chromosome[gene] = random.choice(self.alleles) # sample crossover method def _twopoint(self, other): \"creates offspring via two-point crossover between mates.\" left, right = self._pickpivots() def mate(p0, p1): chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容 chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因 #child = p1.__class__(chromosome) 這是原先的程式,但是應該子代要指向 p0 的內容才對 child = p0.__class__(chromosome) child._repair(p0, p1) return child return mate(self, other), mate(other, self) # some crossover helpers ... def _repair(self, parent1, parent2): \"override this method, if necessary, to fix duplicated genes.\" pass def _pickpivots(self): left = random.randrange(1, self.length-2) right = random.randrange(left, self.length-1) return left, right # # other methods # def __repr__(self): \"returns string representation of self\" ''' return '<%s chromosome=\"%s\" score=%s var=%s>' % \\ (self.__class__.__name__, self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome)) ''' return '<%s score=%s var=%s>' % \\ (self.__class__.__name__,self.score,self._getvar(self.chromosome)) # since the __cmp__ special function is gone use the __lt__ in stead # use the expression (a > b) - (a < b) as the equivalent for cmp(a, b) #def __cmp__(self, other): # these are for python 3 def __cmp__(self, other): if self.optimization == MINIMIZE: #return cmp(self.score, other.score) return (self.score > other.score) - (self.score < other.score) else: # MAXIMIZE #return cmp(other.score, self.score) return (other.score > self.score) - (other.score < self.score) def __lt__(self, other): return self.__cmp__(other) < 0 def __le__(self, other): return self.__cmp__(other) <= 0 def __gt__(self, other): return self.__cmp__(other) > 0 def __ge__(self, other): return self.__cmp__(other) >= 0 def copy(self): twin = self.__class__(self.chromosome[:]) twin.score = self.score return twin class Environment(object): x = [0] y = [0] def __init__(self, kind, population=None, size=100, maxgenerations=100, crossover_rate=0.90, mutation_rate=0.07, optimum=None): self.kind = kind self.size = size self.optimum = optimum self.population = population or self._makepopulation() for individual in self.population: individual.evaluate(self.optimum) self.crossover_rate = crossover_rate self.mutation_rate = mutation_rate self.maxgenerations = maxgenerations self.generation = 0 self.report() def _makepopulation(self): return [self.kind() for individual in range(self.size)] def run(self): while not self._goal(): self.step() def _goal(self): return self.generation > self.maxgenerations or \\ self.best.score == self.optimum def step(self): # this sort is not working with python 3.0, modification is needed self.population.sort() self._crossover() self.generation += 1 self.report() self.x.append(self.generation) # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值 if self.best.score <=5: self.y.append(self.best.score) else: self.y.append(5) def _crossover(self): next_population = [self.best.copy()] while len(next_population) < self.size: mate1 = self._select() if random.random() < self.crossover_rate: mate2 = self._select() offspring = mate1.crossover(mate2) else: offspring = [mate1.copy()] for individual in offspring: self._mutate(individual) individual.evaluate(self.optimum) next_population.append(individual) self.population = next_population[:self.size] def _select(self): \"override this to use your preferred selection method\" return self._tournament() def _mutate(self, individual): for gene in range(individual.length): if random.random() < self.mutation_rate: individual.mutate(gene) # # sample selection method # def _tournament(self, size=8, choosebest=0.90): competitors = [random.choice(self.population) for i in range(size)] competitors.sort() if random.random() < choosebest: return competitors[0] else: return random.choice(competitors[1:]) def best(): doc = \"individual with best fitness score in population.\" def fget(self): return self.population[0] return locals() best = property(**best()) def report(self): print (\"=\"*70) print (\"generation: \", self.generation) print (\"best: \", self.best) # 以上為 genetic.py 目前將兩者結合在一起 #encoding=utf8 # volume.py - useage example # # the fittest individual will have a chromosome consisting of 40 '1's # # #import genetic #此一加總函式在 volume 最大化中,並未使用 def sum(seq): def add(x,y): return x+y return reduce(add, seq, 0) class Volume(Individual): optimization = MAXIMIZE def evaluate(self, optimum=None): SURFACE = 80 # self.score is the fitness value self._getvar(self.chromosome) x = self.var[0] y = self.var[1] z=(SURFACE - x*y)/(2.*(x+y)) fitness_value = x*y*z self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip class Intersect(Individual): optimization = MINIMIZE def evaluate(self, optimum=None): # self.score is the fitness value self._getvar(self.chromosome) t = self.var[0] deg = pi/180 theta = self.var[1]*deg xtarget = 0.75/2 ytarget = 0.5 x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2 y = (-3*t/2 + 123/92)*sin(theta) # 適應值 fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8) # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰 if t > 1: fitness_value += 1000 if t < 0: fitness_value += 1000 # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰 if theta > 2*pi: fitness_value += 1000 if theta < 0: fitness_value += 1000 self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip if __name__ == \"__main__\": #env = Environment(Volume, size=500, maxgenerations=100) env = Environment(Intersect, size=500, maxgenerations=100) env.run()","tags":"Course","url":"https://kmolab.github.io/blog/2015-cadp-w16.html"},{"title":"計算機程式與電腦輔助設計實習","text":"以下為 Brython 網際程式環境. window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } 投影片: from browser import document, html container1 = document['container1'] adata = open(\"./../data/1a_list.txt\").read() alist = adata.splitlines() n = 0 for stud_num in alist: mlink = html.A(stud_num, href=\"http://s\"+str(stud_num)+\".github.io/2017springwcm_hw\") mlink += \" | \" n = n +1 if n%8 == 0: mlink += html.BR() container1 <= mlink template slide 測試 LaTex 方程式寫法與轉換: $$H\\frac{d&#94;{2}\\theta (t)}{dt&#94;{2}} = gSin\\theta(t)+a_2(t)H-a_1(t)Cos\\theta(t)$$ 經過轉換成為: $$H\\frac{d&#94;{2}\\theta (t)}{dt&#94;{2}} = gSin\\theta(t)+a_2(t)H-a_1(t)Cos\\theta(t)$$ $$\\[L(\\mu,\\sigma;X)=\\sum_i\\left[-\\frac 1 2 \\ln(2\\pi)-\\ln(\\sigma)-\\frac{1}{2\\sigma&#94;2}(X_i-\\mu)&#94;2\\right]\\]$$ 經過轉換成為: $$[L(\\mu,\\sigma;X)=\\sum_i\\left[-\\frac 1 2 \\ln(2\\pi)-\\ln(\\sigma)-\\frac{1}{2\\sigma&#94;2}(X_i-\\mu)&#94;2\\right]]$$","tags":"Course","url":"https://kmolab.github.io/blog/2017fall-cp-cadp.html"},{"title":"網際內容管理","text":"網際內容管理課程在教導學生, 利用電腦與網路軟硬體配置, 完成各項與機械設計內容管理有關的任務. 所謂網際指的是 Web-Based, 也就是 World-Wide-Web Based 的簡稱, 中文也可以翻為\"植基於全球資訊網\" 或 \"以全球資訊網為基礎\", 其內涵是希望讓使用者在網際網路 (Internet) 的基礎上, 利用 Web Browser (瀏覽器) 操作各種與機械設計內容管理有關的任務. Ubuntu 操作系統 根據 https://www.ubuntu.com/info/release-end-of-life 的生命週期年限, 選擇 LTS Server 版本安裝, 安裝過程需要安裝 OpenSSL 模組, 以及 ubuntu-desktop, Windows 客戶端則透過 xming 與 http://www.putty.org/ 進行安全的遠端登入. IPv4 與 IPv6 網路設定 一般來說, 只有必須擔負特定 WWW Server、DNS Server 與 Proxy Server 的主機需要同時支援 IPv4 與 IPv6 網路協定外, 其餘客戶端都可以只透過 IPv6 網路協定上網. WWW Server 使用 Nginx, DNS Serve 使用 Bind, 而 Proxy Server 則使用 Squid. Nginx Nginx WWW 伺服器通常用來伺服靜態文件或者作為其他近端伺服資料傳送的代理主機 (例如, uwsgi 網際服務). Ethercalc Ethercalc 允許多人利用瀏覽器同時維護一份線上試算表, 可以用於協同資料永久存檔前的轉介站. Fossil SCM Fossil SCM 是一套小而美的分散式資料管理系統 Squid Proxy Server 在 IPv4 轉換到 IPv6 的過程中, 雙網路協定支援的代理主機扮演非常重要的角色, 例如, 從純 IPv4 瀏覽器連線到純 IPv6 WWW 伺服器, 就需要透過雙網路協定的代理主機轉介資料, 其次 putty ssh 遠端登入或 sftp 安全資料傳送, 也都需要雙網路支援的代理主機居中轉換不同協定資料. X-windows Putty Leo Editor Filezilla 與 SFTP Uwsgi 與 CMSimfly","tags":"Course","url":"https://kmolab.github.io/blog/wcm-course-1.html"},{"title":"協同產品設計實習","text":"協同產品設計課程在教導學生, 以同步或非同步協同方式, 利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.","tags":"Course","url":"https://kmolab.github.io/blog/cd-course-1.html"},{"title":"電腦輔助設計實習","text":"電腦輔助設計課程在教導學生利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務. CAD Book: http://mde.tw/2016fallcadp/data/CAD_book.pdf Space Modeling with SolidWorks and NX http://beyondplm.com/2015/03/18/autodesk-and-onshape-disagree-about-cloud-technology-and-focus/ https://www.solidsmack.com/cad/onshape-comes-out-swinging-changes-mcad-pricing-forever/ https://newscrewdriver.com/category/3d-printing/3d-printing-software/fusion-360-vs-onshape/ eBook: State of Product Development / PLM 2016 http://image.engineering.com/239575/articles/Nov%202016/Autodesk%20Q615/Autodesk_pdf1R.pdf CADO: https://github.com/BGCECSE2015/CADO Electronics made easy: http://fritzing.org/home/ SFEPy: https://github.com/sfepy/sfepy http://nbviewer.jupyter.org/github/sukhbinder/sfepy-simple_tutorial/blob/master/Getting_Started_With_SFEPY_using_a_simpleplate_example.ipynb","tags":"Course","url":"https://kmolab.github.io/blog/cadp-course-1.html"},{"title":"計算機程式","text":"計算機程式課程在教導學生利用電腦完成各項與機械設計流程有關的任務. 為什麼非學不可? https://cacm.acm.org/blogs/blog-cacm/166115-why-scientists-and-engineers-must-learn-programming/fulltext 首先, 看看機械設計流程會牽涉哪些任務, 所謂機械設計, 就是歷經詳細思慮考量, 完成互動元件間之精巧配置, 使其展現特定功能之具體規劃表達. 換言之, 機械設計是一種具體規劃的表達 (presentation), 其內容是經過一系列詳細的思慮與考量所得到的結果, 而此項結果通常有具體的功能, 並且包含許多互動 (interaction) 元件之間的彈性與精巧配置 (flexible and sophisticated configuration). 我們將上述與機械設計有關的關鍵字引列如下: 機械設計是一種表達, 此種表達可以利用文字、口語、2D 靜態圖像、3D 或影音動態圖像、理論分析或實體呈現. 機械設計的過程所需要的各種思慮與考量牽涉許多定性與定量的分析, 包含許多工程原理原則與實務經驗, 這些分析除了必須利用數學建立模型, 透過演算預先模擬外, 還需要使用有效率可協同的方式紀錄過程中所產生的各種資料. 機械設計產品中所包含的各種互動元件, 包括硬體元件、流體元件、軟體元件與管理元件等. 機械設計過程中, 為了在實體化之前能預先針對各種互動元件間的組成與配置進行最佳化, 因此需要使用各種逼真的模擬方法加以呈現. 如何進行文字、2D&3D表達 有沒有一種方法可以讓多名使用者協同管理一份文件, 其中包含各種互動式圖文與影音資料, 各使用者在編修內容過程可以有效對資料進行保全, 可以有效分散備份, 可以紀錄各編修者所增刪的內容, 可以透過有效率的方法散佈此份文件的內容? 使用工具的評量方法 機械設計工程師為了有效完成具體規劃內容的表達, 過程中必須使用各種類型的工具, 其中包括: 文字資料構建、管理與呈現的工具 (text) 2 口語資料構建、管理與呈現的工具 (oral) 2D 靜態圖像資料構建、管理與呈現的工具 (2d) 3D 或影音動態圖像資料構建、管理與呈現的工具 (3d) 理論分析資料構建、管理與呈現的工具 (analytical) 實體構建、管理與呈現的工具 (physical) 工具取得、維護使用成本與其他工具整合效能成本等 工具取得成本 (now and how) 維護更新與永續使用成本 (update and sustainable) 工具掌握度與整合效能成本 (integration) 一定要學 C C 是為建立 Unix 操作系統而生的程式語言, 也是近代許多高階程式語言建構的基礎, 例如, 最早的 C 程式編譯器雖然採用組合語言編寫, 但是隨後的 C 程式編譯器則可以採用舊版的 C 來編譯, 而 Python 解譯器在 1980 年代晚期出現時, 就是以 C 程式編寫, 之後雖然有採用 Java 編寫的 Jython (2001), 以 C# 編寫的 IronPython (2006), 以 RPython 編寫的 PyPy (2007), 以 Javascript 編寫的 Brython (2012), 但是 CPython 仍然是最通用的版本. 儘管 C 程式語言對於工程師而言非常重要, 但是 C 或更進階的 C++ 程式語言的學習並不容易, 並不只是因為 C/C++ 擁有指標, 能夠控制電腦的底層記憶體, 而是因為 C/C++ 程式語言所涵蓋的應用非常廣. 但是無論如何, 工程師一定要學會基本的 C 程式語言, 倒是毋庸置疑. https://www.asme.org/career-education/articles/teachers-academics/c-as-part-of-a-mechanical-engineering-curriculum C 的指標與陣列導引 http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html CP to CADP https://github.com/2015fallhw/cptocadp 如何完成下列工作? 1) 從一本英文書的文字檔中, 算出總字數, 並按照英文字母排列, 列出書中所使用的單字, 並查出各單字的中文解釋. 2) 從網站中擷取當天台幣與美金及英鎊的匯率, 並根據某一列有台幣、美金與英鎊的檔案進行各幣值的總結算. 3) 每組有六人, 某一任務需要完成六項工作, 每人負責一項, 但各工作間必須互相配合, 任務進行中需要完整呈現各組員每一階段所完成的內容細節, 請問該如何完成. https://github.com/dustinrohde/python-rpn 4) 如何將材料特性 2D 圖表轉為電腦可以套用的文字檔或資料庫檔案? 漸開線正齒輪齒面寬運算 - 選擇正齒輪對所要傳遞的功率大小, 選擇所要使用的正齒輪齒數、模數與壓力角, 選擇齒輪的材質, 選擇小齒輪的齒數, 選擇安全係數, 從上述資料中算出齒輪齒面寬, 以便能在安全的範圍中, 不致產生過大噪音條件下完成所需功率的傳遞. 漸開線正齒輪 功率 齒數、模數與壓力角 齒輪的材質與強度 安全係數 振動與噪音 齒輪的鍵銷設計 齒輪的軸尺寸、強度與耐用度設計 軸承的選用設計 齒輪箱的設計 齒輪的潤滑與散熱設計 其他相關的設計分析、製造規劃與後勤維修等議題 5) 文字檔與數位檔案的差別與運用, 各種 2D 與 3D 零組件檔格式的讀取與轉換 https://en.wikipedia.org/wiki/AutoCAD_DXF http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf ASCII DXF File Format Binary DXF File Format https://en.wikipedia.org/wiki/STL_(file_format) http://www.fabbers.com/tech/STL_Format ASCII STL File Format Binary STL File Format IGES Version 5.3: http://paulbourke.net/dataformats/iges/IGES.pdf IGES Version 6: https://filemonger.com/specs/igs/devdept.com/version6.pdf https://en.wikipedia.org/wiki/IGES DXF, IGES and STEP: http://homepages.cae.wisc.edu/~me232/info/dxf_iges_step.pdf Python3 學習 Official Tutorial: https://docs.python.org/3/tutorial/ 10 min Python Tutorial help(), dir(), print(), range() , built-in types , 看影片自學: https://www.youtube.com/watch?v=D48iCw3WWpI http://www.spronck.net/pythonbook https://github.com/coodict/python3-in-one-pic/blob/master/notebooks/py3-in-one-pic.ipynb 資料分析: https://lectures.quantecon.org/py/ Python 很慢? https://www.youtube.com/watch?v=8hHOxfXcWsg https://www.youtube.com/watch?v=a8LsdodGoWQ PyQT https://kuanyui.github.io/2014/09/13/learn-python-via-pyqt/ 網際程式繪圖","tags":"Course","url":"https://kmolab.github.io/blog/cp-course-1.html"},{"title":"大學生為何不來上課?","text":"大學生不願進教室上課的原因很多, 學費太低? 學不到東西? 完全跟不上進度? 老師太混? 上與不上都差不多? 實在爬不起來? 沒有人叫我起床? 大學生為何不來上課? 首先就大學生上課, 有幾項基本組成: 時段、課程內容、教師與學生等. 因此, 大學生之所以不想來上課, 可能是因為時段太早, 學生爬不起來而翹課; 也可能是課程內容不能讓學生認同, 內容太過簡單, 內容太過困難等原因, 讓學生視上課為畏途, 一有機會就不願意到課; 另外也可能是老師的教學方式得不到學生認同, 因此不願意上課; 最後則是學生本身的心態, 完全不知道為何要上這門課, 或者如何克服課程中所碰到的困難等問題, 導致學生一逮到機會就斷然翹課. 時段太早爬不起床 因時段太早而翹課, 大家都知道這絕對是藉口, 也就是說, 這不是學生翹課的主要原因, 而是因為其他主要原因的影響下, 讓學生拿時段太早當作翹課的藉口. 內容太淺, 內容太深 接著來談談因為課程內容無法得到學生認同而翹課的因素, 一般而說, 過去循序漸進, 以靜態課本內容為主的教學, 較能得到學生的認同, 因為所有會涵蓋的教學內容, 都已經鉅細靡遺列在教科書中, 因此針對此類型的課程, 學生到課的主要動機在於能以較高效益理解教科書內容, 但是針對主題已定但內容會隨學習成效而加以取捨的課程, 若學生的學習動機不夠強, 就會覺得無法掌握課程教學的主軸而失焦, 導致認為課程內容太過無聊或太過複雜而中途放棄, 造成學生不願意到課. 打工賺錢太忙, 沒時間上課 有部分學生因為經濟問題, 而必須邊上課邊工作賺錢, 大多數情況下, 由於大學尚未畢業, 無法根據專業找到報酬較高的工作, 因此大多在以時數累積賺錢的第一線服務業工作為主. 當學生日以繼夜打工賺取學費或生活費的同時, 經常以此為藉口而弄得沒時間上課時, 最後在大學註冊的最終目的, 就只剩下拿學位一件事, 一般情況下, 非但無法專心在自己所學的專業上日日進步, 反而在自己的學業成績單上留下許多不良紀錄, 嚴重影響畢業後的發展. 針對此類學生, 我們的建議是, 可以向學校的科系辦公室或職涯規劃單位求助, 尋求與本身專業有關的打工機會, 並且試著利用學校各專業科目所學內容, 在專業公司協助解決實務問題, 假若, 我們是說假若, 事實證明學校所傳授的知識, 完全無法在打工的過程中解決任何實務問題, 那麼表示念這書甚至拿這學位, 根本無助於往後的發展, 這時這些學生就可大步離開學校, 全力投入自己設想更有意義的工作上, 最後也就不會再有沒時間上課的問題了. 不知老師在教什麼? 老師的教學方式確實會影響學生的學習意願, 但是當學生從頭到尾都沒能到課的情形下, 還大聲疾呼說不知老師在教什麼? 就有些說不過去. 學這些東西沒有用 假如學生與家長真的認為在學校所學, 甚至拿學位無助往後發展, 建議應該及早離開學校, 從事更有意義的事, 尋求更好的發展機會. 其他思考 學生為何而讀, 為何而學, 為何而問? 老師如何弄懂學生處境 設法與學生共同學習 鼓勵自學、執行與想像 設法與表現好的學生一起協助跟不上進度的同學 https://www.ptt.cc/bbs/Gossiping/M.1392611157.A.D09.html https://kknews.cc/education/bxbg34n.html https://www.cheers.com.tw/blog/blogTopic.action?id=425&nid=5513 https://www.thenewslens.com/article/664 https://shinphotos.com/2014-03-08-297/ http://www.businessweekly.com.tw/article.aspx?id=1124&type=Blog 大學生應有的學習態度 面對全球協同的知識經濟環境, 身為一個大學生, 至少必須: 不要怕困難 (基本信念) – 因為幾乎處於網路時代的所有人, 在享受高度科技發展所帶來的便利性之後, 都必須隨時獨力或合力克服各種困難. 不要失去熱忱 (強化動力) – 許多人在生活周遭都會碰到非常多不盡如人意的各種挑戰, 持續保持個人與團隊的處事熱忱, 是堅持克服困難的必備動力. 不要以為不可能 (終究達陣) – 只要個人不斷提升待人處事能力, 持續接觸人文養分, 並且在團隊機制的架構下, 以轉知為智的精神來解決各式問題, 假以時日, 便可實現團隊理想, 化不可能為可能! 培養新世紀大學生的關鍵能力: http://www.tpea.org.tw/uploads/TPEA_2013112021132.pdf","tags":"Misc","url":"https://kmolab.github.io/blog/first-discussion-blog.html"},{"title":"其他","text":"不在設置, 模擬, 實作與論述類別的內容, 則放入雜項其他類別","tags":"Misc","url":"https://kmolab.github.io/blog/first-misc-blog.html"},{"title":"實作","text":"紀錄與實作有關的內容, 實體製作 操作流程拍攝 有關實作, 包含拍攝實際操作的照片與影片. 在 Windows 環境建議使用 ShareX 拍攝, Ubuntu 則建議使用 Kazam . 另外一個值得研究的 PyQt5 + FFMpeg 工具位於: https://github.com/codeshard/videomorph 理想的課程網頁 https://lectures.quantecon.org/ 是一門教授數學與計量經濟學的課程, 分別使用 Python 與 Julia 程式語言, 採用 Python3 的課程教材 pdf 位於: https://lectures.quantecon.org/_static/pdfs/QuantEconlectures-python3.pdf . 這門課程的網頁不僅有 News , 有 論壇 , 並使用 Jupyter 建立網際 Notebook . 其中, 互動討論程式: https://github.com/discourse/discourse , 為 discourse, 採用 Ruby 建立. Docker for Discourse: https://github.com/discourse/discourse_docker 安裝: https://blog.fntsr.tw/articles/2014/11/07/how-to-build-discourse-with-docker-1/ Discourse 中文: https://meta.discoursecn.org/ 網際程式框架: https://github.com/emberjs/ember.js","tags":"Misc","url":"https://kmolab.github.io/blog/first-realization-blog.html"},{"title":"電腦模擬","text":"紀錄與電腦模擬相關內容與紀錄， 使用工具 Python3, RoboDK ( RoboDK API ) PyQt5 pyqt5 程式 http://projects.skylogic.ca/blog/how-to-install-pyqt5-and-build-your-first-gui-in-python-3-4/ run.py, 自行編寫用從 core/main.py 中導入 MainWindow 類別建立案例後執行 if __name__ == \"__main__\": import sys from PyQt5.QtWidgets import QApplication from core.main import MainWindow app = QApplication(sys.argv) main = MainWindow() main.show() sys.exit(app.exec_()) core/main.py, 以 main.ui 滑鼠右鍵 generate Dialog Code 產生 # -*- coding: utf-8 -*- \"\"\" Module implementing MainWindow. \"\"\" from PyQt5.QtCore import pyqtSlot from PyQt5.QtWidgets import QMainWindow from PyQt5.QtCore import QLineF from PyQt5.QtWidgets import QFrame from PyQt5.QtWidgets import QGraphicsScene, QGraphicsView, QGraphicsEllipseItem from .Ui_main import Ui_MainWindow class MainWindow(QMainWindow, Ui_MainWindow): \"\"\" Class documentation goes here. \"\"\" def __init__(self, parent=None): \"\"\" Constructor @param parent reference to the parent widget @type QWidget \"\"\" super(MainWindow, self).__init__(parent) self.setupUi(self) @pyqtSlot() def on_actionAbout_triggered(self): \"\"\" Slot documentation goes here. \"\"\" # TODO: not implemented yet #raise NotImplementedError #建立景物 scene = QGraphicsScene(-200, -200, 400, 400) # Create Ellipse Item item = QGraphicsEllipseItem(-150, -100, 300, 300) # Add item scene.addItem(item) # 納入繪圖物件 scene.addText(\"終於可以!\") scene.addLine(QLineF(0, 0, 200, 200)) # set no frame to graphicsView self.graphicsView.setFrameShape(QFrame.NoFrame) # 在既有的 graphicsView 中設定景物 # graphicsView in a layout and set layout to the grid to fit the size of window self.graphicsView.setScene(scene) # 顯示 self.graphicsView.show() @pyqtSlot() def on_actionQuit_triggered(self): \"\"\" Slot documentation goes here. \"\"\" # TODO: not implemented yet #raise NotImplementedError self.close() core/Ui_main.py, 利用 main.ui 以 compile form 產生 # -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'Y:\\tmp\\pyqt5_vault\\ex3\\core\\main.ui' # # Created by: PyQt5 UI code generator 5.8.2 # # WARNING! All changes made in this file will be lost! from PyQt5 import QtCore, QtGui, QtWidgets class Ui_MainWindow(object): def setupUi(self, MainWindow): MainWindow.setObjectName(\"MainWindow\") MainWindow.resize(800, 600) self.centralWidget = QtWidgets.QWidget(MainWindow) self.centralWidget.setObjectName(\"centralWidget\") self.graphicsView = QtWidgets.QGraphicsView(self.centralWidget) self.graphicsView.setGeometry(QtCore.QRect(-15, -29, 871, 581)) self.graphicsView.setObjectName(\"graphicsView\") MainWindow.setCentralWidget(self.centralWidget) self.menuBar = QtWidgets.QMenuBar(MainWindow) self.menuBar.setGeometry(QtCore.QRect(0, 0, 800, 22)) self.menuBar.setObjectName(\"menuBar\") self.menuFile = QtWidgets.QMenu(self.menuBar) self.menuFile.setObjectName(\"menuFile\") MainWindow.setMenuBar(self.menuBar) self.actionAbout = QtWidgets.QAction(MainWindow) self.actionAbout.setObjectName(\"actionAbout\") self.actionQuit = QtWidgets.QAction(MainWindow) self.actionQuit.setObjectName(\"actionQuit\") self.menuFile.addAction(self.actionAbout) self.menuFile.addAction(self.actionQuit) self.menuBar.addAction(self.menuFile.menuAction()) self.retranslateUi(MainWindow) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): _translate = QtCore.QCoreApplication.translate MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\")) self.menuFile.setTitle(_translate(\"MainWindow\", \"File\")) self.actionAbout.setText(_translate(\"MainWindow\", \"About\")) self.actionQuit.setText(_translate(\"MainWindow\", \"Quit\")) if __name__ == \"__main__\": import sys app = QtWidgets.QApplication(sys.argv) MainWindow = QtWidgets.QMainWindow() ui = Ui_MainWindow() ui.setupUi(MainWindow) MainWindow.show() sys.exit(app.exec_()) main.ui MainWindow 0 0 800 600 MainWindow -15 -29 871 581 0 0 800 22 File About Quit Binary Genetic Algorithm #encoding=utf8 # genetic.py # import random import operator # for Intersect from math import * MAXIMIZE, MINIMIZE = 11, 22 class Individual: # 染色體先設為 None chromosome = None # 得分也先設為 None score = None # Here the size of var depends on var_number print # var 變數的元素個數取決於 var_number 的個數 (即變數個數) var = [] # 表示適應值變數個數有兩個 var_number = 2 #先將 var 數列中元素都設為 0 for i in range(var_number): var.append(0) # 等位基因表示各基因可選的內容, 這裡表示不是 0 就是 1 alleles = (0,1) # 2**10 = 32*32 = 1024, 表示若用十個 binary 位數來表示整數, 可以表示從 0 到 1023 的數值大小 # 若也用另外 十個 binary 位數來表示小數值, 則也是 0 到 1023 的數值表示能力, # 而再加一個表示正負的代表 binary 位數, 每一個變數需要 21 個 binary numbers # 以下為參數可負數時的編碼考量 #前10為小數,後10為整數,第21則為正負號 #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號. #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號 #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號 # -1023 ~ 1023 #length = 21*var_number,若接受負數參數,則必須同步修改 20->21 # 因為這裡只接受正的變數值, 所以每一個變數需要 20 個 binary 位數 length = 20*var_number seperator = '' optimization = MINIMIZE def __init__(self, chromosome=None): self.chromosome = chromosome or self._makechromosome() self.score = None # set during evaluation ''' bitwise operators (binary left shift): The left operands value is moved left by the number of bits specified by the right operand. x << y Returns x with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is the same as multiplying x by 2**y. ''' # 根據染色體各位元的值轉為 10 進位值 def _getvar(self, chromosome=None): # x 起始值設為 0 x = 0 for i in range(0, self.var_number): # 先根據前 20 個位元值, 透過 binary left shift 轉為 10 進位之後, 再轉為對應小數 for j in range(i*20, i*20+10): x += self.chromosome[j]<<(j-(i*20)) # 因為前 20 個 binary 數, 負責 10 進位數的小數點後 3 個位數, 只要轉為 10 進位值之後, 若大於 999, 則僅取 999, # 再除以 1000, 可以得到 .999 表示 .999 為最大的小數表示數, 不要因為大於 1000 後若除以 1000 將進位到整數, 會與整數有交互影響 if (x>999): x = 999 x /= 1000. # 整數部份 0 ~ 1023 的表示範圍則沒有問題, 利用 bitwise 轉換後, 直接取整數值 for j in range(i*20+10, i*20+20): x += self.chromosome[j]<<(j-(i*20+10)) self.var[i] = x return self.var ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings #for design variable -1023 ~1023 for i in range(self.var_number): x = 0 for j in range(i*21, i*21+10): x += self.chromosome[j]<<(j-(i*21)) if (x>999): x = 999 x /= 1000. for j in range(i*(21)+10, i*(21)+20): x += self.chromosome[j]<<(j-(i*21+10)) # 各變數範圍第 21 位數若為 1, 則表示該數為負數 if(self.chromosome[i*(21)+20] == 1): self.var[i] = -x else: self.var[i] = x # 讓 x 再設回原值 0 表示內定各變數為正數 x = 0 return self.var ''' # 建立染色體 def _makechromosome(self): \"makes a chromosome from randomly selected alleles.\" return [random.choice(self.alleles) for gene in range(self.length)] # 計算適應值 def evaluate(self, optimum=None): \"this method MUST be overridden to evaluate individual fitness score.\" pass # 交配方法 def crossover(self, other): \"override this method to use your preferred crossover method.\" return self._twopoint(other) # 突變方法 def mutate(self, gene): \"override this method to use your preferred mutation method.\" self._pick(gene) # sample mutation method def _pick(self, gene): \"chooses a random allele to replace this gene's allele.\" self.chromosome[gene] = random.choice(self.alleles) # sample crossover method def _twopoint(self, other): \"creates offspring via two-point crossover between mates.\" left, right = self._pickpivots() def mate(p0, p1): chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容 chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因 child = p0.__class__(chromosome) child._repair(p0, p1) return child return mate(self, other), mate(other, self) # some crossover helpers ... def _repair(self, parent1, parent2): \"override this method, if necessary, to fix duplicated genes.\" pass def _pickpivots(self): left = random.randrange(1, self.length-2) right = random.randrange(left, self.length-1) return left, right # # other methods # def __repr__(self): \"returns string representation of self\" ''' return '<%s chromosome=\"%s\" score=%s var=%s>' % \\ (self.__class__.__name__, self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome)) ''' return '<%s score=%s var=%s>' % \\ (self.__class__.__name__,self.score,self._getvar(self.chromosome)) # since the __cmp__ special function is gone use the __lt__ in stead # use the expression (a > b) - (a < b) as the equivalent for cmp(a, b) #def __cmp__(self, other): # these are for python 3 def __cmp__(self, other): if self.optimization == MINIMIZE: #return cmp(self.score, other.score) return (self.score > other.score) - (self.score < other.score) else: # MAXIMIZE #return cmp(other.score, self.score) return (other.score > self.score) - (other.score < self.score) def __lt__(self, other): return self.__cmp__(other) < 0 def __le__(self, other): return self.__cmp__(other) <= 0 def __gt__(self, other): return self.__cmp__(other) > 0 def __ge__(self, other): return self.__cmp__(other) >= 0 def copy(self): twin = self.__class__(self.chromosome[:]) twin.score = self.score return twin class Environment(object): x = [0] y = [0] def __init__(self, kind, population=None, size=100, maxgenerations=100, crossover_rate=0.90, mutation_rate=0.07, optimum=None): self.kind = kind self.size = size self.optimum = optimum self.population = population or self._makepopulation() for individual in self.population: individual.evaluate(self.optimum) self.crossover_rate = crossover_rate self.mutation_rate = mutation_rate self.maxgenerations = maxgenerations self.generation = 0 self.report() def _makepopulation(self): return [self.kind() for individual in range(self.size)] def run(self): while not self._goal(): self.step() def _goal(self): return self.generation > self.maxgenerations or \\ self.best.score == self.optimum def step(self): # this sort is not working with python 3.0, modification is needed self.population.sort() self._crossover() self.generation += 1 self.report() self.x.append(self.generation) # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值 if self.best.score <=5: self.y.append(self.best.score) else: self.y.append(5) def _crossover(self): next_population = [self.best.copy()] while len(next_population) < self.size: mate1 = self._select() if random.random() < self.crossover_rate: mate2 = self._select() offspring = mate1.crossover(mate2) else: offspring = [mate1.copy()] for individual in offspring: self._mutate(individual) individual.evaluate(self.optimum) next_population.append(individual) self.population = next_population[:self.size] def _select(self): \"override this to use your preferred selection method\" return self._tournament() def _mutate(self, individual): for gene in range(individual.length): if random.random() < self.mutation_rate: individual.mutate(gene) # # sample selection method # def _tournament(self, size=8, choosebest=0.90): competitors = [random.choice(self.population) for i in range(size)] competitors.sort() if random.random() < choosebest: return competitors[0] else: return random.choice(competitors[1:]) def best(): doc = \"individual with best fitness score in population.\" def fget(self): return self.population[0] return locals() best = property(**best()) def report(self): try: print (\"=\"*70) print (\"generation: \", self.generation) print (\"best: \", self.best) except: g.es (\"=\"*70) g.es (\"generation: \", self.generation) g.es (\"best: \", self.best) # 以上為 genetic.py 目前將兩者結合在一起 #encoding=utf8 # volume.py - useage example # # the fittest individual will have a chromosome consisting of 40 '1's # # #import genetic class Volume(Individual): optimization = MAXIMIZE def evaluate(self, optimum=None): SURFACE = 80 # self.score is the fitness value self._getvar(self.chromosome) x = self.var[0] y = self.var[1] z=(SURFACE - x*y)/(2.*(x+y)) fitness_value = x*y*z self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip class Intersect(Individual): optimization = MINIMIZE def evaluate(self, optimum=None): # self.score is the fitness value self._getvar(self.chromosome) t = self.var[0] deg = pi/180 theta = self.var[1]*deg xtarget = 0.75/2 ytarget = 0.5 x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2 y = (-3*t/2 + 123/92)*sin(theta) # 適應值 fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8) # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰 if t > 1: fitness_value += 1000 if t < 0: fitness_value += 1000 # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰 if theta > 2*pi: fitness_value += 1000 if theta < 0: fitness_value += 1000 self.score = fitness_value def mutate(self, gene): self.chromosome[gene] = not self.chromosome[gene] # bit flip if __name__ == \"__main__\": env = Environment(Volume, size=500, maxgenerations=100) #env = Environment(Intersect, size=500, maxgenerations=100) env.run() Deap 與 Scoop Deap: https://github.com/DEAP/deap Scoop: https://en.wikipedia.org/wiki/Python_SCOOP_(software) https://groups.google.com/forum/#!topic/deap-users/v3wbky0EUf0 https://groups.google.com/forum/m/#!msg/deap-users/P4IkiE-Bvbg/xSoMDphbMR4J 平行運算 http://research.cs.wisc.edu/htcondor/ https://github.com/J-Robinson/GridGA 利用 Blender 製作 Essence of calculus Essence of linear algebra","tags":"Research","url":"https://kmolab.github.io/blog/first-simulation-blog.html"},{"title":"軟硬體設置","text":"紀錄電腦與網路的軟硬體相關設置 Github, Bitbucket 與 Fossil SCM Github 目前提供的免費帳號, 允許多人協同提交推送版本, 唯一的限制就是單一檔案不能大於 50 MB. Bitbucket 則允許免費使用非公開的倉儲, 但是至多只允許五個帳號協同. Fossil SCM 則適合在近端或區域網路中使用, 目前 KMOLab 希望在區網中導入作為與 Github Pages 配合的工具, 使用者可以將 Fossil SCM 的 working directory 限縮在 Github 近端倉儲的特定目錄下, 且在 .gitignore 中排除 FOSSIL (under Windows) 的版次管理, 但是相關的 fossil update 與 fossil server 功能仍然必須依照特定的流程進行操作, 以避免兩套版次管理系統內容的不同步導致資料覆蓋流失. github 倉儲與 bitbucket 倉儲, 則可以利用 git remote add 同步. Leo Editor, Pelican 與 Reveal.js Leo Editor 是一套能夠以程式方法有效管理多元資料的文字資料編輯器, 以下就是用來管理 KMOLab Pelican 靜態網誌有關內容的畫面, 其中的 @button local-blog 是用來產生靜態網誌的指令按鈕, @button github-blog 則是用來產生嵌入 Disqus 留言系統的 Github Pages 網誌對應指令, 兩個指令的差別在於使用不同的設定檔案, 使用者可以先利用近端的按鈕, 建立網誌後在近端以另一個 https-server 按鈕建立 https 伺服, 用瀏覽器檢查所產生的網誌內容, 一旦要送到 Github 倉儲, 必須再利用遠端按鈕產生另外一組網誌與搜尋用 .json 檔案後, 再提交推送到倉儲. 在這個過程中, 使用者依照 Pelican 的特定 Markdown 檔案編寫網誌內容外, Leo Editor 專案檔中也可以放入其他有關的註記與設定檔案編輯用的節點. 若需要在 Pelican 的環境中修改設定, 都可以全部在一個 Leo Editor 專案檔中完成. Leo Editor 另外一項有用的特定就是能夠利用從屬節點關係與內文指令來表示複雜的 html 檔案, 如下圖所示, 各段落的超文件標註可以利用節點加以切割, 使用者在編寫 reveal.js 投影片時, 可以只集中在特定簡報內容的編寫, 並且透過節點的複製與搬移, 甚至使用 Leo Editor 的節點 clone 功能, 同步相同內容但是同時出現在不同位置的節點. Pelican Blog 共用設定檔案: pelicanconf.py #!/usr/bin/env python # -*- coding: utf-8 -*- # from __future__ import unicode_literals AUTHOR = 'KMOL' SITENAME = 'KMOLab 機械設計工程' # 不要用文章所在目錄作為類別 USE_FOLDER_AS_CATEGORY = False #PATH = 'content' #OUTPUT_PATH = 'output' TIMEZONE = 'Asia/Taipei' DEFAULT_LANG = 'en' # Feed generation is usually not desired when developing FEED_ALL_ATOM = None CATEGORY_FEED_ATOM = None TRANSLATION_FEED_ATOM = None AUTHOR_FEED_ATOM = None AUTHOR_FEED_RSS = None # Blogroll LINKS = (('Pelican', 'http://getpelican.com/'), ('pelican-bootstrap3', 'https://github.com/DandyDev/pelican-bootstrap3/'), ('pelican-plugins', 'https://github.com/getpelican/pelican-plugins'), ('Tipue search', 'https://github.com/Tipue/Tipue-Search'),) # Social widget #SOCIAL = (('You can add links in your config file', '#'),('Another social link', '#'),) DEFAULT_PAGINATION = 10 # Uncomment following line if you want document-relative URLs when developing #RELATIVE_URLS = True # 必須絕對目錄或相對於設定檔案所在目錄 PLUGIN_PATHS = ['plugin'] PLUGINS = ['summary', 'tipue_search', 'sitemap'] # for sitemap plugin SITEMAP = { 'format': 'xml', 'priorities': { 'articles': 0.5, 'indexes': 0.5, 'pages': 0.5 }, 'changefreqs': { 'articles': 'monthly', 'indexes': 'daily', 'pages': 'monthly' } } # search is for Tipue search DIRECT_TEMPLATES = (('index', 'tags', 'categories', 'authors', 'archives', 'search')) # for pelican-bootstrap3 theme settings #TAG_CLOUD_MAX_ITEMS = 50 DISPLAY_CATEGORIES_ON_SIDEBAR = True DISPLAY_RECENT_POSTS_ON_SIDEBAR = True DISPLAY_TAGS_ON_SIDEBAR = True DISPLAY_TAGS_INLINE = True TAGS_URL = \"tags.html\" CATEGORIES_URL = \"categories.html\" MENUITEMS = [('About', '/blog/pages/about/')] #SHOW_ARTICLE_AUTHOR = True #MENUITEMS = [('Home', '/'), ('Archives', '/archives.html'), ('Search', '/search.html')] 遠端 publishconf.py #!/usr/bin/env python # -*- coding: utf-8 -*- # from __future__ import unicode_literals # This file is only used if you use `make publish` or # explicitly specify it as your config file. import os import sys sys.path.append(os.curdir) from pelicanconf import * # 因為 publishconf.py 在 pelicanconf.py 之後, 因此若兩處有相同變數的設定, 將以較後讀入的 publishconf.py 中的設定為主. # 將所有靜態 html 檔案移到 blog 子目錄 SITEURL = 'https://kmolab.github.io/blog' # 此設定用於將資料送到 gh-pages, 因此使用絕對 URL 設定 RELATIVE_URLS = False # 為了要讓 local 與 gh-pages 上都能夠使用 Tipue search, 可能要採用不同的 theme THEME = 'theme/pelican-bootstrap3' #BOOTSTRAP_THEME = 'readable' #BOOTSTRAP_THEME = 'readable-old' BOOTSTRAP_THEME = 'united' #PYGMENTS_STYLE = 'paraiso-drak' #PYGMENTS_STYLE = 'fruity' # 為了同時兼容 render_math, 必須放棄 fruity PYGMENTS_STYLE = 'monokai' FEED_ALL_ATOM = 'feeds/all.atom.xml' CATEGORY_FEED_ATOM = 'feeds/%s.atom.xml' DELETE_OUTPUT_DIRECTORY = True # Following items are often useful when publishing DISQUS_SITENAME = \"kmolabmde\" #GOOGLE_ANALYTICS = \"\" # 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定 DEFAULT_DATE = 'fs' # 遠端的 code hightlight #MD_EXTENSIONS = ['fenced_code', 'extra', 'codehilite(linenums=True)'] MARKDOWN = { 'extension_configs': { 'markdown.extensions.codehilite': {'css_class': 'highlight'}, 'markdown.extensions.extra': {}, 'markdown.extensions.meta': {}, }, 'output_format': 'html5', } # 若要依照日期存檔呼叫 #ARTICLE_URL = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/' #ARTICLE_SAVE_AS = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' PAGE_URL = 'pages/{slug}/' PAGE_SAVE_AS = 'pages/{slug}/index.html' SHOW_ARTICLE_AUTHOR = True local_publishconf.py #!/usr/bin/env python # -*- coding: utf-8 -*- # from __future__ import unicode_literals # This file is only used if you use `make publish` or # explicitly specify it as your config file. import os import sys sys.path.append(os.curdir) from pelicanconf import * # 因為 publishconf.py 在 pelicanconf.py 之後, 因此若兩處有相同變數的設定, 將以較後讀入的 publishconf.py 中的設定為主. # 請注意, 為了在近端讓 Tipue search 傳回的搜尋結果連結正確, 必須使用 ./ SITEURL = './' # 此設定用於近端靜態網頁查驗, 因此使用相對 URL RELATIVE_URLS = True # 為了要讓 local 與 gh-pages 上都能夠使用 Tipue search, 可能要採用不同的 theme THEME = 'theme/pelican-bootstrap3_local' #BOOTSTRAP_THEME = 'readable' #BOOTSTRAP_THEME = 'readable-old' BOOTSTRAP_THEME = 'united' #PYGMENTS_STYLE = 'paraiso-drak' #PYGMENTS_STYLE = 'fruity' # 為了同時兼容 render_math, 必須放棄 fruity PYGMENTS_STYLE = 'monokai' FEED_ALL_ATOM = 'feeds/all.atom.xml' CATEGORY_FEED_ATOM = 'feeds/%s.atom.xml' DELETE_OUTPUT_DIRECTORY = True # Following items are often useful when publishing #DISQUS_SITENAME = \"kmolabmde\" #GOOGLE_ANALYTICS = \"\" # 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定 DEFAULT_DATE = 'fs' # 近端的 code hightlight #MD_EXTENSIONS = ['fenced_code', 'extra', 'codehilite(linenums=True)'] MARKDOWN = { 'extension_configs': { 'markdown.extensions.codehilite': {'css_class': 'highlight'}, 'markdown.extensions.extra': {}, 'markdown.extensions.meta': {}, }, 'output_format': 'html5', } # 若要依照日期存檔呼叫 #ARTICLE_URL = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' #ARTICLE_SAVE_AS = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html' PAGE_URL = 'pages/{slug}/' PAGE_SAVE_AS = 'pages/{slug}/index.html' SHOW_ARTICLE_AUTHOR = True 區網中的 IPv4 與 IPv6 WWW Server Pelican 在近端產生 weblog 後, 若要在近端以 https 檢視結果, 就必須同時建立 https Server. 近端 IPv4 WWW 伺服器程式: import os import subprocess import threading import http.server, ssl def domake(): # build directory os.chdir(\"./../\") server_address = ('localhost', 5443) httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler) httpd.socket = ssl.wrap_socket(httpd.socket, server_side=True, certfile='localhost.crt', keyfile='localhost.key', ssl_version=ssl.PROTOCOL_TLSv1) print(os.getcwd()) print(\"5443 https server started\") httpd.serve_forever() # 利用執行緒執行 https 伺服器 make = threading.Thread(target=domake) make.start() 近端 IPv6 ＷＷＷ 伺服器程式: import os import subprocess import threading import socket import http.server, ssl class HTTPServerV6(http.server.HTTPServer): address_family = socket.AF_INET6 def domake(): # build directory os.chdir(\"./../\") ipv6_address = '::1' server_address = (ipv6_address, 6443) #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler) httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler) httpd.socket = ssl.wrap_socket(httpd.socket, server_side=True, certfile='localhost.crt', keyfile='localhost.key', ssl_version=ssl.PROTOCOL_TLSv1) print(\"6443 https server started\") httpd.serve_forever() # 利用執行緒執行 https 伺服器 make = threading.Thread(target=domake) make.start()","tags":"Research","url":"https://kmolab.github.io/blog/first-setup-blog.html"}]};