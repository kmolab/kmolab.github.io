<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>KMOLab 機械設計工程 - Course</title><link href="./" rel="alternate"></link><link href="./feeds/course.atom.xml" rel="self"></link><id>./</id><updated>2017-08-26T12:00:00+08:00</updated><entry><title>Sunset of OpenShift Online 2 Platform</title><link href="./sunset-of-openshift-online2.html" rel="alternate"></link><published>2017-08-26T12:00:00+08:00</published><updated>2017-08-26T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:None,2017-08-26:./sunset-of-openshift-online2.html</id><summary type="html">&lt;p&gt;OpenShift 在 2017.08.25 於 &lt;a href="https://blog.openshift.com/migrate-to-v3-v2-eol/"&gt;https://blog.openshift.com/migrate-to-v3-v2-eol/&lt;/a&gt; 宣布, 先前所推出的 Online 2 Platform, 將要在 2017.09.30 走入歷史.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;OpenShift 在 2017.08.25 於 &lt;a href="https://blog.openshift.com/migrate-to-v3-v2-eol/"&gt;https://blog.openshift.com/migrate-to-v3-v2-eol/&lt;/a&gt; 宣布, 先前所推出的 Online 2 Platform, 將要在 2017.09.30 走入歷史.&lt;/p&gt;


&lt;p&gt;為了因應這個變化, 許多過去所建立的網站資料將要轉到 Github 與 Fossil SCM.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wordpress-2015course.rhcloud.com/"&gt;https://wordpress-2015course.rhcloud.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;有用的連結&lt;/h3&gt;
&lt;p&gt;Free Math Books&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.openculture.com/free-math-textbooks"&gt;http://www.openculture.com/free-math-textbooks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kinematic Synthesis of Linkage&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ebooks.library.cornell.edu/k/kmoddl/toc_hartenberg1.html"&gt;http://ebooks.library.cornell.edu/k/kmoddl/toc_hartenberg1.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;the kinematic models for design&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ebooks.library.cornell.edu/k/kmoddl/about.html"&gt;http://ebooks.library.cornell.edu/k/kmoddl/about.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CSS 與 Div 取代 Table&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sofree.cc/css-table/"&gt;https://sofree.cc/css-table/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flycan.com/article/css/css-float-442.html"&gt;http://www.flycan.com/article/css/css-float-442.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以 http://2016spring-cadlab.rhcloud.com 取出舊版程式? cadlab At mde&lt;/p&gt;
&lt;p&gt;備份: https://wordpress-2015course.rhcloud.com/?p=4579&lt;/p&gt;
&lt;p&gt;Product Design Modeling using CAD/CAE &lt;/p&gt;
&lt;p&gt;How to be a star engineer&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ieeexplore.ieee.org/document/795608/"&gt;http://ieeexplore.ieee.org/document/795608/&lt;/a&gt;&lt;/p&gt;</content><category term="OpenShift"></category></entry><entry><title>Calculator in PyQt5 and Eric6</title><link href="./calculator-pyqt5-eric6.html" rel="alternate"></link><published>2017-07-31T12:00:00+08:00</published><updated>2017-07-31T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:None,2017-07-31:./calculator-pyqt5-eric6.html</id><summary type="html">&lt;p&gt;根據 &lt;a href="http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html"&gt;http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html&lt;/a&gt; 的說明, 利用 Eric6 與 PyQt5 開發簡單的計算器視窗程式.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;根據 &lt;a href="http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html"&gt;http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html&lt;/a&gt; 的說明, 利用 Eric6 與 PyQt5 開發簡單的計算器視窗程式.&lt;/p&gt;


&lt;p&gt;Flask 與 Javascript 建立簡單計算器: &lt;a href='https://github.com/helloflask/calculator"&gt;https://github.com/helloflask/calculator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前在 KMOL 的計算機程式, 主要寫成三種格式, 1) 採用 PyQt5 寫單機視窗應用程式, 2) 以 Flask 及 Javascript 寫成瀏覽器程式, 3) 最後則是寫成 Android 平台上的 Apps.&lt;/p&gt;
&lt;p&gt;PyQt5 單機應用程式與 Android Apps 的用途主要在即時與周遭的軟硬體互動, 執行虛實模擬或操作控制, 或者用來管理其他與近端軟硬體有關的主程式, 而 Flask Server Based 程式則以網際模式提供, 主要用於多人同步或非同步協同之用.&lt;/p&gt;
&lt;h3&gt;計算器原始碼&lt;/h3&gt;
&lt;p&gt;與 Qt5 加上 C++ 實現的簡單視窗計算器程式對應的 PyQt5 程式,  &lt;a href="https://github.com/baoboa/pyqt5/blob/master/examples/widgets/calculator.py"&gt;https://github.com/baoboa/pyqt5/blob/master/examples/widgets/calculator.py&lt;/a&gt;. 若使用本學期所使用的 Python 3.6 可攜程是環境 &lt;a href="http://service.mde.tw/public/python2017fall_36.7z"&gt;http://service.mde.tw/public/python2017fall_36.7z&lt;/a&gt;, 直接利用 SciTE 開啟 calculator.py 後按下 Tools - Go 就可以執行.&lt;/p&gt;
&lt;h3&gt;waitingForOperand 變數&lt;/h3&gt;
&lt;p&gt;self.waitingForOperand 成員變數, 用來記錄計算器的輸入流程中, 是否處於等待使用者輸入處理數值. 一開始 self.waitingForOperand 為 True. 當首次按下數字鍵則系統清除顯示區, 然後 self.waitingForOperand 轉為 False. 表示已經進入處理數值的輸入程序中, 這時若使用者再按其他數字按鈕, 則 if self.waitingForOperand 區段將不會執行, 也就不會刷新顯示區, 而是執行其下方的顯示區數字附加的程式段.&lt;/p&gt;
&lt;p&gt;self.display.setText(self.display.text() + str(digitValue))&lt;/p&gt;
&lt;p&gt;至於 self.waitingForOperand 再次轉為 True 的時機, 分別在 unaryOperatorClicked、additiveOperatorClicked、multiplicativeOperatorClicked、pointclicked 或 equalClicked 等成員函式執行後, 輸入流程又轉回等待使用者輸入運算數值的階段.&lt;/p&gt;
&lt;p&gt;其他 self.waitingForOperand 出現在 backspaceClicked、clear 與 clearAll 函式時, 也必須確定 self.waitingForOperand 會再次轉為 True.&lt;/p&gt;
&lt;h3&gt;pendingAdditiveOperator 變數&lt;/h3&gt;
&lt;p&gt;若 pendingAdditiveOperator 為 True, 優先運算階段完成後顯示區換成 self.factorSoFar. 若 pendingAdditiveOperator 為 False, 則將目前顯示區中的數值對應成 self.factorSoFar.&lt;/p&gt;
&lt;p&gt;The private calculate() function performs a binary operation. The right operand is given by rightOperand. For additive operators, the left operand is sumSoFar; for multiplicative operators, the left operand is factorSoFar. The function return false if a division by zero occurs.&lt;/p&gt;
&lt;h3&gt;sumSofFar 與 factorSoFar 變數&lt;/h3&gt;
&lt;p&gt;執行 calculate  函式時, 若運算子為加或減, 則左運算數為 sumSoFar, 若運算子為乘或除, 則左運算數為 factorSoFar. 右運算數則取自 rightOperand 變數.&lt;/p&gt;
&lt;p&gt;The example consists of two classes:&lt;/p&gt;
&lt;p&gt;Calculator is the calculator widget, with all the calculator functionality.&lt;/p&gt;
&lt;p&gt;Button is the widget used for each of the calculator button. It derives from QToolButton.&lt;/p&gt;
&lt;p&gt;The Calculator class provides a simple calculator widget. It inherits from QDialog and has several private slots associated with the calculator's buttons. QObject::eventFilter() is reimplemented to handle mouse events on the calculator's display.&lt;/p&gt;
&lt;p&gt;Buttons are grouped in categories according to their behavior. For example, all the digit buttons (labeled 0 to 9) append a digit to the current operand. For these, we connect multiple buttons to the same slot (e.g., digitClicked()). The categories are digits, unary operators (Sqrt, x², 1/x), additive operators (+, -), and multiplicative operators (×, ÷). The other buttons have their own slots.&lt;/p&gt;
&lt;p&gt;The private createButton() function is used as part of the widget construction. abortOperation() is called whenever a division by zero occurs or when a square root operation is applied to a negative number. calculate() applies a binary operator (+, -, ×, or ÷).&lt;/p&gt;
&lt;p&gt;These variables, together with the contents of the calculator display (a QLineEdit), encode the state of the calculator:&lt;/p&gt;
&lt;p&gt;sumInMemory contains the value stored in the calculator's memory (using MS, M+, or MC).&lt;/p&gt;
&lt;p&gt;sumSoFar stores the value accumulated so far. When the user clicks =, sumSoFar is recomputed and shown on the display. Clear All resets sumSoFar to zero.&lt;/p&gt;
&lt;p&gt;factorSoFar stores a temporary value when doing multiplications and divisions.&lt;/p&gt;
&lt;p&gt;pendingAdditiveOperator stores the last additive operator clicked by the user.&lt;/p&gt;
&lt;p&gt;pendingMultiplicativeOperator stores the last multiplicative operator clicked by the user.&lt;/p&gt;
&lt;p&gt;waitingForOperand is true when the calculator is expecting the user to start typing an operand.&lt;/p&gt;
&lt;p&gt;Additive and multiplicative operators are treated differently because they have different precedences. For example, 1 + 2 ÷ 3 is interpreted as 1 + (2 ÷ 3) because ÷ has higher precedence than +.&lt;/p&gt;
&lt;p&gt;The table below shows the evolution of the calculator state as the user enters a mathematical expression.&lt;/p&gt;
&lt;p&gt;Waiting for Operand? 等待運算處理對象?&lt;/p&gt;
&lt;p&gt;Add. Op. - 加或減運算元,若隨後無乘與除等優先運算元, 且按下等於或接著按加或減運算元, 則前段隨即完成運算後列在 Sum so Far 欄位.&lt;/p&gt;
&lt;p&gt;Mul. Op. - 乘或除運算元, 屬於優先運算元, 因此若輸入已經滿足運算數接優先運算元, 再接其他運算元則 將局部優先運算所需的前方運算數, 放入 Factor so Far, 而前面未處理的加或減運算數, 則放入 Sum so Far.&lt;/p&gt;
&lt;!-- 這裡在測試 template 中 base.html head 標註中所加入的 style 標註用法 --&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;User Input&lt;/th&gt; &lt;th&gt;Display&lt;/th&gt;    &lt;th&gt;Sum so Far&lt;/th&gt; &lt;th&gt;Add. Op.&lt;/ht&gt;   &lt;th&gt;Factor so Far&lt;/th&gt;  &lt;th&gt;Mult. Op.&lt;/th&gt;  &lt;th&gt;Waiting for Operand?&lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt; &lt;td&gt;0&lt;/td&gt;    &lt;td&gt;0&lt;/td&gt;  &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;           &lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;0&lt;/td&gt;  &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;           &lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 +&lt;/td&gt;    &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;+&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;          &lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2&lt;/td&gt;  &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;+&lt;/td&gt;  &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;     &lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2 ÷&lt;/td&gt;    &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;+&lt;/td&gt;  &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;÷&lt;/td&gt; &lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2 ÷ 3&lt;/td&gt;  &lt;td&gt;3&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;+&lt;/td&gt;  &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;÷&lt;/td&gt;  &lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2 ÷ 3 -&lt;/td&gt;    &lt;td&gt;1.66667&lt;/td&gt;    &lt;td&gt;1.66667&lt;/td&gt;    &lt;td&gt;-&lt;/td&gt;  &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;     &lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2 ÷ 3 - 4&lt;/td&gt;  &lt;td&gt;4&lt;/td&gt;  &lt;td&gt;1.66667&lt;/td&gt;    &lt;td&gt;-&lt;/td&gt;      &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2 ÷ 3 - 4 =&lt;/td&gt;    &lt;td&gt;-2.33333&lt;/td&gt;   &lt;td&gt;0&lt;/td&gt;      &lt;td&gt;&lt;/td&gt;   &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
Unary operators, such as Sqrt, require no special handling; they can be applied immediately since the operand is already known when the operator button is clicked.&lt;/p&gt;
&lt;p&gt;Finally, we declare the variables associated with the display and the buttons used to display numerals.&lt;/p&gt;
&lt;p&gt;In the constructor, we initialize the calculator's state. The pendingAdditiveOperator and pendingMultiplicativeOperator variables don't need to be initialized explicitly, because the QString constructor initializes them to empty strings.&lt;/p&gt;
&lt;p&gt;We create the QLineEdit representing the calculator's display and set up some of its properties. In particular, we set it to be read-only.&lt;/p&gt;
&lt;p&gt;We also enlarge display's font by 8 points.&lt;/p&gt;
&lt;p&gt;For each button, we call the private createButton() function with the proper text label and a slot to connect to the button.&lt;/p&gt;
&lt;p&gt;The layout is handled by a single QGridLayout. The QLayout::setSizeConstraint() call ensures that the Calculator widget is always shown as its optimal size (its size hint), preventing the user from resizing the calculator. The size hint is determined by the size and size policy of the child widgets.&lt;/p&gt;
&lt;p&gt;Most child widgets occupy only one cell in the grid layout. For these, we only need to pass a row and a column to QGridLayout::addWidget(). The display, backspaceButton, clearButton, and clearAllButton widgets occupy more than one column; for these we must also pass a row span and a column span.&lt;/p&gt;
&lt;p&gt;Pressing one of the calculator's digit buttons will emit the button's clicked() signal, which will trigger the digitClicked() slot.&lt;/p&gt;
&lt;p&gt;First, we find out which button sent the signal using QObject::sender(). This function returns the sender as a QObject pointer. Since we know that the sender is a Button object, we can safely cast the QObject. We could have used a C-style cast or a C++ static_cast&amp;lt;&amp;gt;(), but as a defensive programming technique we use a qobject_cast(). The advantage is that if the object has the wrong type, a null pointer is returned. Crashes due to null pointers are much easier to diagnose than crashes due to unsafe casts. Once we have the button, we extract the operator using QToolButton::text().&lt;/p&gt;
&lt;p&gt;The slot needs to consider two situations in particular. If display contains "0" and the user clicks the 0 button, it would be silly to show "00". And if the calculator is in a state where it is waiting for a new operand, the new digit is the first digit of that new operand; in that case, any result of a previous calculation must be cleared first.&lt;/p&gt;
&lt;p&gt;At the end, we append the new digit to the value in the display.&lt;/p&gt;
&lt;p&gt;The unaryOperatorClicked() slot is called whenever one of the unary operator buttons is clicked. Again a pointer to the clicked button is retrieved using QObject::sender(). The operator is extracted from the button's text and stored in clickedOperator. The operand is obtained from display.&lt;/p&gt;
&lt;p&gt;Then we perform the operation. If Sqrt is applied to a negative number or 1/x to zero, we call abortOperation(). If everything goes well, we display the result of the operation in the line edit and we set waitingForOperand to true. This ensures that if the user types a new digit, the digit will be considered as a new operand, instead of being appended to the current value.&lt;/p&gt;
&lt;p&gt;The additiveOperatorClicked() slot is called when the user clicks the + or - button.&lt;/p&gt;
&lt;p&gt;Before we can actually do something about the clicked operator, we must handle any pending operations. We start with the multiplicative operators, since these have higher precedence than additive operators:&lt;/p&gt;
&lt;p&gt;If × or ÷ has been clicked earlier, without clicking = afterward, the current value in the display is the right operand of the × or ÷ operator and we can finally perform the operation and update the display.&lt;/p&gt;
&lt;p&gt;If + or - has been clicked earlier, sumSoFar is the left operand and the current value in the display is the right operand of the operator. If there is no pending additive operator, sumSoFar is simply set to be the text in the display.&lt;/p&gt;
&lt;p&gt;Finally, we can take care of the operator that was just clicked. Since we don't have the right-hand operand yet, we store the clicked operator in the pendingAdditiveOperator variable. We will apply the operation later, when we have a right operand, with sumSoFar as the left operand.&lt;/p&gt;
&lt;p&gt;The multiplicativeOperatorClicked() slot is similar to additiveOperatorClicked(). We don't need to worry about pending additive operators here, because multiplicative operators have precedence over additive operators.&lt;/p&gt;
&lt;p&gt;Like in additiveOperatorClicked(), we start by handling any pending multiplicative and additive operators. Then we display sumSoFar and reset the variable to zero. Resetting the variable to zero is necessary to avoid counting the value twice.&lt;/p&gt;
&lt;p&gt;The pointClicked() slot adds a decimal point to the content in display.&lt;/p&gt;
&lt;p&gt;The changeSignClicked() slot changes the sign of the value in display. If the current value is positive, we prepend a minus sign; if the current value is negative, we remove the first character from the value (the minus sign).&lt;/p&gt;
&lt;p&gt;The backspaceClicked() removes the rightmost character in the display. If we get an empty string, we show "0" and set waitingForOperand to true.&lt;/p&gt;
&lt;p&gt;The clear() slot resets the current operand to zero. It is equivalent to clicking Backspace enough times to erase the entire operand.&lt;/p&gt;
&lt;p&gt;The clearAll() slot resets the calculator to its initial state.&lt;/p&gt;
&lt;p&gt;The clearMemory() slot erases the sum kept in memory, readMemory() displays the sum as an operand, setMemory() replace the sum in memory with the current sum, and addToMemory() adds the current value to the value in memory. For setMemory() and addToMemory(), we start by calling equalClicked() to update sumSoFar and the value in the display.&lt;/p&gt;
&lt;p&gt;The private createButton() function is called from the constructor to create calculator buttons.&lt;/p&gt;
&lt;p&gt;The private abortOperation() function is called whenever a calculation fails. It resets the calculator state and displays "####".&lt;/p&gt;
&lt;p&gt;The private calculate() function performs a binary operation. The right operand is given by rightOperand. For additive operators, the left operand is sumSoFar; for multiplicative operators, the left operand is factorSoFar. The function return false if a division by zero occurs.&lt;/p&gt;</content><category term="計算機程式"></category><category term="PyQt5"></category></entry><entry><title>Create a Multi-repository Fossil SCM Server</title><link href="./create-a-multi-repository-fossil-scm-server.html" rel="alternate"></link><published>2017-07-14T12:00:00+08:00</published><updated>2017-07-14T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:None,2017-07-14:./create-a-multi-repository-fossil-scm-server.html</id><summary type="html">&lt;p&gt;In order to create a multi-repository Fossil SCM server on Ubuntu 16.04 environment, three steps are needed.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;In order to create a multi-repository Fossil SCM server on Ubuntu 16.04 environment, three steps are needed.&lt;/p&gt;


&lt;h3&gt;Step 1: install Stunnel and Fossil SCM&lt;/h3&gt;
&lt;p&gt;sudo apt update&lt;/p&gt;
&lt;p&gt;sudo apt install stunnel4 -y&lt;/p&gt;
&lt;p&gt;sudo apt install fossil&lt;/p&gt;
&lt;p&gt;Edit /etc/environment file and add the following setup to allow only the https connections:&lt;/p&gt;
&lt;p&gt;HTTPS=on&lt;/p&gt;
&lt;p&gt;Edit /etc/default/stunnel4 file and modified the ENABLED value from 0 to 1 to get stunnel service running when the computer startup:&lt;/p&gt;
&lt;p&gt;ENABLED=1&lt;/p&gt;
&lt;h3&gt;Step 2: Stunnel setup&lt;/h3&gt;
&lt;p&gt;Change directory to /etc/stunnel/ and use the following command to generate localhost.key and localhost.crt files.&lt;/p&gt;
&lt;p&gt;sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt&lt;/p&gt;
&lt;p&gt;edit stunnel.conf configuration file under /etc/stunnel/ as follows:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
[https]
accept = your_IPv4_ip:443
accept = :::443
cert = /etc/stunnel/localhost.crt
key = /etc/stunnel/localhost.key
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound default
&lt;/pre&gt;

&lt;p&gt;which means the IPv4 and IPv6 requests are both accepted under port 443. And /home/user/repository/ is used to store the Fossil SCM repo files. The default repo file is /home/user/repository/default.fossil&lt;/p&gt;
&lt;p&gt;The setting of "--notfound default" means if the repository file is not specified, connection URL is default which is a relative directory associated with the server main URL.&lt;/p&gt;
&lt;h3&gt;Step 3: create Fossil SCM repositories&lt;/h3&gt;
&lt;p&gt;Change directory to /home/user/repository and use "fossil init default.fossil" command to create the default repository. If more repository is needed, also use "fossil init other.fossil" to create other.fossil repository under /home/user/repository.&lt;/p&gt;
&lt;p&gt;After the setup use "/etc/init.d/stunnel4 restart" command to restart the Stunnel service.&lt;/p&gt;
&lt;p&gt;Use https://site-url:443/ to connect to default.fossil and use https://site-url:443/other to connect to other.fossil.&lt;/p&gt;</content><category term="Fossil SCM"></category><category term="Ubuntu"></category></entry><entry><title>2015 Fall CADP W16</title><link href="./2015-cadp-w16.html" rel="alternate"></link><published>2017-07-10T12:00:00+08:00</published><updated>2017-07-10T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:None,2017-07-10:./2015-cadp-w16.html</id><summary type="html">&lt;p&gt;根據 &lt;a href="./../data/nutcracker/ProEMechanism.pdf"&gt;Nutcracker 機構&lt;/a&gt;的尺寸規格, 請設法算出 Piston 零件的有效運動範圍.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;根據 &lt;a href="./../data/nutcracker/ProEMechanism.pdf"&gt;Nutcracker 機構&lt;/a&gt;的尺寸規格, 請設法算出 Piston 零件的有效運動範圍.&lt;/p&gt;


&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_left_limit.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_right_limit.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;計算 Piston 不發生干涉的有效行程, 可採如下方法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;實際利用 Onshape 中的組立, 移動 piston 零件, 靠目測概略決定 piston 的有效行程. (目測法, 只能得到大概的行程範圍)&lt;/li&gt;
&lt;li&gt;利用 Solvespace 繪製 2D 約束圖, 然後利用約束點在線或圓上的方式, 以圖解法解出有效行程, 如下圖一, 圖二與圖三所示. (圖解法, 利用 Solvespace 既有的約束條件設定完成計算)&lt;/li&gt;
&lt;li&gt;利用 Jupyter 與 Python3 的 sympy 模組, 先進行符號式推導, 然後再利用數值分析解出 piston 的有效行程, 機構各點標示如下圖四所示, &lt;a href="./../data/nutcracker/cadp_nutcracker.ipynb"&gt;計算出&lt;/a&gt;的 theta 轉角為 105.7, 如下圖五所示. (以自行編寫的 sympy 程式解題, 透過 Jupyterhub 可以有效進行協同設計運算)&lt;/li&gt;
&lt;li&gt;除了上述的目測, 圖解與符號式結合數值分析法之外, 也可以採用&lt;a href="./../data/nutcracker/ga_nutcracker1.py"&gt;基因演算法解題&lt;/a&gt;, 計算出的 theta 轉角為 105.7, 如下圖六所示. (利用演化法解題, 可以在單機運算, 也可以在 &lt;a href="./../data/nutcracker//cadp_nutcracker.ipynb"&gt;Jupyterhub 平台&lt;/a&gt;上進行運算)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_solvespace1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖一: 利用 Solvespace 中的繪圖約束條件找出右邊的極限點距離 Onshape Piston 組立原點 0.5&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_solvespace2.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖二: 利用 Solvespace 中的繪圖約束條件找出左邊的極限點距離 Onshape Piston 組立原點 2.23&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_solvespace3.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖三: 當 piston 位於左邊極限點時, AB 轉角為 105.37 度&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_analysis1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖四: Jupyter 計算分析時機構各點標示圖&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_jupyter_result1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖五: 利用 Jupyter 符號式結合數值分析法所得結果&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_ga_result1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖六: 利用基因演算解題, 所得到的結果, 當 piston 位於左邊極限點時, AB 轉角為 105.7 度&lt;/p&gt;
&lt;p&gt;若採用 &lt;a href="https://github.com/deap/deap"&gt;deap&lt;/a&gt; 與 numpy 解題 (AB 轉角極限為 105.71 度):&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# 這裡採用 numpy 與 deap 模組解題, 使用 Genetic Algorithm 模式
# 解的問題為 Nutcracker 左邊 connect 轉角極限
import random
import array
from deap import base
from deap import creator
from deap import tools
import numpy
# for evalIntersect 函式中的 sqrt, sin, cos, pi
from math import *

# 1/4 最小化題目 type of problem
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", array.array, typecode='d', \
               fitness=creator.FitnessMin)
# 2/4 initilization
# 兩個變數題目
NDIM = 2
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, 0, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, NDIM)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# 3/4 選擇 operator step3/4
toolbox.register("select", tools.selRandom, k=3)

# 也可以採用下列設定
#toolbox.register("mate", tools.cxTwoPoint)
#toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.1)
#toolbox.register("select", tools.selTournament, tournsize=3, k=3)

def evalIntersect(individual):
    t = individual[0]
    deg = pi/180
    theta = individual[1]*deg
    xtarget = 0.75/2
    ytarget = 0.5
    x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 \
        + 529)/92 + 3*cos(theta)/2
    y = (-3*t/2 + 123/92)*sin(theta)
    # 適應值
    fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8)

    # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰
    if t &gt; 1:
        fitness_value += 1000
    if t &lt; 0:
        fitness_value += 1000
    # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰
    if theta &gt; 2*pi:
        fitness_value += 1000
    if theta &lt; 0:
        fitness_value += 1000
    return fitness_value,

toolbox.register("evaluate", evalIntersect)
# 以上到 evaluate 為止, 為定義 operators

# 4/4 以下則為 Algorithms
def main():
    # Differential evolution parameters
    CR = 0.25
    F = 1 
    MU = 300
    NGEN = 200   

    pop = toolbox.population(n=MU);
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", numpy.mean)
    stats.register("std", numpy.std)
    stats.register("min", numpy.min)
    stats.register("max", numpy.max)

    # Evaluate the individuals
    fitnesses = toolbox.map(toolbox.evaluate, pop)
    for ind, fit in zip(pop, fitnesses):
        ind.fitness.values = fit

    for g in range(1, NGEN):
        for k, agent in enumerate(pop):
            a,b,c = toolbox.select(pop)
            y = toolbox.clone(agent)
            index = random.randrange(NDIM)
            for i, value in enumerate(agent):
                if i == index or random.random() &lt; CR:
                    y[i] = a[i] + F*(b[i]-c[i])
            y.fitness.values = toolbox.evaluate(y)
            if y.fitness &gt; agent.fitness:
                pop[k] = y
        hof.update(pop)


    print("Best individual is ", hof[0], hof[0].fitness.values[0])

if __name__ == "__main__":
    main()
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;
上述課程資料與 &lt;a href="http://wordpress-2015course.rhcloud.com/?p=4584#more-4584"&gt;Wordpress 網頁&lt;/a&gt;上的資料內容相同, Ｗordpress 網站屬於動態的網誌, 而 &lt;a href="http://chiamingyen.github.io/kmolab/"&gt;http://chiamingyen.github.io/kmolab/&lt;/a&gt; 則是靜態網誌系統, 採用靜態網誌的優點如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較安全&lt;/li&gt;
&lt;li&gt;比較不會過時&lt;/li&gt;
&lt;li&gt;部署成本比較低&lt;/li&gt;
&lt;li&gt;可在各種平台上使用&lt;/li&gt;
&lt;li&gt;各階段改版資料均有紀錄&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下為參考用的 GA 解 Nutcracker 題目的程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#encoding=utf8
# genetic.py
#
import random
import operator
# for Intersect
from math import *
MAXIMIZE, MINIMIZE = 11, 22
class Individual:
    chromosome = None
    score = None
    # Here the size of var depends on var_number
    var = []
    var_number = 2
    for i in range(var_number):
        var.append(0)
    alleles = (0,1)
    # 以下為參數可負數時的編碼考量
    #前10為小數,後10為整數,第21則為正負號
    #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號.
    #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號
    #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號
    # -1023 ~ 1023
    #length = 21*var_number,若接受負數參數,則必須同步修改 20-&gt;21
    length = 20*var_number
    seperator = ''
    optimization = MINIMIZE
    def __init__(self, chromosome=None):
        self.chromosome = chromosome or self._makechromosome()
        self.score = None  # set during evaluation
    def _getvar(self,chromosome=None):
        x = 0
        for i in range(0,self.var_number):
            for j in range(i*20,i*20+10):
                x +=self.chromosome[j]&lt;&lt;(j-(i*20))
            if (x&gt;999):
                x=999
            x/=1000.
            for j in range(i*20+10,i*20+20):
                x +=self.chromosome[j]&lt;&lt;(j-(i*20+10))
            self.var[i] = x
        return self.var
        ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings
#for design variable -1023 ~1023
        for i in range(self.var_number):
            x = 0
            for j in range(i*21,i*21+10):
                x +=self.chromosome[j]&lt;&lt;(j-(i*21))
            if (x&gt;999):
                x=999
            x/=1000.
            for j in range(i*(21)+10,i*(21)+20):
                x +=self.chromosome[j]&lt;&lt;(j-(i*21+10))
            if(self.chromosome[i*(21)+20] == 1):
                self.var[i] = -x
            else:
                self.var[i] = x
            x = 0
        return self.var
        '''
    def _makechromosome(self):
        "makes a chromosome from randomly selected alleles."
        return [random.choice(self.alleles) for gene in range(self.length)]
    def evaluate(self, optimum=None):
        "this method MUST be overridden to evaluate individual fitness score."
        pass
    def crossover(self, other):
        "override this method to use your preferred crossover method."
        return self._twopoint(other)
    def mutate(self, gene):
        "override this method to use your preferred mutation method."
        self._pick(gene)
    # sample mutation method
    def _pick(self, gene):
        "chooses a random allele to replace this gene's allele."
        self.chromosome[gene] = random.choice(self.alleles)
    # sample crossover method
    def _twopoint(self, other):
        "creates offspring via two-point crossover between mates."
        left, right = self._pickpivots()
        def mate(p0, p1):
            chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容
            chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因
            #child = p1.__class__(chromosome) 這是原先的程式,但是應該子代要指向 p0 的內容才對
            child = p0.__class__(chromosome)
            child._repair(p0, p1)
            return child
        return mate(self, other), mate(other, self)
    # some crossover helpers ...
    def _repair(self, parent1, parent2):
        "override this method, if necessary, to fix duplicated genes."
        pass
    def _pickpivots(self):
        left = random.randrange(1, self.length-2)
        right = random.randrange(left, self.length-1)
        return left, right
    #
    # other methods
    #
    def __repr__(self):
        "returns string representation of self"
        '''
        return '&lt;%s chromosome="%s" score=%s var=%s&gt;' % \
               (self.__class__.__name__,
                self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome))
        '''
        return '&lt;%s score=%s var=%s&gt;' % \
               (self.__class__.__name__,self.score,self._getvar(self.chromosome))
    # since the __cmp__ special function is gone  use the __lt__ in stead
    # use the expression (a &gt; b) - (a &lt; b) as the equivalent for cmp(a, b)
    #def __cmp__(self, other):
    # these are for python 3
    def __cmp__(self, other):
        if self.optimization == MINIMIZE:
            #return cmp(self.score, other.score)
            return (self.score &gt; other.score) - (self.score &lt; other.score)
        else: # MAXIMIZE
            #return cmp(other.score, self.score)
            return (other.score &gt; self.score) - (other.score &lt; self.score)

    def __lt__(self, other):
        return self.__cmp__(other) &lt; 0
    def __le__(self, other):
        return self.__cmp__(other) &lt;= 0
    def __gt__(self, other):
        return self.__cmp__(other) &gt; 0
    def __ge__(self, other):
        return self.__cmp__(other) &gt;= 0 
    def copy(self):
        twin = self.__class__(self.chromosome[:])
        twin.score = self.score
        return twin
class Environment(object):
    x = [0]
    y = [0]
    def __init__(self, kind, population=None, size=100, maxgenerations=100,
                 crossover_rate=0.90, mutation_rate=0.07, optimum=None):
        self.kind = kind
        self.size = size
        self.optimum = optimum
        self.population = population or self._makepopulation()
        for individual in self.population:
            individual.evaluate(self.optimum)
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.maxgenerations = maxgenerations
        self.generation = 0
        self.report()
    def _makepopulation(self):
        return [self.kind() for individual in range(self.size)]
    def run(self):
        while not self._goal():
            self.step()
    def _goal(self):
        return self.generation &gt; self.maxgenerations or \
               self.best.score == self.optimum
    def step(self):
        # this sort is not working with python 3.0, modification is needed
        self.population.sort()
        self._crossover()
        self.generation += 1
        self.report()
        self.x.append(self.generation)
        # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值
        if self.best.score &lt;=5:
            self.y.append(self.best.score)
        else:
            self.y.append(5)
    def _crossover(self):
        next_population = [self.best.copy()]
        while len(next_population) &lt; self.size:
            mate1 = self._select()
            if random.random() &lt; self.crossover_rate:
                mate2 = self._select()
                offspring = mate1.crossover(mate2)
            else:
                offspring = [mate1.copy()]
            for individual in offspring:
                self._mutate(individual)
                individual.evaluate(self.optimum)
                next_population.append(individual)
        self.population = next_population[:self.size]
    def _select(self):
        "override this to use your preferred selection method"
        return self._tournament()
    def _mutate(self, individual):
        for gene in range(individual.length):
            if random.random() &lt; self.mutation_rate:
                individual.mutate(gene)
    #
    # sample selection method
    #
    def _tournament(self, size=8, choosebest=0.90):
        competitors = [random.choice(self.population) for i in range(size)]
        competitors.sort()
        if random.random() &lt; choosebest:
            return competitors[0]
        else:
            return random.choice(competitors[1:])
    def best():
        doc = "individual with best fitness score in population."
        def fget(self):
            return self.population[0]
        return locals()
    best = property(**best())
    def report(self):
        print ("="*70)
        print ("generation: ", self.generation)
        print ("best:       ", self.best)

# 以上為 genetic.py 目前將兩者結合在一起
#encoding=utf8
# volume.py - useage example
#
# the fittest individual will have a chromosome consisting of 40 '1's
#
#
#import genetic
#此一加總函式在 volume 最大化中,並未使用
def sum(seq):
    def add(x,y): return x+y
    return reduce(add, seq, 0)
class Volume(Individual):
    optimization = MAXIMIZE
    def evaluate(self, optimum=None):
        SURFACE = 80
        # self.score is the fitness value
        self._getvar(self.chromosome)

        x = self.var[0]
        y = self.var[1]
        z=(SURFACE - x*y)/(2.*(x+y))
        fitness_value = x*y*z

        self.score = fitness_value

    def mutate(self, gene):
        self.chromosome[gene] = not self.chromosome[gene] # bit flip

class Intersect(Individual):
    optimization = MINIMIZE
    def evaluate(self, optimum=None):
        # self.score is the fitness value
        self._getvar(self.chromosome)

        t = self.var[0]
        deg = pi/180
        theta = self.var[1]*deg
        xtarget = 0.75/2
        ytarget = 0.5
        x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2
        y = (-3*t/2 + 123/92)*sin(theta)
        # 適應值
        fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8)

        # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰
        if t &gt; 1:
            fitness_value += 1000
        if t &lt; 0:
            fitness_value += 1000
        # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰
        if theta &gt; 2*pi:
            fitness_value += 1000
        if theta &lt; 0:
            fitness_value += 1000

        self.score = fitness_value

    def mutate(self, gene):
        self.chromosome[gene] = not self.chromosome[gene] # bit flip


if __name__ == "__main__":
    #env = Environment(Volume, size=500, maxgenerations=100)
    env = Environment(Intersect, size=500, maxgenerations=100)
    env.run()
&lt;/pre&gt;</content><category term="電腦輔助設計實習"></category><category term="2015 Fall cadp"></category></entry><entry><title>計算機程式與電腦輔助設計實習</title><link href="./2017fall-cp-cadp.html" rel="alternate"></link><published>2017-07-06T12:00:00+08:00</published><updated>2017-07-06T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:None,2017-07-06:./2017fall-cp-cadp.html</id><summary type="html">&lt;p&gt;以下為 Brython 網際程式環境.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;以下為 Brython 網際程式環境.&lt;/p&gt;


&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;p&gt;投影片:&lt;/p&gt;

&lt;div id="container1"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document, html
container1 = document['container1']
adata = open("./../data/1a_list.txt").read()
alist = adata.splitlines()
n = 0
for stud_num in alist:
    mlink = html.A(stud_num, href="http://s"+str(stud_num)+".github.io/2017springwcm_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container1 &lt;= mlink
&lt;/script&gt;

&lt;!-- 在 blog 中引用圖檔, 只要往外跳一層即可跳出 blog 目錄 --&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src="./../data/logo/kmol_1172x340_blue_3yrs.png" width="300"&gt;&lt;/img&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;a href="./../slides/template_slide.html"&gt;template slide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;測試 LaTex 方程式寫法與轉換:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
$$H\frac{d^{2}\theta (t)}{dt^{2}} = gSin\theta(t)+a_2(t)H-a_1(t)Cos\theta(t)$$
&lt;/pre&gt;

&lt;p&gt;經過轉換成為:&lt;/p&gt;
&lt;p&gt;$$H\frac{d^{2}\theta (t)}{dt^{2}} = gSin\theta(t)+a_2(t)H-a_1(t)Cos\theta(t)$$&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
$$\[L(\mu,\sigma;X)=\sum_i\left[-\frac 1 2 \ln(2\pi)-\ln(\sigma)-\frac{1}{2\sigma^2}(X_i-\mu)^2\right]\]$$
&lt;/pre&gt;

&lt;p&gt;經過轉換成為:&lt;/p&gt;
&lt;p&gt;$$[L(\mu,\sigma;X)=\sum_i\left[-\frac 1 2 \ln(2\pi)-\ln(\sigma)-\frac{1}{2\sigma^2}(X_i-\mu)^2\right]]$$&lt;/p&gt;</content><category term="Final"></category></entry><entry><title>網際內容管理</title><link href="./wcm-course-1.html" rel="alternate"></link><published>2017-06-18T13:00:00+08:00</published><updated>2017-06-18T13:00:00+08:00</updated><author><name>kmol</name></author><id>tag:None,2017-06-18:./wcm-course-1.html</id><summary type="html">&lt;p&gt;網際內容管理課程在教導學生, 利用電腦與網路軟硬體配置, 完成各項與機械設計內容管理有關的任務.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;網際內容管理課程在教導學生, 利用電腦與網路軟硬體配置, 完成各項與機械設計內容管理有關的任務.&lt;/p&gt;


&lt;p&gt;所謂網際指的是 Web-Based, 也就是 World-Wide-Web Based 的簡稱, 中文也可以翻為"植基於全球資訊網" 或 "以全球資訊網為基礎", 其內涵是希望讓使用者在網際網路 (Internet) 的基礎上, 利用 Web Browser (瀏覽器) 操作各種與機械設計內容管理有關的任務.&lt;/p&gt;
&lt;h3&gt;Ubuntu 操作系統&lt;/h3&gt;
&lt;p&gt;根據 https://www.ubuntu.com/info/release-end-of-life 的生命週期年限, 選擇 LTS Server 版本安裝, 安裝過程需要安裝 OpenSSL 模組, 以及 ubuntu-desktop, Windows 客戶端則透過 &lt;a href="https://sourceforge.net/projects/xming/"&gt;xming&lt;/a&gt; 與 &lt;a href="http://www.putty.org/"&gt;http://www.putty.org/&lt;/a&gt; 進行安全的遠端登入.&lt;/p&gt;
&lt;h3&gt;IPv4 與 IPv6 網路設定&lt;/h3&gt;
&lt;p&gt;一般來說, 只有必須擔負特定 WWW Server、DNS Server 與 Proxy Server 的主機需要同時支援 IPv4 與 IPv6 網路協定外, 其餘客戶端都可以只透過 IPv6 網路協定上網.&lt;/p&gt;
&lt;p&gt;WWW Server 使用 Nginx, DNS Serve 使用 Bind, 而 Proxy Server 則使用 Squid.&lt;/p&gt;
&lt;h3&gt;Nginx&lt;/h3&gt;
&lt;p&gt;Nginx WWW 伺服器通常用來伺服靜態文件或者作為其他近端伺服資料傳送的代理主機 (例如, uwsgi 網際服務).&lt;/p&gt;
&lt;h3&gt;Ethercalc&lt;/h3&gt;
&lt;p&gt;Ethercalc 允許多人利用瀏覽器同時維護一份線上試算表, 可以用於協同資料永久存檔前的轉介站.&lt;/p&gt;
&lt;h3&gt;Fossil SCM&lt;/h3&gt;
&lt;p&gt;Fossil SCM 是一套小而美的分散式資料管理系統&lt;/p&gt;
&lt;h3&gt;Squid Proxy Server&lt;/h3&gt;
&lt;p&gt;在 IPv4 轉換到 IPv6 的過程中, 雙網路協定支援的代理主機扮演非常重要的角色, 例如, 從純 IPv4 瀏覽器連線到純 IPv6 WWW 伺服器, 就需要透過雙網路協定的代理主機轉介資料, 其次 putty ssh 遠端登入或 sftp 安全資料傳送, 也都需要雙網路支援的代理主機居中轉換不同協定資料.&lt;/p&gt;
&lt;h3&gt;X-windows&lt;/h3&gt;
&lt;h3&gt;Putty&lt;/h3&gt;
&lt;h3&gt;Leo Editor&lt;/h3&gt;
&lt;h3&gt;Filezilla 與 SFTP&lt;/h3&gt;
&lt;h3&gt;Uwsgi 與 CMSimfly&lt;/h3&gt;</content><category term="網際內容管理"></category><category term="課程"></category></entry><entry><title>協同產品設計實習</title><link href="./cd-course-1.html" rel="alternate"></link><published>2017-06-18T12:00:00+08:00</published><updated>2017-06-18T12:00:00+08:00</updated><author><name>kmol</name></author><id>tag:None,2017-06-18:./cd-course-1.html</id><summary type="html">&lt;p&gt;協同產品設計課程在教導學生, 以同步或非同步協同方式, 利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;協同產品設計課程在教導學生, 以同步或非同步協同方式, 利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.&lt;/p&gt;
</content><category term="協同產品設計實習"></category><category term="課程"></category></entry><entry><title>電腦輔助設計實習</title><link href="./cadp-course-1.html" rel="alternate"></link><published>2017-06-18T11:00:00+08:00</published><updated>2017-06-18T11:00:00+08:00</updated><author><name>kmol</name></author><id>tag:None,2017-06-18:./cadp-course-1.html</id><summary type="html">&lt;p&gt;電腦輔助設計課程在教導學生利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;電腦輔助設計課程在教導學生利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.&lt;/p&gt;


&lt;p&gt;CAD Book: &lt;a href="http://mde.tw/2016fallcadp/data/CAD_book.pdf"&gt;http://mde.tw/2016fallcadp/data/CAD_book.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://link.springer.com/content/pdf/10.1007%2F978-3-319-03862-9.pdf"&gt;Space Modeling with SolidWorks and NX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://beyondplm.com/2015/03/18/autodesk-and-onshape-disagree-about-cloud-technology-and-focus/"&gt;http://beyondplm.com/2015/03/18/autodesk-and-onshape-disagree-about-cloud-technology-and-focus/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.solidsmack.com/cad/onshape-comes-out-swinging-changes-mcad-pricing-forever/"&gt;https://www.solidsmack.com/cad/onshape-comes-out-swinging-changes-mcad-pricing-forever/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://newscrewdriver.com/category/3d-printing/3d-printing-software/fusion-360-vs-onshape/"&gt;https://newscrewdriver.com/category/3d-printing/3d-printing-software/fusion-360-vs-onshape/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;eBook: State of Product Development / PLM 2016&lt;/p&gt;
&lt;p&gt;&lt;a href="http://image.engineering.com/239575/articles/Nov%202016/Autodesk%20Q615/Autodesk_pdf1R.pdf"&gt;http://image.engineering.com/239575/articles/Nov%202016/Autodesk%20Q615/Autodesk_pdf1R.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CADO: &lt;a href="https://github.com/BGCECSE2015/CADO"&gt;https://github.com/BGCECSE2015/CADO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Electronics made easy: &lt;a href="http://fritzing.org/home/"&gt;http://fritzing.org/home/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SFEPy: &lt;a href="https://github.com/sfepy/sfepy"&gt;https://github.com/sfepy/sfepy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://nbviewer.jupyter.org/github/sukhbinder/sfepy-simple_tutorial/blob/master/Getting_Started_With_SFEPY_using_a_simpleplate_example.ipynb"&gt;http://nbviewer.jupyter.org/github/sukhbinder/sfepy-simple_tutorial/blob/master/Getting_Started_With_SFEPY_using_a_simpleplate_example.ipynb&lt;/a&gt;&lt;/p&gt;</content><category term="電腦輔助設計實習"></category><category term="課程"></category></entry><entry><title>計算機程式</title><link href="./cp-course-1.html" rel="alternate"></link><published>2017-06-12T11:00:00+08:00</published><updated>2017-06-12T11:00:00+08:00</updated><author><name>kmol</name></author><id>tag:None,2017-06-12:./cp-course-1.html</id><summary type="html">&lt;p&gt;計算機程式課程在教導學生利用電腦完成各項與機械設計流程有關的任務.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;計算機程式課程在教導學生利用電腦完成各項與機械設計流程有關的任務.&lt;/p&gt;


&lt;h3&gt;為什麼非學不可?&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://cacm.acm.org/blogs/blog-cacm/166115-why-scientists-and-engineers-must-learn-programming/fulltext"&gt;https://cacm.acm.org/blogs/blog-cacm/166115-why-scientists-and-engineers-must-learn-programming/fulltext&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先, 看看機械設計流程會牽涉哪些任務, 所謂機械設計, 就是歷經詳細思慮考量, 完成互動元件間之精巧配置, 使其展現特定功能之具體規劃表達.&lt;/p&gt;
&lt;p&gt;換言之, 機械設計是一種具體規劃的表達 (presentation), 其內容是經過一系列詳細的思慮與考量所得到的結果, 而此項結果通常有具體的功能, 並且包含許多互動 (interaction) 元件之間的彈性與精巧配置 (flexible and sophisticated configuration).&lt;/p&gt;
&lt;p&gt;我們將上述與機械設計有關的關鍵字引列如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;機械設計是一種表達, 此種表達可以利用文字、口語、2D 靜態圖像、3D 或影音動態圖像、理論分析或實體呈現.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;機械設計的過程所需要的各種思慮與考量牽涉許多定性與定量的分析, 包含許多工程原理原則與實務經驗, 這些分析除了必須利用數學建立模型, 透過演算預先模擬外, 還需要使用有效率可協同的方式紀錄過程中所產生的各種資料.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;機械設計產品中所包含的各種互動元件, 包括硬體元件、流體元件、軟體元件與管理元件等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;機械設計過程中, 為了在實體化之前能預先針對各種互動元件間的組成與配置進行最佳化, 因此需要使用各種逼真的模擬方法加以呈現.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;如何進行文字、2D&amp;amp;3D表達&lt;/h3&gt;
&lt;p&gt;有沒有一種方法可以讓多名使用者協同管理一份文件, 其中包含各種互動式圖文與影音資料, 各使用者在編修內容過程可以有效對資料進行保全, 可以有效分散備份, 可以紀錄各編修者所增刪的內容, 可以透過有效率的方法散佈此份文件的內容?&lt;/p&gt;
&lt;h3&gt;使用工具的評量方法&lt;/h3&gt;
&lt;p&gt;機械設計工程師為了有效完成具體規劃內容的表達, 過程中必須使用各種類型的工具, 其中包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文字資料構建、管理與呈現的工具 (text)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2  口語資料構建、管理與呈現的工具 (oral)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;2D 靜態圖像資料構建、管理與呈現的工具 (2d)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3D 或影音動態圖像資料構建、管理與呈現的工具 (3d)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理論分析資料構建、管理與呈現的工具 (analytical)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;實體構建、管理與呈現的工具 (physical)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;工具取得、維護使用成本與其他工具整合效能成本等&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;工具取得成本 (now and how)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;維護更新與永續使用成本 (update and sustainable)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工具掌握度與整合效能成本 (integration)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;一定要學 C&lt;/h3&gt;
&lt;p&gt;C 是為建立 Unix 操作系統而生的程式語言, 也是近代許多高階程式語言建構的基礎, 例如, 最早的 C 程式編譯器雖然採用組合語言編寫, 但是隨後的 C 程式編譯器則可以採用舊版的 C 來編譯, 而 Python 解譯器在 1980 年代晚期出現時, 就是以 C 程式編寫, 之後雖然有採用 Java 編寫的 Jython (2001), 以 C# 編寫的 IronPython (2006), 以 RPython 編寫的 PyPy (2007), 以 Javascript 編寫的 Brython (2012), 但是 CPython 仍然是最通用的版本.&lt;/p&gt;
&lt;p&gt;儘管 C 程式語言對於工程師而言非常重要, 但是 C 或更進階的 C++ 程式語言的學習並不容易, 並不只是因為 C/C++ 擁有指標, 能夠控制電腦的底層記憶體, 而是因為 C/C++ 程式語言所涵蓋的應用非常廣.&lt;/p&gt;
&lt;p&gt;但是無論如何, 工程師一定要學會基本的  C 程式語言, 倒是毋庸置疑.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.asme.org/career-education/articles/teachers-academics/c-as-part-of-a-mechanical-engineering-curriculum"&gt;https://www.asme.org/career-education/articles/teachers-academics/c-as-part-of-a-mechanical-engineering-curriculum&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;C 的指標與陣列導引&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html"&gt;http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;CP to CADP&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/2015fallhw/cptocadp"&gt;https://github.com/2015fallhw/cptocadp&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;如何完成下列工作?&lt;/h3&gt;
&lt;p&gt;1) 從一本英文書的文字檔中, 算出總字數, 並按照英文字母排列, 列出書中所使用的單字, 並查出各單字的中文解釋.&lt;/p&gt;
&lt;p&gt;2) 從網站中擷取當天台幣與美金及英鎊的匯率, 並根據某一列有台幣、美金與英鎊的檔案進行各幣值的總結算.&lt;/p&gt;
&lt;p&gt;3) 每組有六人, 某一任務需要完成六項工作, 每人負責一項, 但各工作間必須互相配合, 任務進行中需要完整呈現各組員每一階段所完成的內容細節, 請問該如何完成.&lt;/p&gt;
&lt;p&gt;例如: &lt;/p&gt;
&lt;p&gt;3 1 + 2 / 各數字與符號隔開, 表示 3 + 1 / 2&lt;/p&gt;
&lt;p&gt;2 3 4 + 4 * 7 / 答案為?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/dustinrohde/python-rpn"&gt;https://github.com/dustinrohde/python-rpn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4) 如何將材料特性 2D 圖表轉為電腦可以套用的文字檔或資料庫檔案?&lt;/p&gt;
&lt;p&gt;漸開線正齒輪齒面寬運算 - 選擇正齒輪對所要傳遞的功率大小, 選擇所要使用的正齒輪齒數、模數與壓力角, 選擇齒輪的材質, 選擇小齒輪的齒數, 選擇安全係數, 從上述資料中算出齒輪齒面寬, 以便能在安全的範圍中, 不致產生過大噪音條件下完成所需功率的傳遞.&lt;/p&gt;
&lt;p&gt;漸開線正齒輪&lt;/p&gt;
&lt;p&gt;功率&lt;/p&gt;
&lt;p&gt;齒數、模數與壓力角&lt;/p&gt;
&lt;p&gt;齒輪的材質與強度&lt;/p&gt;
&lt;p&gt;安全係數&lt;/p&gt;
&lt;p&gt;振動與噪音&lt;/p&gt;
&lt;p&gt;齒輪的鍵銷設計&lt;/p&gt;
&lt;p&gt;齒輪的軸尺寸、強度與耐用度設計&lt;/p&gt;
&lt;p&gt;軸承的選用設計&lt;/p&gt;
&lt;p&gt;齒輪箱的設計&lt;/p&gt;
&lt;p&gt;齒輪的潤滑與散熱設計&lt;/p&gt;
&lt;p&gt;其他相關的設計分析、製造規劃與後勤維修等議題&lt;/p&gt;
&lt;p&gt;5) 文字檔與數位檔案的差別與運用, 各種 2D 與 3D 零組件檔格式的讀取與轉換&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/AutoCAD_DXF"&gt;https://en.wikipedia.org/wiki/AutoCAD_DXF&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf"&gt;http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASCII DXF File Format&lt;/p&gt;
&lt;p&gt;Binary DXF File Format&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/STL_(file_format)"&gt;https://en.wikipedia.org/wiki/STL_(file_format)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.fabbers.com/tech/STL_Format"&gt;http://www.fabbers.com/tech/STL_Format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASCII STL File Format&lt;/p&gt;
&lt;p&gt;Binary STL File Format&lt;/p&gt;
&lt;p&gt;IGES Version 5.3: &lt;a href="http://paulbourke.net/dataformats/iges/IGES.pdf"&gt;http://paulbourke.net/dataformats/iges/IGES.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IGES Version 6: &lt;a href="https://filemonger.com/specs/igs/devdept.com/version6.pdf"&gt;https://filemonger.com/specs/igs/devdept.com/version6.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/IGES"&gt;https://en.wikipedia.org/wiki/IGES&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DXF, IGES and STEP: &lt;a href="http://homepages.cae.wisc.edu/~me232/info/dxf_iges_step.pdf"&gt;http://homepages.cae.wisc.edu/~me232/info/dxf_iges_step.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Python3 學習&lt;/h3&gt;
&lt;p&gt;Official Tutorial: &lt;a href="https://docs.python.org/3/tutorial/"&gt;https://docs.python.org/3/tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.stavros.io/tutorials/python/"&gt; 10 min Python Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;help(), dir(), print(), &lt;a href="https://docs.python.org/3/tutorial/controlflow.html#the-range-function"&gt;range()&lt;/a&gt;, &lt;a href="https://docs.python.org/3/library/stdtypes.html"&gt;built-in types&lt;/a&gt;,&lt;/p&gt;
&lt;p&gt;看影片自學: &lt;a href="https://www.youtube.com/watch?v=D48iCw3WWpI"&gt;https://www.youtube.com/watch?v=D48iCw3WWpI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.spronck.net/pythonbook"&gt;http://www.spronck.net/pythonbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coodict/python3-in-one-pic/blob/master/notebooks/py3-in-one-pic.ipynb"&gt;https://github.com/coodict/python3-in-one-pic/blob/master/notebooks/py3-in-one-pic.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;資料分析: &lt;a href="https://lectures.quantecon.org/py/"&gt;https://lectures.quantecon.org/py/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Python 很慢?&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=8hHOxfXcWsg"&gt;https://www.youtube.com/watch?v=8hHOxfXcWsg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=a8LsdodGoWQ"&gt;https://www.youtube.com/watch?v=a8LsdodGoWQ&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;PyQT&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://kuanyui.github.io/2014/09/13/learn-python-via-pyqt/"&gt;https://kuanyui.github.io/2014/09/13/learn-python-via-pyqt/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;網際程式繪圖&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://2015fallhw.github.io/2015fallcpa/g99_w15.html"http://2015fallhw.github.io/2015fallcpa/g99_w15.html&lt;/a&gt;&lt;/p&gt;</content><category term="計算機程式"></category><category term="課程"></category></entry></feed>