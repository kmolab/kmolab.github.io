<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計工程系 KMOLab - Research</title><link href="https://kmolab.github.io/blog/" rel="alternate"></link><link href="https://kmolab.github.io/blog/feeds/research.atom.xml" rel="self"></link><id>https://kmolab.github.io/blog/</id><updated>2017-10-01T11:00:00+08:00</updated><entry><title>CMSimfly 與 Fossil SCM</title><link href="https://kmolab.github.io/blog/cmsimfly-and-fossil-on-same-machine.html" rel="alternate"></link><published>2017-10-01T11:00:00+08:00</published><updated>2017-10-01T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-10-01:/blog/cmsimfly-and-fossil-on-same-machine.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/chiamingyen/cmsimfly"&gt;CMSimfly&lt;/a&gt; 是一套採用 Flask 應用程式框架編寫的網際內容管理系統 (Content Management System),  &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 則是以 ANSI C 編寫的軟體組態管理 (Software Configuration Management) 系統, 兩套程式各有不同的特色, CMSimfly 適合用來管理無版次的大型檔案, 而 Fossil SCM 則可用來記錄詳細的軟體設計開發歷程.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/chiamingyen/cmsimfly"&gt;CMSimfly&lt;/a&gt; 是一套採用 Flask 應用程式框架編寫的網際內容管理系統 (Content Management System),  &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 則是以 ANSI C 編寫的軟體組態管理 (Software Configuration Management) 系統, 兩套程式各有不同的特色, CMSimfly 適合用來管理無版次的大型檔案, 而 Fossil SCM 則可用來記錄詳細的軟體設計開發歷程.&lt;/p&gt;


&lt;h2&gt;CMSimfly 與 Fossil SCM 安裝規劃&lt;/h2&gt;
&lt;p&gt;CMSimfly 採用 Python3 與 Flask 編寫, 可以採用 &lt;a href="https://github.com/unbit/uwsgi"&gt;uwsgi&lt;/a&gt; 模組啟動, 預計網際前端透過 Nginx https 埠號 8443 承接來自瀏覽器的請求, 而 Fossil SCM 的 http port 80 前端則由 Nginx 承接後, 直接跳轉 Stunnel 所代理的 https 服務. 因此當使用者以瀏覽器 http 連線, 伺服器會馬上跳轉 https 的 Fossil SCM, 假如要連結 CMSimfly, 則必須以 https 8443 連線.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/unbit/uwsgi"&gt;uwsgi&lt;/a&gt; 有多種啟動方式, 在此希望透過 Emperor 的多應用程式的模式啟動, 基本架構是,  uwsgi 指令在 /etc/rc.local 中以 exec 執行, 可以在伺服器開機時執行, 而 uwsgi Emperor  中指定以一般用戶身分執行, 實際封包在內部網路的 8081 啟動, 之後透過 /etc/nginx/sites-available/default 中的 server 設定, 只接受 8443 埠號的 IPv4 與 IPv6 網際瀏覽器請求.&lt;/p&gt;
&lt;h2&gt;CMSimfly 安裝設定&lt;/h2&gt;
&lt;p&gt;根據 uwsgi 與 Emperor 的啟動, 伺服器所需模組, 包括 pip3, Flask, python3 開發環境, uwsgi, nginx 與 uwsgi-plugin-python3 模組:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
sudo apt install python3-pip
sudo pip3 install Flask
sudo apt install build-essential python3-dev
sudo pip3 install uwsgi
sudo apt install nginx uwsgi-plugin-python3
&lt;/pre&gt;

&lt;p&gt;而 /etc/nginx/sites-available/default 的設定&lt;/p&gt;
&lt;pre class="brush:python"&gt;
server {
    listen 80 default_server;
    listen [::]:80 default_server;

    server_name _;
        return 301 https://my.server.host.name;
}

server {
    listen 8443 ssl;
    listen [::]:8443 ssl;

    location /static {
        alias /home/user/cmsimfly/static/;
    }

    location / {
        include uwsgi_params;
        uwsgi_pass  127.0.0.1:8081;
    }

    server_name my.server.host.name;
    ssl on;
    ssl_certificate /etc/nginx/ssl/nginx.crt;
    ssl_certificate_key /etc/nginx/ssl/nginx.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}
&lt;/pre&gt;

&lt;p&gt;位於 /home/user/uwsgi_ini/ 目錄下的 uwsgi.ini 檔案設定:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
[uwsgi]
socket = 127.0.0.1:8081 
uid = user
gid = user
plugins-dir = /usr/lib/uwsgi/plugins/
plugin = python3
master = true
process = 4
threads = 2
chdir = /home/user/cmsimfly
wsgi-file = /home/user/cmsimfly/wsgi.py
&lt;/pre&gt;

&lt;p&gt;假如希望額外啟動其他的 uwsgi 程式, 例如第二組 CMSimfly 或其他對應的 Flask 應用程式, 則需要在 /etc/nginx/sites-available/default 增加另外一組 server 設定, 主要在選定內部網路的特定埠號, 例如: 127.0.0.1:8082, 編寫 default 設定檔案成為:&lt;/p&gt;
&lt;pre class="brush:python"&gt;
server {
    listen 80 default_server;
    listen [::]:80 default_server;

    server_name _;
        return 301 https://my.server.host.name;
}

server {
    listen 8443 ssl;
    listen [::]:8443 ssl;

    location /static {
        alias /home/user/cmsimfly/static/;
    }

    location / {
        include uwsgi_params;
        uwsgi_pass  127.0.0.1:8081;
    }

    server_name my.server.host.name;
    ssl on;
    ssl_certificate /etc/nginx/ssl/nginx.crt;
    ssl_certificate_key /etc/nginx/ssl/nginx.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}

server {
    listen 9443 ssl;
    listen [::]:9443 ssl;

    location /static {
        alias /home/user/cmsimfly2/static/;
    }

    location / {
        include uwsgi_params;
        uwsgi_pass  127.0.0.1:8082;
    }

    server_name my.server.host.name;
    ssl on;
    ssl_certificate /etc/nginx/ssl/nginx.crt;
    ssl_certificate_key /etc/nginx/ssl/nginx.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}
&lt;/pre&gt;

&lt;p&gt;然後在 /home/user/uwsgi_ini 目錄中, 再配合增加一組 uwsgi2.ini, 內容為:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
[uwsgi]
socket = 127.0.0.1:8082
uid = user
gid = user
plugins-dir = /usr/lib/uwsgi/plugins/
plugin = python3
process = 4
threads = 2
chdir = /home/user/cmsimfly2
wsgi-file = /home/user/cmsimfly2/wsgi.py
&lt;/pre&gt;

&lt;p&gt;/etc/nginx/sites-available/default 與 /home/user/uwsgi_ini/uwsgi2.ini 設定修改後, 只要透過 /etc/init.d/nginx restart 重新啟動 Nginx, 並且重新執行 uwsgi 指令, 意即, uwsgi --emperor /home/user/uwsgi_ini, 納入 /home/user/uwsgi_ini/uwsgi.ini 與 /home/user/uwsgi_ini/uwsgi2.ini 的多 uwsgi Emperor 架構應用程式即可在 https://my.sever.host.name:9443 多一組 CMSimply 網際內容管理的伺服.&lt;/p&gt;
&lt;p&gt;若要讓伺服器在開機時執行 uwsgi, 則需要在/etc/rc.local 加入:&lt;/p&gt;
&lt;p&gt;exec uwsgi --emperor /home/user/uwsgi_ini&lt;/p&gt;
&lt;p&gt;過程中若需要重新啟動 nginx, 以 /etc/init.d/nginx restart 執行.&lt;/p&gt;
&lt;h2&gt;Fossil SCM 與 Stunnel 聯合啟動&lt;/h2&gt;
&lt;p&gt;因為在 Nginx /etc/nginx/sites-available/default 中已經將 port 80 的回應處理直接透過 http 301 狀態碼的宣告, 永久轉接到 https://my.server.host.name, 因此只要透過 Stunnel 代理在標準的 IPv4 與 IPv6 網路協定中, 以 https 啟動 Fossil SCM 即可.&lt;/p&gt;
&lt;p&gt;首先要安裝 Stunnel 與 Fossil SCM:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
sudo apt update
sudo apt install stunnel4 -y
sudo apt install fossil
&lt;/pre&gt;

&lt;p&gt;讓 Stunnel 開機時啟動:&lt;/p&gt;
&lt;p&gt;/etc/default/stunnel4 檔案設定, 將原先內定的 ENABLED=0 改為 1:&lt;/p&gt;
&lt;p&gt;ENABLED=1&lt;/p&gt;
&lt;p&gt;因為要以 https 設定 /etc/stunnel/stunnel.conf, 因此 /etc/stunnel 目錄中需要 stunnel.crt 與 stunnel.key.&lt;/p&gt;
&lt;p&gt;在 /etc/stunnel 目錄中執行 openssl 指令:&lt;/p&gt;
&lt;p&gt;sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout stunnel.key -out stunnel.crt&lt;/p&gt;
&lt;p&gt;然後設定 /etc/stunnel/stunnel.conf:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
[https]
accept = your.ipv4.ip:443
accept = :::443
cert = /etc/stunnel/localhost.crt
key = /etc/stunnel/localhost.key
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/user/ --https --nojail --notfound default
&lt;/pre&gt;

&lt;p&gt;重新啟動 stunnel 時, 執行 /etc/init.d/stunnel4&lt;/p&gt;</content><category term="2017fall"></category></entry><entry><title>2017 Fall 主機設定</title><link href="https://kmolab.github.io/blog/2017fall-srver-setup.html" rel="alternate"></link><published>2017-09-16T12:00:00+08:00</published><updated>2017-09-16T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-09-16:/blog/2017fall-srver-setup.html</id><summary type="html">&lt;p&gt;在 2017 年 Spring, 電腦輔助設計室購入兩台 HP 伺服器, 分別是 &lt;a href="https://www.hpe.com/h20195/v2/GetPDF.aspx/c04922941.pdf"&gt;HPE ProLiant ML10 Gen9 Server&lt;/a&gt; 與 &lt;a href="https://www.hpe.com/h20195/v2/getpdf.aspx/c04375628.pdf"&gt;HPE ProLiant ML350 Gen9 Server&lt;/a&gt;, 操作系統為 Ubuntu 16.04, 根據 &lt;a href="https://www.ubuntu.com/info/release-end-of-life"&gt;Ubuntu LTS 通告&lt;/a&gt;, 使用週期可至 2021 年, 預計在 2019 年 Spring 由新伺服器接手提供服務.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;在 2017 年 Spring, 電腦輔助設計室購入兩台 HP 伺服器, 分別是 &lt;a href="https://www.hpe.com/h20195/v2/GetPDF.aspx/c04922941.pdf"&gt;HPE ProLiant ML10 Gen9 Server&lt;/a&gt; 與 &lt;a href="https://www.hpe.com/h20195/v2/getpdf.aspx/c04375628.pdf"&gt;HPE ProLiant ML350 Gen9 Server&lt;/a&gt;, 操作系統為 Ubuntu 16.04, 根據 &lt;a href="https://www.ubuntu.com/info/release-end-of-life"&gt;Ubuntu LTS 通告&lt;/a&gt;, 使用週期可至 2021 年, 預計在 2019 年 Spring 由新伺服器接手提供服務.&lt;/p&gt;


&lt;h2&gt;近端、區網與雲端其實是同一端&lt;/h2&gt;
&lt;p&gt;自 2017 年 10 月起, 已經沒有免費的 OpenShift 雲端服務可以使用, 遠端較穩定的 html + javascript hosting 只剩下 Github Pages, 但是就課程與研究所需的近端、區網與雲端上的各項服務而言, 雲端的免費套餐終將越來越縮水的情況下, 強化近端與區網上的軟硬體服務, 將會更加重要.&lt;/p&gt;
&lt;p&gt;這個學期工作站室的伺服器, 將全面使用 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 管理所有的課程與研究專案, 每一位上課的學員都將在近端與區網擁有一個 Fossil 倉儲, 用來存放與課程相關的所有內容.&lt;/p&gt;
&lt;p&gt;Github 與 Bitbuckert 等雲端免費方案仍然扮演重要角色, 只是在無廣域網路連線與區域網路連線的情況下, 各學員的各項課程內容演練與操作資料提交, 將能在隨身的可攜系統上完成, 之後再配合區網與雲端網路的連線, 設法在分組協同的模式下, 將近端資料同步到區網與雲端主機. 因此 2017 Fall 起, 如何在近端、區網與雲端不同硬體環境下, 保持倉儲資料版本的同步, 就是另外一個重點.&lt;/p&gt;
&lt;h2&gt;主機設定&lt;/h2&gt;
&lt;p&gt;接下來, 我們透過 &lt;a href="https://cadpb.kmol.info/40523201"&gt;https://cadpb.kmol.info/40523201&lt;/a&gt; 學員倉儲, 來說明提供 Fossil SCM 服務的主機如何設定.&lt;/p&gt;
&lt;p&gt;首先當然是要先掌握 kmol.info 網域的主導權, 透過網域 DNS 的控管, 讓區域網路中的主機可以在 A 與 AAA 設定下的 IPv4 與 IPv6 網址呼應, 例如: cadpb.kmol.info 指的就是 cadp 電腦輔助設計實習課程中的 b 班所使用的伺服器名稱.&lt;/p&gt;
&lt;p&gt;如前所述, 這些伺服器都是安裝 Ubuntu 16.04 Server 操作系統 + OpenSSH, 目的是希望在 Self-signed Certificate 的模式下運作.&lt;/p&gt;
&lt;p&gt;接著必須根據 &lt;a href="create-a-multi-repository-fossil-scm-server.html"&gt;多 Fossil SCM 倉儲主機&lt;/a&gt; 的架構, 分別安裝 Fossil SCM 與 Stunnel.&lt;/p&gt;
&lt;p&gt;其中, 特別將 Fossil SCM 伺服的目錄指向 /home/cadpa2017, 表示各操作系統帳號所有人, 可以自行利用 fossil 指令, 建立多個倉儲, 此一模式就是同一台主機可以透過網域來界定上課班級, 操作系統帳號可以界定大分組名稱, 而採用學號的倉儲名稱則可以用來界定參與協同的所有者.&lt;/p&gt;
&lt;p&gt;因此, 一旦各倉儲所有者掌握管理該 .fossil 檔案的總管理權之後, 可以將其他學員納入自己所掌控的 .fossil users 中, 視實際需求賦於各帳號不同權限. 且可透過制式的 URL, 在得知各班各分組的成員學號情況下, 連結至各學員的倉儲中進行資料檢視.&lt;/p&gt;
&lt;h2&gt;機械設計專案的資料格式&lt;/h2&gt;
&lt;p&gt;由於設計是一種利用口語、文字、2D、3D、數學與實體等形式, 所完成的明確與具體表達, 過程中必須仔細思考、多方考量, 而且在不同時段與多人協同合作的結果, 將會產生許多不同的資料版本.&lt;/p&gt;
&lt;p&gt;加上二十一世紀的機械可說是各種固體、流體與軟體元件精巧組合而成, 能達成特定功能之器物. 因此機械設計專案過程所產生的各種資料及版本, 更需要特別關注並竭力保存, 以便讓新舊學員在自學、執行與想像的創造力發揮階段, 擁有可持續改進的工具之外, 也能有保有多元開放的完整學習資料.&lt;/p&gt;
&lt;p&gt;在這樣對於機械設計表達、內容物與創造流程的認知下, 我們會希望學員在口語表達階段除了錄音之外, 能夠利用 Reveal.js 投影片寫下文字資料, 能儘量採用開放的設計格式, 在 Fossil SCM 倉儲中保留可以持續追蹤的文字資料格式, 2D/3D 的末端二位元檔案, 並非版次管理系統所關注並保留的重點, 學員該紀錄的是, 各種末端檔案是在何種情況下, 根據哪些約束條件, 用甚麼方法產生, 隨後的使用者在檢視歷史資料的同時, 應該可以根據這些較能持續改進的文字資料, 配合不同的情況, 使用不同的工具, 建立其所需的二位元末端檔案.&lt;/p&gt;
&lt;p&gt;換言之, 一個多元開放的機械設計專案, 在導入各種軟硬體組態管理的時間點, 必須全面檢視所用的工具, 所處的環境, 盡量採用能持續改進的專案資料格式, 而非只儲存不知前因與狀況下所產生的封閉格式檔案.&lt;/p&gt;
&lt;h2&gt;文字、大綱與程式&lt;/h2&gt;
&lt;p&gt;當上述 Fossil SCM 主機的設定, 可以讓各學員個別管理 .fossil 倉儲檔案之後, 
利用瀏覽器介面可以控管 users, 可以利用  wiki 建立快寫網頁, 可以將各種影片檔案以 attach 方式附加在 wiki 頁面中, 也可以在專案進行過程利用 tickets 追蹤設計問題, 並在專案階段性任務完成時, 以 technote 紀錄成果.&lt;/p&gt;
&lt;p&gt;除了利用瀏覽器介面維護的協同內容之外, 機械設計過程中採 Pelican Blog 紀錄的網誌, 採 Reveal.js 格式的簡報網頁, 以及各種計算機程式檔案, 則必須在文字、大綱與程式架構下來進行管理.&lt;/p&gt;
&lt;p&gt;在此我們所採用的管理工具為 Leo Editor, SciTE 與 Eric6.&lt;/p&gt;
&lt;p&gt;Leo Editor 是一套採用 Python3 + PyQt5 所編寫的大綱管理套件, 其任務是負責利用大綱架構管理鬆散的 Pelican Blog, 並且利用 button 執行操作系統指令, 還肩負透過 Python3 程式碼所組成的 button, 在近端啟動 IPv4 與 IPv6 WWW 伺服模擬環境, 能讓學員在近端檢視所有之後要推送到區網與雲端中的網誌與投影片內容.&lt;/p&gt;
&lt;p&gt;SciTE 則提供文字編輯以及 Python3 與 ANSI C 程式執行環境, 而 Eric6 則用於 PyQt5 程式的開發.&lt;/p&gt;
&lt;h2&gt;純 IPv6 主機設定&lt;/h2&gt;
&lt;p&gt;目前在系主幹上的電腦已經可以選擇透過 IPv6 DHCP 或自行設定 IPv6 位址連線上網. &lt;/p&gt;
&lt;p&gt;在安裝  Ubuntu 16.04 Server 時, 選擇安裝 OpenSSH 模組, 之後則必須透過 IPv4/IPv6 雙支援的 Squid Proxy Server 才可以利用 apt 維護系統所安裝的套件.&lt;/p&gt;
&lt;p&gt;apt Proxy 的設定必須在 /etc/apt/atp.conf 中納入:&lt;/p&gt;
&lt;p&gt;Acquire::http::Proxy "http://[2001:288:6004:17::87]:3128";&lt;/p&gt;
&lt;p&gt;直接存檔後, apt 指令就可以透過 Proxy Server 連接到只支援 IPv4 網路協定的電腦.&lt;/p&gt;
&lt;p&gt;Ubuntu Server 安裝後, 若希望安裝 ubuntu-desktop:&lt;/p&gt;
&lt;p&gt;sudo apt install ubuntu-desktop&lt;/p&gt;
&lt;p&gt;接著必須在 Firefox 瀏覽中設定 Proxy Server 代理主機, 否則無法連到只支援 IPv4 網路協定的網站. 其中 Firefox 的 Proxy Server 設定, Proxy Server 的 IPv6 網址無需中括號.&lt;/p&gt;
&lt;p&gt;其次若希望採用自訂的 IPv6 網路設定, 可以修改 /etc/network/interfaces 檔案&lt;/p&gt;
&lt;p&gt;啟用 inet6 static or auto &lt;/p&gt;
&lt;pre class="brush: python"&gt;
address 2001... 
netmask 64 
gateway 2001... 
dns-nameservers 2001:b000:168::1
&lt;/pre&gt;

&lt;p&gt;最後則安裝設定中文輸入法:&lt;/p&gt;
&lt;p&gt;sudo apt install fcitx fcitx-chewing&lt;/p&gt;
&lt;p&gt;然後修改系統的 language support 將輸入法改為 fcitx 設定後, 必須登出再登入, 讓設定生效, input method 則選擇 chewing.&lt;/p&gt;
&lt;h2&gt;各階段設定檔案&lt;/h2&gt;
&lt;p&gt;Stunnel 的設定, 目的在與 Fossil SCM 結合, 提供 https 的連線代理.&lt;/p&gt;
&lt;p&gt;/etc/stunnel/stunnel.conf&lt;/p&gt;
&lt;pre class="brush: python"&gt;
[https]
accept = your_IPv4_ip:443
accept = :::443
cert = /etc/stunnel/localhost.crt
key = /etc/stunnel/localhost.key
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/ --https --nojail --notfound user/default
&lt;/pre&gt;

&lt;p&gt;因為 Fossil SCM 加上 Stunnel 設定時, 已經將連線協定設為 HTTPS, 因此 http 伺服則交由 nginx 回應:&lt;/p&gt;
&lt;p&gt;sudo apt install nginx&lt;/p&gt;
&lt;p&gt;之後再些改 /etc/ nginx/site-available/default&lt;/p&gt;
&lt;p&gt;nginx return 301 設定:&lt;/p&gt;
&lt;pre class="brush:python"&gt;
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    return 301 https://hp.kmol.info;
}
&lt;/pre&gt;</content><category term="2017fall"></category></entry><entry><title>電腦模擬</title><link href="https://kmolab.github.io/blog/first-simulation-blog.html" rel="alternate"></link><published>2017-06-05T02:29:00+08:00</published><updated>2017-06-05T02:29:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-05:/blog/first-simulation-blog.html</id><summary type="html">&lt;p&gt;紀錄與電腦模擬相關內容與紀錄， 使用工具 Python3, &lt;a href="http://www.robodk.com/download"&gt;RoboDK&lt;/a&gt; (&lt;a href="https://robodk.com/doc/en/RoboDK-API.html"&gt;RoboDK API&lt;/a&gt;)&lt;/p&gt;
</summary><content type="html">&lt;p&gt;紀錄與電腦模擬相關內容與紀錄， 使用工具 Python3, &lt;a href="http://www.robodk.com/download"&gt;RoboDK&lt;/a&gt; (&lt;a href="https://robodk.com/doc/en/RoboDK-API.html"&gt;RoboDK API&lt;/a&gt;)&lt;/p&gt;


&lt;h2&gt;PyQt5&lt;/h2&gt;
&lt;p&gt;pyqt5 程式 &lt;a href="http://projects.skylogic.ca/blog/how-to-install-pyqt5-and-build-your-first-gui-in-python-3-4/"&gt;http://projects.skylogic.ca/blog/how-to-install-pyqt5-and-build-your-first-gui-in-python-3-4/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;run.py, 自行編寫用從 core/main.py 中導入 MainWindow 類別建立案例後執行&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if __name__ == "__main__":
    import sys
    from PyQt5.QtWidgets import QApplication

    from core.main import MainWindow

    app = QApplication(sys.argv)

    main = MainWindow()
    main.show()

    sys.exit(app.exec_())
&lt;/pre&gt;

&lt;p&gt;core/main.py, 以 main.ui 滑鼠右鍵 generate Dialog Code 產生&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# -*- coding: utf-8 -*-

"""
Module implementing MainWindow.
"""

from PyQt5.QtCore import pyqtSlot
from PyQt5.QtWidgets import QMainWindow

from PyQt5.QtCore import QLineF
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QGraphicsScene,  QGraphicsView,  QGraphicsEllipseItem

from .Ui_main import Ui_MainWindow


class MainWindow(QMainWindow, Ui_MainWindow):
    """
    Class documentation goes here.
    """
    def __init__(self, parent=None):
        """
        Constructor

        @param parent reference to the parent widget
        @type QWidget
        """
        super(MainWindow, self).__init__(parent)
        self.setupUi(self)

    @pyqtSlot()
    def on_actionAbout_triggered(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        #raise NotImplementedError
        #建立景物
        scene = QGraphicsScene(-200, -200, 400, 400)
        # Create Ellipse Item
        item = QGraphicsEllipseItem(-150, -100, 300, 300)
        # Add item
        scene.addItem(item)
        # 納入繪圖物件
        scene.addText("終於可以!")
        scene.addLine(QLineF(0, 0, 200, 200))
        # set no frame to graphicsView
        self.graphicsView.setFrameShape(QFrame.NoFrame)
        # 在既有的 graphicsView 中設定景物
        # graphicsView in a layout and set layout to the grid to fit the size of window
        self.graphicsView.setScene(scene)

        # 顯示
        self.graphicsView.show()

    @pyqtSlot()
    def on_actionQuit_triggered(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        #raise NotImplementedError
        self.close()
&lt;/pre&gt;

&lt;p&gt;core/Ui_main.py, 利用 main.ui 以 compile form 產生&lt;/p&gt;
&lt;pre class="brush: python"&gt;

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Y:\tmp\pyqt5_vault\ex3\core\main.ui'
#
# Created by: PyQt5 UI code generator 5.8.2
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralWidget = QtWidgets.QWidget(MainWindow)
        self.centralWidget.setObjectName("centralWidget")
        self.graphicsView = QtWidgets.QGraphicsView(self.centralWidget)
        self.graphicsView.setGeometry(QtCore.QRect(-15, -29, 871, 581))
        self.graphicsView.setObjectName("graphicsView")
        MainWindow.setCentralWidget(self.centralWidget)
        self.menuBar = QtWidgets.QMenuBar(MainWindow)
        self.menuBar.setGeometry(QtCore.QRect(0, 0, 800, 22))
        self.menuBar.setObjectName("menuBar")
        self.menuFile = QtWidgets.QMenu(self.menuBar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menuBar)
        self.actionAbout = QtWidgets.QAction(MainWindow)
        self.actionAbout.setObjectName("actionAbout")
        self.actionQuit = QtWidgets.QAction(MainWindow)
        self.actionQuit.setObjectName("actionQuit")
        self.menuFile.addAction(self.actionAbout)
        self.menuFile.addAction(self.actionQuit)
        self.menuBar.addAction(self.menuFile.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.actionAbout.setText(_translate("MainWindow", "About"))
        self.actionQuit.setText(_translate("MainWindow", "Quit"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
&lt;/pre&gt;

&lt;p&gt;main.ui&lt;/p&gt;
&lt;pre class="brush: xml"&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ui version="4.0"&gt;
 &lt;class&gt;MainWindow&lt;/class&gt;
 &lt;widget class="QMainWindow" name="MainWindow"&gt;
  &lt;property name="geometry"&gt;
   &lt;rect&gt;
    &lt;x&gt;0&lt;/x&gt;
    &lt;y&gt;0&lt;/y&gt;
    &lt;width&gt;800&lt;/width&gt;
    &lt;height&gt;600&lt;/height&gt;
   &lt;/rect&gt;
  &lt;/property&gt;
  &lt;property name="windowTitle"&gt;
   &lt;string&gt;MainWindow&lt;/string&gt;
  &lt;/property&gt;
  &lt;widget class="QWidget" name="centralWidget"&gt;
   &lt;widget class="QGraphicsView" name="graphicsView"&gt;
    &lt;property name="geometry"&gt;
     &lt;rect&gt;
      &lt;x&gt;-15&lt;/x&gt;
      &lt;y&gt;-29&lt;/y&gt;
      &lt;width&gt;871&lt;/width&gt;
      &lt;height&gt;581&lt;/height&gt;
     &lt;/rect&gt;
    &lt;/property&gt;
   &lt;/widget&gt;
  &lt;/widget&gt;
  &lt;widget class="QMenuBar" name="menuBar"&gt;
   &lt;property name="geometry"&gt;
    &lt;rect&gt;
     &lt;x&gt;0&lt;/x&gt;
     &lt;y&gt;0&lt;/y&gt;
     &lt;width&gt;800&lt;/width&gt;
     &lt;height&gt;22&lt;/height&gt;
    &lt;/rect&gt;
   &lt;/property&gt;
   &lt;widget class="QMenu" name="menuFile"&gt;
    &lt;property name="title"&gt;
     &lt;string&gt;File&lt;/string&gt;
    &lt;/property&gt;
    &lt;addaction name="actionAbout"/&gt;
    &lt;addaction name="actionQuit"/&gt;
   &lt;/widget&gt;
   &lt;addaction name="menuFile"/&gt;
  &lt;/widget&gt;
  &lt;action name="actionAbout"&gt;
   &lt;property name="text"&gt;
    &lt;string&gt;About&lt;/string&gt;
   &lt;/property&gt;
  &lt;/action&gt;
  &lt;action name="actionQuit"&gt;
   &lt;property name="text"&gt;
    &lt;string&gt;Quit&lt;/string&gt;
   &lt;/property&gt;
  &lt;/action&gt;
 &lt;/widget&gt;
 &lt;resources/&gt;
 &lt;connections/&gt;
&lt;/ui&gt;
&lt;/pre&gt;

&lt;h2&gt;Binary Genetic Algorithm&lt;/h2&gt;
&lt;pre class="brush: python"&gt;
#encoding=utf8
# genetic.py
#
import random
import operator
# for Intersect
from math import *
MAXIMIZE, MINIMIZE = 11, 22
class Individual:
    # 染色體先設為 None
    chromosome = None
    # 得分也先設為 None
    score = None
    # Here the size of var depends on var_number print
    # var 變數的元素個數取決於 var_number 的個數 (即變數個數)
    var = []
    # 表示適應值變數個數有兩個
    var_number = 2
    #先將 var 數列中元素都設為 0
    for i in range(var_number):
        var.append(0)
    # 等位基因表示各基因可選的內容, 這裡表示不是 0 就是 1
    alleles = (0,1)
    # 2**10 = 32*32 = 1024, 表示若用十個 binary 位數來表示整數, 可以表示從 0 到 1023 的數值大小
    # 若也用另外 十個 binary 位數來表示小數值, 則也是 0 到 1023 的數值表示能力, 
    # 而再加一個表示正負的代表 binary 位數, 每一個變數需要 21 個 binary numbers 
    # 以下為參數可負數時的編碼考量
    #前10為小數,後10為整數,第21則為正負號
    #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號.
    #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號
    #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號
    # -1023 ~ 1023
    #length = 21*var_number,若接受負數參數,則必須同步修改 20-&gt;21
    # 因為這裡只接受正的變數值, 所以每一個變數需要 20 個 binary 位數
    length = 20*var_number
    seperator = ''
    optimization = MINIMIZE

    def __init__(self, chromosome=None):
        self.chromosome = chromosome or self._makechromosome()
        self.score = None  # set during evaluation

    '''
    bitwise operators (binary left shift): The left operands value is moved left by the number of bits specified by the right operand.
    x &lt;&lt; y
    Returns x with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is the same as multiplying x by 2**y.
    '''
    # 根據染色體各位元的值轉為 10 進位值
    def _getvar(self, chromosome=None):
        # x 起始值設為 0
        x = 0
        for i in range(0, self.var_number):
            # 先根據前 20 個位元值, 透過 binary left shift 轉為 10 進位之後, 再轉為對應小數
            for j in range(i*20, i*20+10):
                x += self.chromosome[j]&lt;&lt;(j-(i*20))
            # 因為前 20 個 binary 數, 負責 10 進位數的小數點後 3 個位數, 只要轉為 10 進位值之後, 若大於 999, 則僅取 999,
            # 再除以 1000, 可以得到 .999 表示 .999 為最大的小數表示數, 不要因為大於 1000 後若除以 1000 將進位到整數, 會與整數有交互影響
            if (x&gt;999):
                x = 999
            x /= 1000.
            # 整數部份 0 ~ 1023 的表示範圍則沒有問題, 利用 bitwise 轉換後, 直接取整數值
            for j in range(i*20+10, i*20+20):
                x += self.chromosome[j]&lt;&lt;(j-(i*20+10))
            self.var[i] = x
        return self.var

    ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings
    #for design variable -1023 ~1023
        for i in range(self.var_number):
            x = 0
            for j in range(i*21, i*21+10):
                x += self.chromosome[j]&lt;&lt;(j-(i*21))
            if (x&gt;999):
                x = 999
            x /= 1000.
            for j in range(i*(21)+10, i*(21)+20):
                x += self.chromosome[j]&lt;&lt;(j-(i*21+10))
            # 各變數範圍第 21 位數若為 1, 則表示該數為負數
            if(self.chromosome[i*(21)+20] == 1):
                self.var[i] = -x
            else:
                self.var[i] = x
            # 讓 x 再設回原值 0 表示內定各變數為正數
            x = 0
        return self.var
    '''
    # 建立染色體
    def _makechromosome(self):
        "makes a chromosome from randomly selected alleles."
        return [random.choice(self.alleles) for gene in range(self.length)]

    # 計算適應值
    def evaluate(self, optimum=None):
        "this method MUST be overridden to evaluate individual fitness score."
        pass

    # 交配方法
    def crossover(self, other):
        "override this method to use your preferred crossover method."
        return self._twopoint(other)

    # 突變方法
    def mutate(self, gene):
        "override this method to use your preferred mutation method."
        self._pick(gene)

    # sample mutation method
    def _pick(self, gene):
        "chooses a random allele to replace this gene's allele."
        self.chromosome[gene] = random.choice(self.alleles)

    # sample crossover method
    def _twopoint(self, other):
        "creates offspring via two-point crossover between mates."
        left, right = self._pickpivots()

        def mate(p0, p1):
            chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容
            chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因
            child = p0.__class__(chromosome)
            child._repair(p0, p1)
            return child
        return mate(self, other), mate(other, self)

    # some crossover helpers ...
    def _repair(self, parent1, parent2):
        "override this method, if necessary, to fix duplicated genes."
        pass

    def _pickpivots(self):
        left = random.randrange(1, self.length-2)
        right = random.randrange(left, self.length-1)
        return left, right
    #
    # other methods
    #
    def __repr__(self):
        "returns string representation of self"
        '''
        return '&lt;%s chromosome="%s" score=%s var=%s&gt;' % \
               (self.__class__.__name__,
                self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome))
        '''
        return '&lt;%s score=%s var=%s&gt;' % \
               (self.__class__.__name__,self.score,self._getvar(self.chromosome))
    # since the __cmp__ special function is gone  use the __lt__ in stead
    # use the expression (a &gt; b) - (a &lt; b) as the equivalent for cmp(a, b)
    #def __cmp__(self, other):
    # these are for python 3
    def __cmp__(self, other):
        if self.optimization == MINIMIZE:
            #return cmp(self.score, other.score)
            return (self.score &gt; other.score) - (self.score &lt; other.score)
        else: # MAXIMIZE
            #return cmp(other.score, self.score)
            return (other.score &gt; self.score) - (other.score &lt; self.score)

    def __lt__(self, other):
        return self.__cmp__(other) &lt; 0
    def __le__(self, other):
        return self.__cmp__(other) &lt;= 0
    def __gt__(self, other):
        return self.__cmp__(other) &gt; 0
    def __ge__(self, other):
        return self.__cmp__(other) &gt;= 0 
    def copy(self):
        twin = self.__class__(self.chromosome[:])
        twin.score = self.score
        return twin
class Environment(object):
    x = [0]
    y = [0]

    def __init__(self, kind, population=None, size=100, maxgenerations=100,
                 crossover_rate=0.90, mutation_rate=0.07, optimum=None):
        self.kind = kind
        self.size = size
        self.optimum = optimum
        self.population = population or self._makepopulation()
        for individual in self.population:
            individual.evaluate(self.optimum)
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.maxgenerations = maxgenerations
        self.generation = 0
        self.report()

    def _makepopulation(self):
        return [self.kind() for individual in range(self.size)]

    def run(self):
        while not self._goal():
            self.step()

    def _goal(self):
        return self.generation &gt; self.maxgenerations or \
               self.best.score == self.optimum

    def step(self):
        # this sort is not working with python 3.0, modification is needed
        self.population.sort()
        self._crossover()
        self.generation += 1
        self.report()
        self.x.append(self.generation)
        # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值
        if self.best.score &lt;=5:
            self.y.append(self.best.score)
        else:
            self.y.append(5)

    def _crossover(self):
        next_population = [self.best.copy()]
        while len(next_population) &lt; self.size:
            mate1 = self._select()
            if random.random() &lt; self.crossover_rate:
                mate2 = self._select()
                offspring = mate1.crossover(mate2)
            else:
                offspring = [mate1.copy()]
            for individual in offspring:
                self._mutate(individual)
                individual.evaluate(self.optimum)
                next_population.append(individual)
        self.population = next_population[:self.size]

    def _select(self):
        "override this to use your preferred selection method"
        return self._tournament()

    def _mutate(self, individual):
        for gene in range(individual.length):
            if random.random() &lt; self.mutation_rate:
                individual.mutate(gene)
    #
    # sample selection method
    #
    def _tournament(self, size=8, choosebest=0.90):
        competitors = [random.choice(self.population) for i in range(size)]
        competitors.sort()
        if random.random() &lt; choosebest:
            return competitors[0]
        else:
            return random.choice(competitors[1:])

    def best():
        doc = "individual with best fitness score in population."
        def fget(self):
            return self.population[0]
        return locals()
    best = property(**best())

    def report(self):
        try:
            print ("="*70)
            print ("generation: ", self.generation)
            print ("best:       ", self.best)
        except:
            g.es ("="*70)
            g.es ("generation: ", self.generation)
            g.es ("best:       ", self.best)

# 以上為 genetic.py 目前將兩者結合在一起
#encoding=utf8
# volume.py - useage example
#
# the fittest individual will have a chromosome consisting of 40 '1's
#
#
#import genetic
class Volume(Individual):
    optimization = MAXIMIZE
    def evaluate(self, optimum=None):
        SURFACE = 80
        # self.score is the fitness value
        self._getvar(self.chromosome)

        x = self.var[0]
        y = self.var[1]
        z=(SURFACE - x*y)/(2.*(x+y))
        fitness_value = x*y*z

        self.score = fitness_value

    def mutate(self, gene):
        self.chromosome[gene] = not self.chromosome[gene] # bit flip

class Intersect(Individual):
    optimization = MINIMIZE
    def evaluate(self, optimum=None):
        # self.score is the fitness value
        self._getvar(self.chromosome)

        t = self.var[0]
        deg = pi/180
        theta = self.var[1]*deg
        xtarget = 0.75/2
        ytarget = 0.5
        x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2
        y = (-3*t/2 + 123/92)*sin(theta)
        # 適應值
        fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8)

        # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰
        if t &gt; 1:
            fitness_value += 1000
        if t &lt; 0:
            fitness_value += 1000
        # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰
        if theta &gt; 2*pi:
            fitness_value += 1000
        if theta &lt; 0:
            fitness_value += 1000


        self.score = fitness_value

    def mutate(self, gene):
        self.chromosome[gene] = not self.chromosome[gene] # bit flip


if __name__ == "__main__":
    env = Environment(Volume, size=500, maxgenerations=100)
    #env = Environment(Intersect, size=500, maxgenerations=100)
    env.run()
&lt;/pre&gt;

&lt;h2&gt;Deap 與 Scoop&lt;/h2&gt;
&lt;p&gt;Deap: &lt;a href="https://github.com/DEAP/deap"&gt;https://github.com/DEAP/deap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Scoop: &lt;a href="https://en.wikipedia.org/wiki/Python_SCOOP_(software)"&gt;https://en.wikipedia.org/wiki/Python_SCOOP_(software)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://groups.google.com/forum/#!topic/deap-users/v3wbky0EUf0"&gt;https://groups.google.com/forum/#!topic/deap-users/v3wbky0EUf0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://groups.google.com/forum/m/#!msg/deap-users/P4IkiE-Bvbg/xSoMDphbMR4J"&gt;https://groups.google.com/forum/m/#!msg/deap-users/P4IkiE-Bvbg/xSoMDphbMR4J&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;平行運算&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://research.cs.wisc.edu/htcondor/"&gt;http://research.cs.wisc.edu/htcondor/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/J-Robinson/GridGA"&gt;https://github.com/J-Robinson/GridGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用 Blender 製作 &lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=WUvTyaaNkzM"&gt;Essence of calculus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=kjBOesZCoqc"&gt;Essence of linear algebra&lt;/a&gt;&lt;/p&gt;</content><category term="機械設計"></category><category term="課程"></category></entry><entry><title>軟硬體設置</title><link href="https://kmolab.github.io/blog/first-setup-blog.html" rel="alternate"></link><published>2017-06-05T01:29:00+08:00</published><updated>2017-06-05T01:29:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-05:/blog/first-setup-blog.html</id><summary type="html">&lt;p&gt;紀錄電腦與網路的軟硬體相關設置&lt;/p&gt;
</summary><content type="html">&lt;p&gt;紀錄電腦與網路的軟硬體相關設置&lt;/p&gt;


&lt;h2&gt;Github, Bitbucket 與 Fossil SCM&lt;/h2&gt;
&lt;p&gt;Github 目前提供的免費帳號, 允許多人協同提交推送版本, 唯一的限制就是單一檔案不能大於 50 MB.&lt;/p&gt;
&lt;p&gt;Bitbucket 則允許免費使用非公開的倉儲, 但是至多只允許五個帳號協同.&lt;/p&gt;
&lt;p&gt;Fossil SCM 則適合在近端或區域網路中使用, 目前 KMOLab 希望在區網中導入作為與 Github Pages 配合的工具, 使用者可以將 Fossil SCM 的 working directory 限縮在 Github 近端倉儲的特定目錄下, 且在 .gitignore 中排除 &lt;em&gt;FOSSIL&lt;/em&gt; (under Windows) 的版次管理, 但是相關的 fossil update 與 fossil server 功能仍然必須依照特定的流程進行操作, 以避免兩套版次管理系統內容的不同步導致資料覆蓋流失.&lt;/p&gt;
&lt;p&gt;github 倉儲與 bitbucket 倉儲, 則可以利用 git remote add 同步.&lt;/p&gt;
&lt;h2&gt;Leo Editor, Pelican 與 Reveal.js&lt;/h2&gt;
&lt;p&gt;Leo Editor 是一套能夠以程式方法有效管理多元資料的文字資料編輯器, 以下就是用來管理 KMOLab Pelican 靜態網誌有關內容的畫面, 其中的 @button local-blog 是用來產生靜態網誌的指令按鈕, @button github-blog 則是用來產生嵌入 Disqus 留言系統的 Github Pages 網誌對應指令, 兩個指令的差別在於使用不同的設定檔案, 使用者可以先利用近端的按鈕, 建立網誌後在近端以另一個 https-server 按鈕建立 https 伺服, 用瀏覽器檢查所產生的網誌內容, 一旦要送到 Github 倉儲, 必須再利用遠端按鈕產生另外一組網誌與搜尋用 .json 檔案後, 再提交推送到倉儲.&lt;/p&gt;
&lt;p&gt;在這個過程中, 使用者依照 Pelican 的特定 Markdown 檔案編寫網誌內容外, Leo Editor 專案檔中也可以放入其他有關的註記與設定檔案編輯用的節點. 若需要在 Pelican 的環境中修改設定, 都可以全部在一個 Leo Editor 專案檔中完成.&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/images/leo_editor_kmolab.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;Leo Editor 另外一項有用的特定就是能夠利用從屬節點關係與內文指令來表示複雜的 html 檔案, 如下圖所示, 各段落的超文件標註可以利用節點加以切割, 使用者在編寫 reveal.js 投影片時, 可以只集中在特定簡報內容的編寫, 並且透過節點的複製與搬移, 甚至使用 Leo Editor 的節點 clone 功能, 同步相同內容但是同時出現在不同位置的節點.&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/images/reveal_slide_on_leo_editor.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;Pelican Blog 共用設定檔案:&lt;/p&gt;
&lt;p&gt;pelicanconf.py&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#!/usr/bin/env python
# -*- coding: utf-8 -*- #
from __future__ import unicode_literals

AUTHOR = 'KMOL'
SITENAME = 'KMOLab 機械設計工程'
# 不要用文章所在目錄作為類別
USE_FOLDER_AS_CATEGORY = False

#PATH = 'content'

#OUTPUT_PATH = 'output'

TIMEZONE = 'Asia/Taipei'

DEFAULT_LANG = 'en'

# Feed generation is usually not desired when developing
FEED_ALL_ATOM = None
CATEGORY_FEED_ATOM = None
TRANSLATION_FEED_ATOM = None
AUTHOR_FEED_ATOM = None
AUTHOR_FEED_RSS = None

# Blogroll
LINKS = (('Pelican', 'http://getpelican.com/'),
         ('pelican-bootstrap3', 'https://github.com/DandyDev/pelican-bootstrap3/'),
         ('pelican-plugins', 'https://github.com/getpelican/pelican-plugins'),
         ('Tipue search', 'https://github.com/Tipue/Tipue-Search'),)

# Social widget
#SOCIAL = (('You can add links in your config file', '#'),('Another social link', '#'),)

DEFAULT_PAGINATION = 10

# Uncomment following line if you want document-relative URLs when developing
#RELATIVE_URLS = True

# 必須絕對目錄或相對於設定檔案所在目錄
PLUGIN_PATHS = ['plugin']
PLUGINS = ['summary', 'tipue_search', 'sitemap']

# for sitemap plugin
SITEMAP = {
    'format': 'xml',
    'priorities': {
        'articles': 0.5,
        'indexes': 0.5,
        'pages': 0.5
    },
    'changefreqs': {
        'articles': 'monthly',
        'indexes': 'daily',
        'pages': 'monthly'
    }
}

# search is for Tipue search
DIRECT_TEMPLATES = (('index', 'tags', 'categories', 'authors', 'archives', 'search'))

# for pelican-bootstrap3 theme settings
#TAG_CLOUD_MAX_ITEMS = 50
DISPLAY_CATEGORIES_ON_SIDEBAR = True
DISPLAY_RECENT_POSTS_ON_SIDEBAR = True
DISPLAY_TAGS_ON_SIDEBAR = True
DISPLAY_TAGS_INLINE = True
TAGS_URL = "tags.html"
CATEGORIES_URL = "categories.html"
MENUITEMS = [('About', '/blog/pages/about/')]
#SHOW_ARTICLE_AUTHOR = True

#MENUITEMS = [('Home', '/'), ('Archives', '/archives.html'), ('Search', '/search.html')]
&lt;/pre&gt;

&lt;p&gt;遠端 publishconf.py&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#!/usr/bin/env python
# -*- coding: utf-8 -*- #
from __future__ import unicode_literals

# This file is only used if you use `make publish` or
# explicitly specify it as your config file.

import os
import sys
sys.path.append(os.curdir)
from pelicanconf import *

# 因為 publishconf.py 在 pelicanconf.py 之後, 因此若兩處有相同變數的設定, 將以較後讀入的 publishconf.py 中的設定為主.

# 將所有靜態 html 檔案移到 blog 子目錄
SITEURL = 'https://kmolab.github.io/blog'
# 此設定用於將資料送到 gh-pages, 因此使用絕對 URL 設定
RELATIVE_URLS = False
# 為了要讓 local 與 gh-pages 上都能夠使用 Tipue search, 可能要採用不同的 theme
THEME = 'theme/pelican-bootstrap3'
#BOOTSTRAP_THEME = 'readable'
#BOOTSTRAP_THEME = 'readable-old'
BOOTSTRAP_THEME = 'united'
#PYGMENTS_STYLE = 'paraiso-drak'
#PYGMENTS_STYLE = 'fruity'
# 為了同時兼容 render_math, 必須放棄 fruity
PYGMENTS_STYLE = 'monokai'

FEED_ALL_ATOM = 'feeds/all.atom.xml'
CATEGORY_FEED_ATOM = 'feeds/%s.atom.xml'

DELETE_OUTPUT_DIRECTORY = True

# Following items are often useful when publishing

DISQUS_SITENAME = "kmolabmde"
#GOOGLE_ANALYTICS = ""

# 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定
DEFAULT_DATE = 'fs'

# 遠端的 code hightlight
#MD_EXTENSIONS = ['fenced_code', 'extra', 'codehilite(linenums=True)']
MARKDOWN = {
    'extension_configs': {
        'markdown.extensions.codehilite': {'css_class': 'highlight'},
        'markdown.extensions.extra': {},
        'markdown.extensions.meta': {},
    },
    'output_format': 'html5',
}

# 若要依照日期存檔呼叫
#ARTICLE_URL = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/'
#ARTICLE_SAVE_AS = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html'
PAGE_URL = 'pages/{slug}/'
PAGE_SAVE_AS = 'pages/{slug}/index.html'
SHOW_ARTICLE_AUTHOR = True
&lt;/pre&gt;

&lt;p&gt;local_publishconf.py&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#!/usr/bin/env python
# -*- coding: utf-8 -*- #
from __future__ import unicode_literals

# This file is only used if you use `make publish` or
# explicitly specify it as your config file.

import os
import sys
sys.path.append(os.curdir)
from pelicanconf import *

# 因為 publishconf.py 在 pelicanconf.py 之後, 因此若兩處有相同變數的設定, 將以較後讀入的 publishconf.py 中的設定為主.

# 請注意, 為了在近端讓 Tipue search 傳回的搜尋結果連結正確, 必須使用 ./
SITEURL = './'
# 此設定用於近端靜態網頁查驗, 因此使用相對 URL
RELATIVE_URLS = True
# 為了要讓 local 與 gh-pages 上都能夠使用 Tipue search, 可能要採用不同的 theme
THEME = 'theme/pelican-bootstrap3_local'
#BOOTSTRAP_THEME = 'readable'
#BOOTSTRAP_THEME = 'readable-old'
BOOTSTRAP_THEME = 'united'
#PYGMENTS_STYLE = 'paraiso-drak'
#PYGMENTS_STYLE = 'fruity'
# 為了同時兼容 render_math, 必須放棄 fruity
PYGMENTS_STYLE = 'monokai'

FEED_ALL_ATOM = 'feeds/all.atom.xml'
CATEGORY_FEED_ATOM = 'feeds/%s.atom.xml'

DELETE_OUTPUT_DIRECTORY = True

# Following items are often useful when publishing

#DISQUS_SITENAME = "kmolabmde"
#GOOGLE_ANALYTICS = ""

# 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定
DEFAULT_DATE = 'fs'

# 近端的 code hightlight
#MD_EXTENSIONS = ['fenced_code', 'extra', 'codehilite(linenums=True)']
MARKDOWN = {
    'extension_configs': {
        'markdown.extensions.codehilite': {'css_class': 'highlight'},
        'markdown.extensions.extra': {},
        'markdown.extensions.meta': {},
    },
    'output_format': 'html5',
}

# 若要依照日期存檔呼叫
#ARTICLE_URL = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html'
#ARTICLE_SAVE_AS = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html'
PAGE_URL = 'pages/{slug}/'
PAGE_SAVE_AS = 'pages/{slug}/index.html'
SHOW_ARTICLE_AUTHOR = True
&lt;/pre&gt;

&lt;h2&gt;區網中的 IPv4 與 IPv6 WWW Server&lt;/h2&gt;
&lt;p&gt;Pelican 在近端產生 weblog 後, 若要在近端以 https 檢視結果, 就必須同時建立 https Server.&lt;/p&gt;
&lt;p&gt;近端 IPv4 WWW 伺服器程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 5443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print(os.getcwd())
    print("5443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()
&lt;/pre&gt;

&lt;p&gt;近端 IPv6 ＷＷＷ 伺服器程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import os
import subprocess
import threading
import socket
import http.server, ssl

class HTTPServerV6(http.server.HTTPServer):
    address_family = socket.AF_INET6

def domake():
    # build directory
    os.chdir("./../")
    ipv6_address = '::1'
    server_address = (ipv6_address, 6443)
    #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("6443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()
&lt;/pre&gt;</content><category term="Github"></category><category term="Bitbucket"></category><category term="Fossil SCM"></category><category term="Leo Editor"></category><category term="Pelican"></category><category term="Reveal.js"></category></entry></feed>