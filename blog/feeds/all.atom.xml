<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計工程系 KMOLab</title><link href="https://kmolab.github.io/blog/" rel="alternate"></link><link href="https://kmolab.github.io/blog/feeds/all.atom.xml" rel="self"></link><id>https://kmolab.github.io/blog/</id><updated>2018-01-20T11:00:00+08:00</updated><entry><title>本站網址改為 lab.kmol.info</title><link href="https://kmolab.github.io/blog/use-blog-kmol-info-as-domain-name.html" rel="alternate"></link><published>2018-01-20T11:00:00+08:00</published><updated>2018-01-20T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2018-01-20:/blog/use-blog-kmol-info-as-domain-name.html</id><summary type="html">&lt;p&gt;目前的網址為 kmolab.github.io, 從今起希望改為 lab.kmol.info&lt;/p&gt;
</summary><content type="html">&lt;p&gt;目前的網址為 kmolab.github.io, 從今起希望改為 lab.kmol.info&lt;/p&gt;


&lt;h2&gt;DNS 設定&lt;/h2&gt;
&lt;p&gt;首先必須先在 DNS 伺服器中, 新增 CNAME 類型, 主機選擇 lab, 指向則設為 kmolab.github.io&lt;/p&gt;
&lt;h2&gt;修改 publishconf.py&lt;/h2&gt;
&lt;p&gt;接下來必須修改  publishconf.py, 將 SITEURL 設為 'https://kmolab.github.io/blog'&lt;/p&gt;
&lt;h2&gt;Github 倉儲設定&lt;/h2&gt;
&lt;p&gt;倉儲中新增一個 CNAME 檔案, 內容為 lab.kmol.info, 且進入倉儲 settings 查驗是否 Custom domain 也是設為 lab.kmol.info, 透過以上設定就可以將 &lt;a href="http://kmolab.github.io"&gt;http://kmolab.github.io&lt;/a&gt; 轉為 &lt;a href="http://lab.kmol.info"&gt;http://lab.kmol.info&lt;/a&gt;&lt;/p&gt;</content><category term="domain name"></category><category term="cname"></category></entry><entry><title>2017 KMOLab 總結</title><link href="https://kmolab.github.io/blog/Year-2017-Conclusion.html" rel="alternate"></link><published>2018-01-19T11:00:00+08:00</published><updated>2018-01-19T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2018-01-19:/blog/Year-2017-Conclusion.html</id><summary type="html">&lt;p&gt;2017 年在兩個禮拜前結束, &lt;a href="https://kmolab.github.io"&gt;KMOLab&lt;/a&gt; 也在秋季學期完成了計算機程式與電腦輔助設計實習的課程.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;2017 年在兩個禮拜前結束, &lt;a href="https://kmolab.github.io"&gt;KMOLab&lt;/a&gt; 也在秋季學期完成了計算機程式與電腦輔助設計實習的課程.&lt;/p&gt;


&lt;h2&gt;從 &lt;a href="https://www.riverbankcomputing.com/software/pyqt/download5"&gt;PyQt5&lt;/a&gt; 事件導向教起&lt;/h2&gt;
&lt;p&gt;原本只教導基本 Python3 語法的計算機程式課程, 首度以 &lt;a href="https://www.riverbankcomputing.com/software/pyqt/download5"&gt;PyQt5&lt;/a&gt; 的物件導向與事件導向為課程主體, 然後讓學員從中了解各種語法的使用時機. 儘管相較於一般工學院科系的計算機程式課程, 從 C++ 或 C 的內容學起, 有很大的差異, 但是出發點在於: 要讓大一的機械設計工程系學生儘快了解, 電腦程式語言該如何應用, 就必須把握機會, 在學生迷失於各種程式語法之前, 設法讓各學員提起更大的學習動機.&lt;/p&gt;
&lt;p&gt;這著險棋因為有 &lt;a href="https://eric-ide.python-projects.org/eric-download.html"&gt;Eric6&lt;/a&gt; 與 &lt;a href="http://doc.qt.io/qt-5/qtdesigner-manual.html"&gt;Qt Designer&lt;/a&gt; 的協助, 才值得一試, 從基本視窗按鈕元件與 lineEdit 元件的置入, 到對話框布局的配置, 因為都採用 &lt;a href="http://doc.qt.io/qt-5/qtdesigner-manual.html"&gt;Qt Designer&lt;/a&gt; 的滑鼠互動操作, 相信沒有太大的難度, 但是當 .ui XML 檔案轉為 Python3 原始碼之後, 到配合對話框建立與視窗元件互動的程式邏輯編寫, 就在在考驗著每一位程式初學者的耐性與學習動機.&lt;/p&gt;
&lt;p&gt;過程中, 利用 &lt;a href="https://www.riverbankcomputing.com/software/pyqt/download5"&gt;PyQt5&lt;/a&gt; 建立了一個簡單的電腦輔助設計實習相關的機電系統控制介面程式, 用來控制 &lt;a href="http://www.coppeliarobotics.com/"&gt;V-rep&lt;/a&gt; 鋼珠軌道運動模擬系統的視窗程式, 如下列影片所示, 希望以此為例說明在隨後的課程中, 如何使用 &lt;a href="https://www.riverbankcomputing.com/software/pyqt/download5"&gt;PyQt5&lt;/a&gt; 程式, 協助完成構想中的機電資產品設計:&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/JPtW66z0-VQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;上述這個簡單的視窗程式, 與計算機程式中所建立的簡易計算機程式, 非常類似, 僅使用了按鈕與 lineEdit 元件, 且利用 &lt;a href="http://www.coppeliarobotics.com/"&gt;V-rep&lt;/a&gt; 的 &lt;a href="http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm"&gt;Python remote API&lt;/a&gt; 模式編寫, 最大的教學目標是希望大一計算機程式課程學生, 到了大二上電腦輔助設計實習課程時, 能夠運用 &lt;a href="https://www.riverbankcomputing.com/software/pyqt/download5"&gt;PyQt5&lt;/a&gt; 建立監控用的視窗程式, 實際用來控制虛擬的 &lt;a href="http://www.coppeliarobotics.com/"&gt;V-rep&lt;/a&gt; 機電系統, 或者是控制根據模擬設計過程所完成的實體系統.&lt;/p&gt;
&lt;h2&gt;全面採用 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;2017 Fall &lt;a href="https://kmolab.github.io"&gt;KMOLab&lt;/a&gt; 課程的另外一個特點是, 在兩門課程初期, 利用下列 Python 程式, 為每一位學員建立區域網路 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 主機上的倉儲帳號:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import os
import string
import random
# 使用 Gmail 寄信必須導入下列模組
import smtplib
import re
from email.mime.text import MIMEText  
from email.header import Header

# 用來以亂數建立密碼的函式
def id_generator(size=6, chars=string.ascii_uppercase + string.digits):
    '''
    source: https://stackoverflow.com/questions/2257441/random-string-generation-with-upper-case-letters-and-digits-in-python
    '''
    return ''.join(random.choice(chars) for _ in range(size))

# 讀取學員名單, 逐一取得學員學號, 學員名單, 檢查點 1/7
student_data = open("2017fall_list/1b.txt").read()
student_list = student_data.splitlines()

# 利用 gmail smtp 功能寄信
server = smtplib.SMTP('smtp.gmail.com:587')
server.ehlo()
server.starttls()
# 以下必須準備好對應郵件帳號與密碼的外部檔案, 所提供的寄信帳號, 是否可以寄信, 檢查點 2/7
'''
寄信之前必須到 https://www.google.com/settings/security/lesssecureapps 修改權限, 改為較低安全權限
否則無法使用程式寄信!
'''
# 從外部檔案讀取要用來寄信的 gmail 帳號與密碼
# mail.txt 格式為: 電子郵箱,對應密碼, 以逗點隔開, 檢查點 3/7
email_data = open("z:/2017fall/mail.txt").read()
email, email_password= email_data.split(",")
print(email, email_password)
# 是否登入所提供寄信的電子郵箱, 4/7
server.login(email, email_password)
# 不同課程名稱, 與對應主機名稱, 必須配合修改 5/7
course_title = "計算機程式"
fossil_server = "cpb.kmol.info"

for student_num in student_list:
    username = student_num
    repository = username + '.fossil'
    # 利用所提供的字串, 以亂數組成六個字元的密碼
    password = id_generator(6, "23456789abcdef")
    print(student_num, ", " , password)

    # 執行 dos command 指令, 建立倉儲
    os.system("fossil init -A " +username + " " + repository)
    print("已經建立倉儲 " + repository)

    # 執行 dos command 指令, 修改使用者密碼
    os.system("fossil user password " + username + " " + password + " -R " + repository)
    print("已經修改密碼")

    # 利用 Gmail 寄信, 告知各學員倉儲連結與帳號密碼
    # 每一位學員收到的 output 都從這裡 reset
    output = ""
    # 若學號欄為空, 則不寄信
    if student_num != "":
        # output 為寄給每一位學員的資料表格
        mail_content = student_num+' 您好: &lt;br&gt;&lt;br&gt; 您在 '+course_title+' 課程中的區域網路倉儲: &lt;a href="https://'+fossil_server+'/'+student_num+'"&gt;https://'+fossil_server+'/'+student_num+'&lt;/a&gt;&lt;br&gt;&lt;br&gt;'
        mail_content += '管理帳號為:'+ student_num + '&lt;br&gt; 管理密碼為: '+ password+'&lt;br&gt;&lt;br&gt;'
        print(student_num)
        print(mail_content)
        # 至此 mail_content 已經確定
        # 在測試與實際寄送資料, 也必須配合修改, 檢查點  6/7
        receiver_email = student_num + "@gm.nfu.edu.tw"
        # 測試用
        #receiver_email = student_num+"@mde.tw"
        # 列出收信人 email 位址
        #print(receiver_email)
        #message= MIMEText(mail_content,'plain','UTF-8')
        # 以 html 格式寄信
        message= MIMEText(mail_content,'html','UTF-8')
        message['Subject'] = Header(course_title+" Fossil SCM 帳號通知", 'UTF-8') 
        # 可以先不寄信, 確定格式正確後再開啟, 是否實際寄出信件, 檢查點 7/7
        server.sendmail("gmail_address", receiver_email, message.as_string())
server.quit()
&lt;/pre&gt;

&lt;p&gt;由於先前的 &lt;a href="https://kmolab.github.io"&gt;KMOLab&lt;/a&gt; 課程,  都是在第一時間就導入 &lt;a href="https://github.com/"&gt;Github&lt;/a&gt; 帳號與用法教學, 好處是無需自行維護實體伺服器, 但是缺點則是 &lt;a href="https://git-scm.com/"&gt;Git&lt;/a&gt; 的 Windows client 指令依賴一個大約 200 MB 目錄中的許多套件工具, 與初學者的距離較遠, 而 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的 client 程式只有一個 6MB 的 fossil.exe 檔案, 且若在進階的計算機程式課程中可以直接利用可攜的 &lt;a href="http://www.msys2.org/"&gt;MSYS2&lt;/a&gt; 視窗環境自行從 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 網站中下載原始碼, 然後自行編譯出內含 https 協定連線的 fossil.exe, 這可以是一位大一機械設計工程系學生自行利用一個 32 GB USB 3.0 隨身碟, 自行打造 Windows 視窗環境下工具的第一步, 因此才從 2017 Fall 開始決定全面導入 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;另外一個導入 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 的好處是, 其中大量使用 &lt;a href="https://www.sqlite.org/"&gt;SQLite&lt;/a&gt; 的 SQL 語法存取資料 (因為都是由 &lt;a href="https://www.sqlite.org/crew.html"&gt;D. Richard Hipp&lt;/a&gt; 建立), 因此也讓學生有機會及早一窺 SQL 語言的用法.&lt;/p&gt;
&lt;h2&gt;機電資導向的電腦輔助設計實習&lt;/h2&gt;
&lt;p&gt;過去的電腦輔助設計實習課程, 頂多只是利用機械類電腦輔助設計套件 (例如: PTC Creo, Solidworks, Autodesk Inventor, Siemens NX 或 Simens Solid Edge 等) 建立相關零組件, 或者利用 PTC Creo 應用程式延伸介面中的 Pro/Web.Link 程式架構, 直接在嵌入的 Internet Explorer 瀏覽器中, 進行 Javascript 的程式化參數零組件應用, 雖然可以利用瀏覽器中的 html 表單, 達到設計流程中的網際客製化, 但是隨著 &lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 在 2015 年起提供教育界免費使用後, 連可以簡單放入隨身碟, 以網路取得認證的 PTC Creo 容量都超過 5GB 來看, 都嫌笨重, 更不用提其他無法輕易放入隨身碟中的固定式機械類電腦輔助設計套件, 在輕薄短小, 敏捷協同過程中所帶來的不便.&lt;/p&gt;
&lt;p&gt;因為在一般的機械概念設計初期, 通常需要進行機構的結構設計, 而這些套件卻無法簡易讓初級使用者快速驗證目標機構的可行性, 因此在 2013 年 &lt;a href="http://solvespace.com"&gt;Solvespace&lt;/a&gt; 開源之後, &lt;a href="https://kmolab.github.io"&gt;KMOLab&lt;/a&gt; 就開始在課程中導入, 動機與採用 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 相同, 使用者可以利用 &lt;a href="http://www.msys2.org/"&gt;MSYS2&lt;/a&gt; 可攜套件, 在 Windows 10 64 位元環境中, 自行從 C++11 的原始碼編譯出所需的 3.0 版 solvespace.exe, 含執行時所需的 libwinpthread-1.dll 與 d3dcompiler_43.dll, 總容量大約只有 20 MB, 若採用官方以 Visual Studio 編譯的 2.0 版 solvespace.exe, 更只需要約 7 MB, 直接放在隨身碟中, 使用非常方便.&lt;/p&gt;
&lt;p&gt;電腦輔助設計實習課程中結合 &lt;a href="http://solvespace.com"&gt;Solvespace&lt;/a&gt; 與 &lt;a href="http://www.coppeliarobotics.com/"&gt;V-rep&lt;/a&gt; 的過程可以參考下列影片:&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/LV6QcZZtlFU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;至於結合 &lt;a href="http://solvespace.com"&gt;Solvespace&lt;/a&gt;, &lt;a href="https://www.onshape.com/"&gt;Onshape&lt;/a&gt; 與 &lt;a href="http://www.coppeliarobotics.com/"&gt;V-rep&lt;/a&gt; 的教學影片範例如下:&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/QzYcxTjRsPA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/Zc17Azvmx9M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;而實際從設計, 模擬到實體機電系統測試的範例可參考:&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/j0EALTPfNjQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2&gt;從概念轉為知識, 用知識解題&lt;/h2&gt;
&lt;p&gt;最後, 在 2017 Fall 教學的最後階段, &lt;a href="https://kmolab.github.io"&gt;KMOLab&lt;/a&gt; 還導入了一項源自法國的 &lt;a href="http://www.cktheory.com/blog/index.html"&gt;C-K 設計理論&lt;/a&gt;, C 代表 Concept 指設計過程中的許多概念, 而 K 則是 Knowledge, 也就是設計者已經掌握, 可以用來解決問題的知識, 這個設計理論中最重要的概念是, 沒有所謂愚笨或可笑的設計概念, 而應當視為閱聽者在面對這些概念時, 還不具備實現這些概念所需的知識.&lt;/p&gt;
&lt;p&gt;簡言之, &lt;a href="http://www.cktheory.com/blog/index.html"&gt;C-K 設計理論&lt;/a&gt; 闡述設計是可以被教導的, 而且可以引用數學原理, 從概念中衍生出更多概念, 將概念轉化為知識, 利用知識推演出更多知識, 同時, 許多知識隨著時空環境的變化, 也可能會轉為概念, 因為已經無法解決當時所面臨的實際問題.&lt;/p&gt;
&lt;p&gt;在 &lt;a href="http://www.cktheory.com/blog/index.html"&gt;C-K 設計理論&lt;/a&gt; 的引領下, 任何一個從事機械設計流程的成員, 都不再會因為掌握一些片段知識而自滿, 因為若這些知識沒有持續改進, 未來將無法用來解題, 同時, 初學者也不會因為在協同設計過程中, 擔心提出所謂離譜可笑的概念, 因為理論上所有的概念都可能被實現, 就好像對於一個在數學理論上擁有無限大知識的成員, 就學理上, 根本沒有解決不了的問題, 呵呵, 這確實有些抽象.&lt;/p&gt;
&lt;p&gt;歡迎各位來到 2018 年, 一個深度學習與智慧口號滿天的歷史元年, 我們有整整一年的時間來探討,  大家所擁有的所謂深度學習與智慧機械, 到底是概念還是真能用來解決問題的知識.&lt;/p&gt;</content><category term="2017"></category><category term="C-K Theory"></category></entry><entry><title>網頁上的數學方程式</title><link href="https://kmolab.github.io/blog/Math-Equation-On-Web-Page.html" rel="alternate"></link><published>2018-01-15T11:00:00+08:00</published><updated>2018-01-15T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2018-01-15:/blog/Math-Equation-On-Web-Page.html</id><summary type="html">&lt;p&gt;利用 &lt;a href="https://www.mathjax.org"&gt;Mathjax&lt;/a&gt; 可以利用 LaTeX 語法，在網頁上編寫數學方程式.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;利用 &lt;a href="https://www.mathjax.org"&gt;Mathjax&lt;/a&gt; 可以利用 LaTeX 語法，在網頁上編寫數學方程式.&lt;/p&gt;


&lt;h2&gt;數學方程式&lt;/h2&gt;
&lt;p&gt;當 $a \ne 0$, 一元二次方程式 (ax^2 + bx + c = 0) 有兩組解, 可以寫成:
$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$&lt;/p&gt;
&lt;p&gt;以上的原始 Markdown 檔案為:&lt;/p&gt;
&lt;pre class="brush:xml"&gt;
當 $a \ne 0$, 一元二次方程式 \(ax^2 + bx + c = 0\) 有兩組解, 可以寫成:
$$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$

[Mathjax]:https://www.mathjax.org
&lt;/pre&gt;

&lt;h2&gt;機械設計方法與表達&lt;/h2&gt;
&lt;p&gt;假如您真正將在機械設計工程系所學, 用在解決實務問題, 就會發現整個過程都在與概念及知識混戰, 而概念與知識的交互作用, 正是所謂知識經濟的重要特徵, 概念可以通過驗證而成為知識, 用來解決問題, 而概念可能衍生出更多概念, 當知識在實務執行過程中, 因為各種原因而無法用來解決問題時, 就會轉化成為團隊間的概念, 而特定知識的運用與推演, 更會產生更多有用的知識.&lt;/p&gt;
&lt;p&gt;上面與概念及知識相關的說明, 就是來自 &lt;a href="http://cktheory.com"&gt;C-K 設計理論&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;以上述利用 LaTeX 語法, 在網頁中產生數學方程式的概念, 來自於工程師設計表達過程中的需求, 而這些需求最早的"知識", 是將方程式事先做成圖形檔案, 然後再以 img 標註引入網頁, 但是這樣的知識很快受到挑戰, 因為整體流程非常沒有彈性, 並非直接從網頁中的文字"自動"轉為可視的數學公式, 因此早先的知識在 Javascript 的置入後, 由使用者編寫 LaTeX 語法, 然後再由程式方法在網頁中即時訂製出所要的數學方程式.&lt;/p&gt;
&lt;p&gt;與數學方程式在網頁中的表達需求相同的, 是在網頁中正確引用各種程式碼, 在此我們採用的是舊版的 &lt;a href="http://alexgorbatchev.com/SyntaxHighlighter/"&gt;Syntaxhighlighter&lt;/a&gt;, 也是透過 Javascript 解讀所要引用的程式語法, 然後再利用設定顯示出對應的行號. 上述用來顯示四行 LaTeX 方程式與 Markdown 引用網址的原始內容, 就是應用之一.&lt;/p&gt;
&lt;h2&gt;組成內容與狀態的版次決定一切&lt;/h2&gt;
&lt;p&gt;當上述引用 &lt;a href="http://alexgorbatchev.com/SyntaxHighlighter/"&gt;Syntaxhighlighter&lt;/a&gt; 與 &lt;a href="https://www.mathjax.org"&gt;Mathjax&lt;/a&gt; 的過程中, 非常重要的一點就是這兩套 Javascript 程式碼, 在不斷更新的情況下, 不同版次的組成內容各不相同, 使用的方法也不一樣, 因此我們說事物組成內容與狀態的版次決定一切, 當許多問題的解決與討論, 在各自不知彼此立足點的組成內容與狀態版次的情況下, 許多無謂紛爭就會發生, 解決方法也比相對難以找到.&lt;/p&gt;
&lt;p&gt;以我們目前在使用的 &lt;a href="http://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 來說, 可以在 &lt;a href="https://pythonclock.org/"&gt;Python2&lt;/a&gt; 或 Python3 的環境中使用, 並且需要安裝 &lt;a href="https://riverbankcomputing.com/software/pyqt/intro"&gt;PyQt&lt;/a&gt; 第四版或第五版模組才能啟動. 但是隨著 &lt;a href="https://pythonclock.org/"&gt;Python2&lt;/a&gt; 的生命週期即將抵達終點, 而且 &lt;a href="http://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 及 &lt;a href="https://riverbankcomputing.com/software/pyqt/intro"&gt;PyQt&lt;/a&gt; 幾乎隨時都在更動改版中, 因此假如使用者的操作系統、&lt;a href="http://leoeditor.com/"&gt;Leo Editor&lt;/a&gt;、&lt;a href="https://riverbankcomputing.com/software/pyqt/intro"&gt;PyQt&lt;/a&gt; 與其他使用者用來建置網頁或程式的所有套件都能"自動"感知組成內容, 自動調適狀態, 自動搭配改版, 使用者就能高枕無憂, 永續使用這一系列工具, 問題是整個過程中牽涉到如何收費, 這些工具套件如何正確判斷使用者的需求, 倘若因此造成損失, 該由誰負責"賠償"或者恢復原狀, 重點在於哪一個才是原狀?&lt;/p&gt;
&lt;p&gt;以過去三十幾年的電腦與網路使用歷程來看, 第一階段的電腦輔助, 從旁協助的角色, 早已提升到自動附加的半自主角色, 例如: Windows 10 的自主更新, 已經無需使用者同意, 眼前能夠想像的是在十年內, 電腦與網路全面自主為人類創造價值的世代, 希望屆時使用者不僅只是整體社會運作的組成元件
, 更是主導運作狀態的發號者.&lt;/p&gt;</content><category term="Mathjax"></category></entry><entry><title>Cango Javascript 程式庫繪圖</title><link href="https://kmolab.github.io/blog/cango-brython-svg-canvas.html" rel="alternate"></link><published>2017-10-25T12:00:00+08:00</published><updated>2017-10-25T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-10-25:/blog/cango-brython-svg-canvas.html</id><summary type="html">&lt;p&gt;利用 Cango 與 Brython 進行網際繪圖&lt;/p&gt;
</summary><content type="html">&lt;p&gt;利用 Cango 與 Brython 進行網際繪圖&lt;/p&gt;


&lt;!-- 導入 FileSaver 與 filereader --&gt;

&lt;script type="text/javascript" src="./../ace/FileSaver.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../ace/filereader.js"&gt;&lt;/script&gt;

&lt;!-- 導入最新版的 Brython 標準程式庫 3.3.4 --&gt;

&lt;script type="text/javascript" src="./../data/Brython-3.3.4/brython_dist.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/cango/Cango-12v05-min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../data/cango/CangoAxes-4v00-min.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython 時, 設定 pythonpath 為 data/py, 並將 script1.py 放入, 以便取代 3.2.9 之前版本的 script id 導入 --&gt;

&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;script src="./../ace/ace.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/ext-language_tools.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/mode-python3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/snippets/python.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;

&lt;script type="text/javascript"&gt;
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
&lt;/script&gt;

&lt;canvas id="plotarea" width="800" height="400"&gt;&lt;/canvas&gt;

&lt;script type="text/python"&gt;
from browser import alert
from browser import window
import math

# Javascript 物件
cango = window.Cango.new
path = window.Path.new
shape = window.Shape.new
# Javascript 變數
shapedefs = window.shapeDefs
cgo = cango("plotarea")
cgo.gridboxPadding(10, 10, 5, 7)

# 設定座標系統
# cgo.setWorldCoordsRHC(xmin, ymin, xmax-xmin);  
cgo.setWorldCoordsRHC(-40, -50, 800, 300) 

# 畫軸線
cgo.drawAxes(-40, 750, -80, 710, {
    'xOrigin':0, 'yOrigin':0,
    "strokeColor":"#aaaaaa",
    "fillColor": "#aaaaaa",
    "xTickInterval": 40,
    "xLabelInterval": 40,
    "yTickInterval": 40,
    "yLabelInterval": 40})

deg = math.pi/180  

# 將繪製鏈條輪廓的內容寫成 class 物件
class chain():
    # 輪廓的外型設為成員變數
    chamber = "M -6.8397, -1.4894 \
            A 7, 7, 0, 1, 0, 6.8397, -1.4894 \
            A 40, 40, 0, 0, 1, 6.8397, -18.511 \
            A 7, 7, 0, 1, 0, -6.8397, -18.511 \
            A 40, 40, 0, 0, 1, -6.8397, -1.4894 z"
    cgoChamber = window.svgToCgo2D(chamber)

    # 利用鏈條起點與終點定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic(self, x1, y1, x2, y2, color="green", border=True, linewidth=4, scale=3):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgoChamber 為成員變數
        # 新的 shape 物件函式
        cmbr = shape(self.cgoChamber, {
                "fillColor": self.color,
                "border": self.border,
                "strokeColor": "tan",
                "lineWidth": self.linewidth })

        # hole 為原點位置
        # 新的 path 函式
        hole = path(shapedefs.circle(4))
        cmbr.appendPath(hole)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量 atan2 的轉角
        basic1.rotate(math.atan2(self.y2-self.y1, self.x2-self.x1)/deg-90)

        # 放大 scale 倍
        basic1.translate(self.x1, self.y1)
        basic1.scale(self.scale)
        cgo.render(basic1,False)

    # 利用鏈條起點與旋轉角度定義繪圖, 使用內定的 color, border 與 linewidth 變數
    def basic_rot(self, x1, y1, rot, color="green", border=True, linewidth=4, scale=3):
        self.x1 = x1
        self.y1 = y1
        self.rot = rot
        self.color = color
        self.border = border
        self.linewidth = linewidth
        self.scale = scale
        # 注意, cgoChamber 為成員變數
        cmbr = shape(self.cgoChamber, {
                "fillColor": self.color,
                "border": self.border,
                "strokeColor": "tan",
                "lineWidth": self.linewidth })

        # hole 為原點位置
        hole = path(shapedefs.circle(4))
        cmbr.appendPath(hole)
        # 根據旋轉角度, 計算 x2 與 y2
        x2 = self.x1 + 20*math.cos(self.rot*deg)
        y2 = self.y1 + 20*math.sin(self.rot*deg)

        # 複製 cmbr, 然後命名為 basic1
        basic1 = cmbr.dup()
        # 因為鏈條的角度由原點向下垂直, 所以必須轉 90 度, 再考量轉角
        basic1.rotate(self.rot-90)

        # 放大 scale 倍
        basic1.translate(self.x1, self.y1)
        basic1.scale(self.scale)
        cgo.render(basic1, False)

        return x2, y2

# 利用 chain class 建立案例, 對應到 mychain 變數
mychain = chain()

# 畫 A
# 左邊兩個垂直單元
x1, y1 = mychain.basic_rot(0, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
# 左斜邊兩個單元
x3, y3 = mychain.basic_rot(x2, y2, 80)
x4, y4 = mychain.basic_rot(x3, y3, 71)
# 最上方水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜邊兩個單元
x6, y6 = mychain.basic_rot(x5, y5, -71)
x7, y7 = mychain.basic_rot(x6, y6, -80)
# 右邊兩個垂直單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
x9, y9 = mychain.basic_rot(x8, y8, -90)
# 中間兩個水平單元
x10, y10 = mychain.basic_rot(x8, y8, -180)
mychain.basic(x10, y10, x1, y1, color="red")

# 畫 B
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+ 65, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 右上垂直向下單元
x7, y7 = mychain.basic_rot(x6, y6, -90)
# 右斜 240 度
x8, y8 = mychain.basic_rot(x7, y7, 210)
# 中間水平
mychain.basic(x8, y8, x2, y2)
# 右下斜 -30 度
x10, y10 = mychain.basic_rot(x8, y8, -30)
# 右下垂直向下單元
x11, y11 = mychain.basic_rot(x10, y10, -90)
# 右下斜 240 度
x12, y12 = mychain.basic_rot(x11, y11, 210)
# 水平接回起點
mychain.basic(x12,y12, 0, 0, color="red")

# 畫 C
# 上半部
# 左邊中間垂直起點, 圓心位於線段中央, y 方向再向上平移兩個鏈條圓心距單位
x1, y1 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), 90)
# 上方轉 80 度
x2, y2 = mychain.basic_rot(x1, y1, 80)
# 上方轉 30 度
x3, y3 = mychain.basic_rot(x2, y2, 30)
# 上方水平
x4, y4 = mychain.basic_rot(x3, y3, 0)
# 下半部, 從起點開始 -80 度
x5, y5 = mychain.basic_rot(0+65*2, -10+10+20*math.sin(80*deg)+20*math.sin(30*deg), -80)
# 下斜 -30 度
x6, y6 = mychain.basic_rot(x5, y5, -30)
# 下方水平單元
x7, y7 = mychain.basic_rot(x6, y6, -0, color="red")


# 畫 D
# 左邊四個垂直單元
x1, y1 = mychain.basic_rot(0+65*3, 0, 90)
x2, y2 = mychain.basic_rot(x1, y1, 90)
x3, y3 = mychain.basic_rot(x2, y2, 90)
x4, y4 = mychain.basic_rot(x3, y3, 90)
# 上方一個水平單元
x5, y5 = mychain.basic_rot(x4, y4, 0)
# 右斜 -40 度
x6, y6 = mychain.basic_rot(x5, y5, -40)
x7, y7 = mychain.basic_rot(x6, y6, -70)
# 右中垂直向下單元
x8, y8 = mychain.basic_rot(x7, y7, -90)
# -110 度
x9, y9 = mychain.basic_rot(x8, y8, -100)
# -150
x10, y10 = mychain.basic_rot(x9, y9, -150)
# 水平接回原點
mychain.basic(x10, y10, 0+65*3, 0, color="red")
&lt;/script&gt;

&lt;!-- Cango 繪圖程式 --&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="can1_editor", console_id="can1_console", container_id="can1_container", storage_id="can1_py_src" )

Ace.editor.setValue('''#Cango 繪圖
from browser import window
import math
cos30 = math.cos(30*math.pi/180)
sin30 = math.sin(30*math.pi/180)

# Javascript 物件
cango = window.Cango.new
path = window.Path.new
shape = window.Shape.new
# Javascript 變數
shapedefs = window.shapeDefs
g1 = cango("can1_container")
g1.clearCanvas()
g1.gridboxPadding(10, 10, 5, 7)
g1.fillGridbox("lightgreen")
g1.setWorldCoordsRHC(0, 0, 80)

g1.drawText("gc.setWorldCoordsRHC() 設為 Y 向上為正", {'x':3, 'y':52, 'fontSize': 30, 'fillColor':"black"})
g1.drawText("X", {'x':60, 'y':2, 'fontSize': 30, 'fontWeight': 800, 'lorg': 9, 'fillColor': "black"});
g1.drawText("Y", {'x':2, 'y':30, 'fontSize': 30, 'fontWeight': 800, 'lorg': 1, 'fillColor': "black"});

g1.drawArrow(60, 0, {'shaftWidth':2.5, 'fillColor':'black'});
g1.drawArrow(0, 30, {'shaftWidth':2.5, 'fillColor':'black'});
g1.drawPath(["M", 0,0, "L", 35*cos30, 35*sin30, 0, 0]);
g1.drawArrowArc(25, 0, 30, {'clockwise':False, 'shaftWidth':2.5, 'fillColor':'black'});
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['can1_run'].bind('click', Ace.run)
doc['can1_show_console'].bind('click', Ace.show_console)
doc['can1_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="can1_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="can1_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('can1_py_src', 'can1_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="can1_run"&gt;Run&lt;/button&gt;
&lt;button id="can1_show_console"&gt;Output&lt;/button&gt;
&lt;button id="can1_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="can1_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;canvas id="can1_container" width="750" height="550"&gt;&lt;/canvas&gt;&lt;/p&gt;
&lt;!-- Cango 繪圖程式2 --&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="can2_editor", console_id="can2_console", container_id="can2_container", storage_id="can2_py_src" )

Ace.editor.setValue('''#Cango 繪圖
from browser import window
import math
cos30 = math.cos(30*math.pi/180)
sin30 = math.sin(30*math.pi/180)

# Javascript 物件
cango = window.Cango.new
path = window.Path.new
shape = window.Shape.new
# Javascript 變數
shapedefs = window.shapeDefs
g1 = cango("can2_container")
g1.clearCanvas()
g1.gridboxPadding(10, 10, 5, 7)
g1.fillGridbox("lightpink")
g1.setWorldCoordsSVG(0, 0, 100)

g1.drawText("gc.setWorldCoordsSVG() 設為 Y 向下為正", {'x':2, 'y':-6, 'fontSize': 30, 'fillColor':"black"})
g1.drawText("X", {'x':60, 'y':2, 'fontSize': 30, 'fontWeight': 800, 'lorg': 3, 'fillColor': "black"});
g1.drawText("Y", {'x':2, 'y':30, 'fontSize': 30, 'fontWeight': 800, 'lorg': 7, 'fillColor': "black"});

g1.drawArrow(60, 0, {'shaftWidth':2.5, 'fillColor':'black'});
g1.drawArrow(0, 30, {'shaftWidth':2.5, 'fillColor':'black'});
g1.drawPath(["M", 0,0, "L", 35*cos30, 35*sin30, 0, 0]);
g1.drawArrowArc(25, 0, 30, {'clockwise':False, 'shaftWidth':2.5, 'fillColor':'black'});
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['can2_run'].bind('click', Ace.run)
doc['can2_show_console'].bind('click', Ace.show_console)
doc['can2_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="can2_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="can2_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('can2_py_src', 'can2_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="can2_run"&gt;Run&lt;/button&gt;
&lt;button id="can2_show_console"&gt;Output&lt;/button&gt;
&lt;button id="can2_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="can2_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;canvas id="can2_container" width="750" height="550"&gt;&lt;/canvas&gt;&lt;/p&gt;
&lt;!-- Cango 繪圖程式3 --&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="can3_editor", console_id="can3_console", container_id="can3_container", storage_id="can3_py_src" )

Ace.editor.setValue('''#Cango Bezier 繪圖
from browser import window

# Javascript 物件
cango = window.Cango.new
path = window.Path.new
shape = window.Shape.new
group = window.Group.new
# Javascript 變數
shapedefs = window.shapeDefs
g1 = cango("can3_container")
g1.clearCanvas()
g1.gridboxPadding(10, 10, 5, 7)
g1.fillGridbox("lightgreen")
g1.setWorldCoordsRHC(-100, -100, 400)

x1 = 40
y1 = 20
cx1 = 90
cy1 = 120
x2 = 120
y2 = 100
cx2 = 130
cy2 = 20
cx3 = 150
cy3 = 120
x3 = 180
y3 = 60

def dragC1(mousePos):
    global cx1, cy1
    cx1 = mousePos.x
    cy1 = mousePos.y
    drawCurve()

def dragC2(mousePos):
    global cx2, cy2
    cx2 = mousePos.x
    cy2 = mousePos.y
    drawCurve()

def dragC3(mousePos):
    global cx3, cy3
    cx3 = mousePos.x
    cy3 = mousePos.y
    drawCurve()

def drawCurve():
    qbez = path(['M', x1, y1, 'Q', cx1, cy1, x2, y2], {
      'strokeColor':'blue'})
    cbez = path(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], {
      'strokeColor':'green'})
    L1 = path(['M', x1, y1, 'L', cx1, cy1, x2, y2], {
      'strokeColor':"rgba(0, 0, 0, 0.2)",
      'dashed':[4]})
    L2 = path(['M', x2, y2, 'L', cx2, cy2], {
      'strokeColor':"rgba(0, 0, 0, 0.2)",
      'dashed':[4]})
    L3 = path(['M', x3, y3, 'L', cx3, cy3], {
      'strokeColor':"rgba(0, 0, 0, 0.2)",
      'dashed':[4]})
    c1.transform.translate(cx1, cy1)
    c2.transform.translate(cx2, cy2)
    c3.transform.translate(cx3, cy3)
    grp = group(qbez, cbez, L1, L2, L3, c1, c2, c3)
    g1.render(grp, True)

g1.clearCanvas("lightyellow")
g1.deleteAllLayers()
g1.setWorldCoordsRHC(0, 0, 200)

c1 = shape(shapedefs.circle(6), {'fillColor':'red'})
c1.enableDrag(None, dragC1, None)

c2 = shape(shapedefs.circle(6), {'fillColor':'red'})
c2.enableDrag(None, dragC2, None)

c3 = shape(shapedefs.circle(6), {'fillColor':'red'})
c3.enableDrag(None, dragC3, None);

drawCurve()
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['can3_run'].bind('click', Ace.run)
doc['can3_show_console'].bind('click', Ace.show_console)
doc['can3_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="can3_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="can3_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('can3_py_src', 'can3_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="can3_run"&gt;Run&lt;/button&gt;
&lt;button id="can3_show_console"&gt;Output&lt;/button&gt;
&lt;button id="can3_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="can3_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;canvas id="can3_container" width="750" height="550"&gt;&lt;/canvas&gt;&lt;/p&gt;</content><category term="Cango"></category><category term="Brython"></category><category term="SVG"></category><category term="Canvas"></category></entry><entry><title>Brython 3.3.4 程式環境</title><link href="https://kmolab.github.io/blog/brython-programming-environment.html" rel="alternate"></link><published>2017-10-25T11:00:00+08:00</published><updated>2017-10-25T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-10-25:/blog/brython-programming-environment.html</id><summary type="html">&lt;p&gt;利用 &lt;a href="http://brython.info/"&gt;Brython&lt;/a&gt; 與 &lt;a href="https://ace.c9.io/"&gt;Ace&lt;/a&gt; 編輯器, 建立瀏覽器上的簡單 Python3 程式練習環境.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;利用 &lt;a href="http://brython.info/"&gt;Brython&lt;/a&gt; 與 &lt;a href="https://ace.c9.io/"&gt;Ace&lt;/a&gt; 編輯器, 建立瀏覽器上的簡單 Python3 程式練習環境.&lt;/p&gt;


&lt;!-- 導入 FileSaver 與 filereader --&gt;

&lt;script type="text/javascript" src="./../ace/FileSaver.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="./../ace/filereader.js"&gt;&lt;/script&gt;

&lt;!-- 導入最新版的 Brython 標準程式庫 3.3.4 --&gt;

&lt;script type="text/javascript" src="./../data/Brython-3.3.4/brython_dist.js"&gt;
&lt;/script&gt;

&lt;!-- 導入平面機構模擬所需程式庫 --&gt;

&lt;!-- sylvester.js 為向量、矩陣與幾何程式庫 http://sylvester.jcoglan.com/ --&gt;

&lt;script src="./../data/sylvester/sylvester.js"&gt;&lt;/script&gt;

&lt;!-- PrairieDraw.js 為延伸 sylvester.js 的 html5 canvas 繪圖應用程式庫 https://github.com/martin70/PrairieDraw.js --&gt;

&lt;script src="./../data/sylvester/PrairieDraw.js"&gt;&lt;/script&gt;

&lt;style&gt;
canvas {
    border: 1px solid black;
}
&lt;/style&gt;

&lt;!-- 啟動 Brython 時, 設定 pythonpath 為 data/py, 並將 script1.py 放入, 以便取代 3.2.9 之前版本的 script id 導入 --&gt;

&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;!-- 以下執行 Brython 程式 --&gt;

&lt;script src="./../ace/ace.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/ext-language_tools.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/mode-python3.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;script src="./../ace/snippets/python.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;

&lt;!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--&gt;

&lt;script type="text/javascript"&gt;
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
&lt;/script&gt;

&lt;p&gt;編寫 Python3 程式邏輯之前必須先了解基本的程式語法, 其中包括:&lt;/p&gt;
&lt;h2&gt;Python3 變數命名規則與關鍵字&lt;/h2&gt;
&lt;p&gt;Python 英文變數命名規格&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;變數必須以英文字母大寫或小寫或底線開頭
變數其餘字元可以是英文大小寫字母, 數字或底線
變數區分英文大小寫
變數不限字元長度
不可使用關鍵字當作變數名稱
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用者可以利用以下程式列出所使用 Python 的版次與關鍵字:&lt;/p&gt;
&lt;!-- 印出版次與關鍵字程式 --&gt;

&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )

Ace.editor.setValue('''# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword

# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="kw_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="kw_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('kw_py_src', 'kw_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="kw_run"&gt;Run&lt;/button&gt;
&lt;button id="kw_show_console"&gt;Output&lt;/button&gt;
&lt;button id="kw_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="kw_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;Python3 的程式關鍵字, 使用者命名變數時, 必須避開下列保留字.&lt;/p&gt;
&lt;p&gt;Python keywords:  ['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']&lt;/p&gt;
&lt;p&gt;選擇好的變數名稱:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;使用有意義且適當長度的變數名稱， 例如: 使用 length 代表長度, 不要單獨使用 l 或 L, 也不要使用 this_is_the_length
程式前後變數命名方式盡量一致, 例如: 使用 rect_length 或 RectLength
用底線開頭的變數通常具有特殊意義
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;print() 函式用法&lt;/h2&gt;
&lt;p&gt;print() 為 Python 程式語言中用來列印數值或字串的函式, 其中有 sep 變數定義分隔符號, ｓep 內定為 ",", end 變數則用來定義列印結尾的符號, end 內定為跳行符號.&lt;/p&gt;
&lt;h2&gt;for 迴圈用法與 Python 的縮排規定&lt;/h2&gt;
&lt;p&gt;重複迴圈用法, 使用者可以透過下列程式編輯區練習 for 迴圈與 print() 函式的用法.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="editor", console_id="console", container_id="first_container", storage_id="py_src" )

Ace.editor.setValue('''#ex1 簡單的 for 迴圈範例
for i in range(10):
    print(i)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['run'].bind('click', Ace.run)
doc['show_console'].bind('click', Ace.show_console)
doc['clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('py_src', 'filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="run"&gt;Run&lt;/button&gt;
&lt;button id="show_console"&gt;Output&lt;/button&gt;
&lt;button id="clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;!-- 以下置入 brython turtle 繪圖程式段, 但是各畫布必須使用不同名稱 --&gt;

&lt;p&gt;下列的 Brython turtle 網際繪圖程式僅提供參考, 可以用來練習 Python3 程式語法.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="turtle_editor", console_id="turtle_console", container_id="container", storage_id="turtle_py_src" )

Ace.editor.setValue('''import turtle
t=turtle.Turtle()

t.penup()
t.left(45)
t.backward(125)
t.right(45)
t.pendown()

for c in ['red', 'green', 'yellow', 'blue']:
    t.color(c)
    t.forward(75)
    t.left(90)

t1=turtle.Turtle("turtle")
t1.penup()

t1.pendown()
t1.width(3)
for c in ['red', 'blue', 'yellow', 'green', 'purple', 'brown']:
    t1.color(c)
    t1.forward(50)
    t1.left(60)

t1.penup()
t1.left(60)
t1.backward(120)

t1.pendown()
t1.color('red')
t1.write("I love Brython!!")

turtle._Screen().end()
''')

Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

doc['turtle_run'].bind('click', Ace.run)
doc['turtle_show_console'].bind('click', Ace.show_console)
doc['turtle_clear_console'].bind('click', Ace.clear_console)
doc['turtle_clear_container'].bind('click', Ace.clear_container)
&lt;/script&gt;

&lt;div id="turtle_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="turtle_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('tutle_py_src', 'turtle_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="turtle_run"&gt;Run&lt;/button&gt;
&lt;button id="turtle_show_console"&gt;Output&lt;/button&gt;
&lt;button id="turtle_clear_console"&gt;清除&lt;/button&gt;
&lt;button id="turtle_clear_container"&gt;清除畫布&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="turtle_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;!-- container 主要提供網際繪圖用之畫布 --&gt;

&lt;div id="container"&gt;&lt;/div&gt;

&lt;h2&gt;函式用法與呼叫&lt;/h2&gt;
&lt;p&gt;使用者可以利用下列程式, 練習 def 函式定義與呼叫的用法.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="fun_editor", console_id="fun_console", container_id="fun_container", storage_id="fun_py_src" )

Ace.editor.setValue('''# 定義函式
def square_of_x(x):
    return x*x

# 呼叫函式
y = square_of_x(3)
# 列印 y 對應內容
print(y)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['fun_run'].bind('click', Ace.run)
doc['fun_show_console'].bind('click', Ace.show_console)
doc['fun_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="fun_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="fun_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('fun_py_src', 'fun_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="fun_run"&gt;Run&lt;/button&gt;
&lt;button id="fun_show_console"&gt;Output&lt;/button&gt;
&lt;button id="fun_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="fun_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;!-- Brython 的網際繪圖 --&gt;

&lt;p&gt;以下網際繪圖程式, 僅提供參考.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="by_editor", console_id="by_console", container_id="by_container", storage_id="by_py_src" )

Ace.editor.setValue('''# First of all, the import of some libraries
from browser import document as doc
from browser import html

# All the elements will be inserted in the div with the "container" id
container = doc['by_container']

# We create a new div element
newdiv = html.DIV(id = "new-div")
# Now we add some style
newdiv.style = {"padding": "5px", 
               "backgroundColor": "#ADD8E6"}

# Now, lets add a table with a column with numbers and a
# column with a word on each cell
text = "Brython is really cool"
textlist = text.split()
table = html.TABLE()
for i, word in enumerate(textlist):
    table &lt;= html.TR(html.TD(i + 1) + 
                     html.TD(word))
# Now we add some style to the table
table.style = {"padding": "5px", 
               "backgroundColor": "#aaaaaa",
               "width": "100%"}
# Now we add the table to the new div previously created
newdiv &lt;= table + html.BR()

# a form? why not?
form = html.FORM()
input1 = html.INPUT(type="text", name="firstname", value="First name")
input2 = html.INPUT(type="text", name="lastname", value="Last name")
input3 = html.BUTTON("Button with no action!")
form &lt;= input1 + html.BR() + input2 + html.BR() + input3

newdiv &lt;= form + html.BR()

# Finally, we will add something more 'HTML5istic', a canvas with
# a color gradient in the newdiv previously created and below the form
canvas = html.CANVAS(width = 300, height = 300)
#canvas.style = {"width": "100%"}
ctx = canvas.getContext('2d')
ctx.rect(0, 0, 300, 300)
grd = ctx.createRadialGradient(150, 150, 10, 150, 150, 150)
grd.addColorStop(0, '#8ED6FF')
grd.addColorStop(1, '#004CB3')
ctx.fillStyle = grd
ctx.fill()

newdiv &lt;= canvas
# And finally we append the newdiv element
# to the parent, in this case the div with the "container" id
container &lt;= newdiv
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['by_run'].bind('click', Ace.run)
doc['by_show_console'].bind('click', Ace.show_console)
doc['by_clear_console'].bind('click', Ace.clear_console)
doc['by_clear_container'].bind('click', Ace.clear_container)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="by_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="by_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('by_py_src', 'by_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="by_run"&gt;Run&lt;/button&gt;
&lt;button id="by_show_console"&gt;Output&lt;/button&gt;
&lt;button id="by_clear_console"&gt;清除&lt;/button&gt;
&lt;button id="by_clear_container"&gt;清除畫布&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="by_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div id="by_container"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;!-- Brython 動畫 --&gt;

&lt;p&gt;以下網際動態繪圖程式, 僅提供參考.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="clock_editor", console_id="clock_console", container_id="clock_container", storage_id="clock_py_src" )

Ace.editor.setValue('''# First of all, the import of some libraries
import time
import math
import datetime
from browser import document as doc
import browser.timer
from browser import html

sin,cos = math.sin,math.cos
width,height = 250,250 # canvas dimensions
ray = 100 # clock ray

# All the elements will be inserted in the div with the "container" id
container = doc['clock_container']

# We create a new div element
newdiv = html.DIV(id = "new-div")
# Now we add some style
newdiv.style = {"padding": "5px", 
               "backgroundColor": "#ADD8E6"}

canvas = html.CANVAS(width = width, height = height)
#canvas.style = {"width": "100%"}
ctx = canvas.getContext('2d')

def needle(angle,r1,r2,color="#000000"):
    # draw a needle at specified angle in specified color
    # r1 and r2 are percentages of clock ray
    x1 = width/2-ray*cos(angle)*r1
    y1 = height/2-ray*sin(angle)*r1
    x2 = width/2+ray*cos(angle)*r2
    y2 = height/2+ray*sin(angle)*r2
    ctx.beginPath()
    ctx.strokeStyle = color
    ctx.moveTo(x1,y1)
    ctx.lineTo(x2,y2)
    ctx.stroke()

def set_clock():
    # erase clock
    ctx.beginPath()
    ctx.fillStyle = "#FFF"
    ctx.arc(width/2,height/2,ray*0.89,0,2*math.pi)
    ctx.fill()

    # redraw hours
    show_hours()

    # print day
    now = datetime.datetime.now()
    day = now.day
    ctx.font = "bold 14px Arial"
    ctx.textAlign = "center"
    ctx.textBaseline = "middle"
    ctx.fillStyle="#FFF"
    ctx.fillText(day,width*0.7,height*0.5)

    # draw needles for hour, minute, seconds    
    ctx.lineWidth = 3
    hour = now.hour%12 + now.minute/60
    angle = hour*2*math.pi/12 - math.pi/2
    needle(angle,0.05,0.5)
    minute = now.minute
    angle = minute*2*math.pi/60 - math.pi/2
    needle(angle,0.05,0.85)
    ctx.lineWidth = 1
    second = now.second+now.microsecond/1000000
    angle = second*2*math.pi/60 - math.pi/2
    needle(angle,0.05,0.85,"#FF0000") # in red

browser.timer.set_interval(set_clock,100)

ctx.beginPath()
ctx.lineWidth = 10
ctx.arc(width/2,height/2,ray,0,2*math.pi)
ctx.stroke()

for i in range(60):
    ctx.lineWidth = 1
    if i%5 == 0:
        ctx.lineWidth = 3
    angle = i*2*math.pi/60 - math.pi/3
    x1 = width/2+ray*cos(angle)
    y1 = height/2+ray*sin(angle)
    x2 = width/2+ray*cos(angle)*0.9
    y2 = height/2+ray*sin(angle)*0.9
    ctx.beginPath()
    ctx.moveTo(x1,y1)
    ctx.lineTo(x2,y2)
    ctx.stroke()

def show_hours():
    ctx.beginPath()
    ctx.arc(width/2,height/2,ray*0.05,0,2*math.pi)
    ctx.fillStyle = "#000"
    ctx.fill()
    for i in range(1,13):
        angle = i*math.pi/6-math.pi/2
        x3 = width/2+ray*cos(angle)*0.75
        y3 = height/2+ray*sin(angle)*0.75
        ctx.font = "20px Arial"
        ctx.textAlign = "center"
        ctx.textBaseline = "middle"
        ctx.fillText(i,x3,y3)
    # cell for day
    ctx.fillStyle = "#000"
    ctx.fillRect(width*0.65,height*0.47,width*0.1,height*0.06)

show_hours()
set_clock()

newdiv &lt;= canvas
# And finally we append the newdiv element
# to the parent, in this case the div with the "container" id
container &lt;= newdiv
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['clock_run'].bind('click', Ace.run)
doc['clock_show_console'].bind('click', Ace.show_console)
doc['clock_clear_console'].bind('click', Ace.clear_console)
doc['clock_clear_container'].bind('click', Ace.clear_container)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="clock_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="clock_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('clock_py_src', 'clock_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="clock_run"&gt;Run&lt;/button&gt;
&lt;button id="clock_show_console"&gt;Output&lt;/button&gt;
&lt;button id="clock_clear_console"&gt;清除&lt;/button&gt;
&lt;button id="clock_clear_container"&gt;清除畫布&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="clock_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;div id="clock_container"&gt;&lt;/div&gt;&lt;/p&gt;
&lt;h2&gt;基本物件導向與案例&lt;/h2&gt;
&lt;p&gt;Python 採用類別 (class) 將案例變數 (instance variables) 與案例方法 (instance methods) 包在一起, 並用來定義一種物件 (object).&lt;/p&gt;
&lt;p&gt;物件導向具有封裝 (encapsulation) , 繼承 (inheritance) 與多形 ( polymorphism) 等三種特性.&lt;/p&gt;
&lt;!-- oop 範例 --&gt;

&lt;p&gt;使用者可以利用下列程式練習 Python3 物件的定義與應用.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="oop1_editor", console_id="oop1_console", container_id="oop1_container", storage_id="oop1_py_src" )

Ace.editor.setValue('''# Robot class 定義
class Robot(object):
    def __init__(self, name, by):
        self._name = name
        self._build_year = by

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, newname):
        self._name = name

    @property
    def build_year(self):
        return self._build_year

    @build_year.setter
    def build_year(self, newby):
        self._build_year = newby

x = Robot("bob", 1993)
x.build_year = 1993
print(x.name)
print(x.build_year)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['oop1_run'].bind('click', Ace.run)
doc['oop1_show_console'].bind('click', Ace.show_console)
doc['oop1_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="oop1_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="oop1_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('oop1_py_src', 'oop1_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="oop1_run"&gt;Run&lt;/button&gt;
&lt;button id="oop1_show_console"&gt;Output&lt;/button&gt;
&lt;button id="oop1_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="oop1_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;!-- 必須處理重複執行後機構模擬產生錯誤的問題 --&gt;

&lt;p&gt;以下平面機構動態模擬程式, 僅提供參考.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
import ace

Ace = ace.Editor(editor_id="link_editor", console_id="link_console", container_id="fourbar", storage_id="link_py_src" )

Ace.editor.setValue('''# 導入所需模組
from browser import document as doc
from browser import window
from browser import timer
from browser import html
import math

# 利用 window 擷取 PrairieDraw 程式庫變數物件, 然後以 new 方法轉為 Brython 變數
pdraw = window.PrairieDraw.new
# 利用 window 擷取 PrairieDrawAnim 程式庫變數物件, 然後以 new 方法轉為 Brython 變數
PrairieDrawAnim = window.PrairieDrawAnim.new

# 利用 window 擷取 sylvester 程式庫變數物件 Vector, 並將其 create 方法直接轉為 Brython 變數
# 在 sylvester 中的 $V 簡化變數無法直接在 Brython 程式中引用
vector = window.Vector.create

# 在 "fourbar" 畫布中建立 panim 動態模擬案例
panim = PrairieDrawAnim("fourbar")

# 平面連桿繪圖以 t = 0 起始
t = 0
# 控制轉動方向變數
direction = True

# 繪製不同 t 時間下的平面連桿
def draw():
    global t, direction, fast
    # 設定模擬繪圖範圍
    panim.setUnits(6, 6)
    # 設定箭頭線寬
    panim.setProp("arrowLineWidthPx",2)

    # 起始變數設定
    omega = 1
    length_bar1 = 1
    length_bar2 = 26/18
    length_bar3 = 2
    length_base = 40/18
    time = 0

    # 畫出地面直線
    G = vector([0, -0.5])
    panim.ground(G, vector([0, 1]), 10)

    # 連桿長度與角度計算
    A = t*omega # "theta"
    AD = length_bar1 #length of left bar
    AB = length_base #distance between two stationary pivots
    BC = length_bar3 #length of right bar
    CD = length_bar2 #length of middle bar
    BD = math.sqrt(AD*AD + AB*AB - 2*AD*AB*math.cos(A))
    C = math.acos((BC*BC + CD*CD - BD*BD)/(2*BC*CD))
    ABD = math.asin(CD * math.sin(C) / BD)
    DBC = math.asin(AD * math.sin(A) / BD)
    B = ABD + DBC
    D = math.pi - B - C

    # draw pivot
    pivot_left = vector([AB/-2, 0])
    pivot_right = vector([AB/2, 0])
    panim.pivot(vector([pivot_left.e(1), -0.5]), pivot_left, 0.5)
    panim.pivot(vector([pivot_right.e(1), -0.5]), pivot_right, 0.5)

    # 儲存轉換矩陣
    panim.save()
    #FIRST BAR
    panim.translate(pivot_left)
    panim.rotate(A)
    panim.rod(vector([0,0]), vector([AD,0]), 0.25)
    panim.point(vector([0,0]))

    #SECOND BAR
    panim.translate(vector([AD,0]))
    panim.rotate(A*-1)  #"undo" the original A rotation
    panim.rotate(D)     #rotate by D only
    panim.rod(vector([0,0]), vector([CD,0]), 0.25)
    panim.point(vector([0,0]))

    #THIRD BAR
    panim.translate(vector([CD,0]))
    panim.rotate(math.pi+C)
    panim.rod(vector([0,0]), vector([BC,0]), 0.25)
    panim.point(vector([0,0]))
    # 回復原先的轉換矩陣
    panim.restore()

    panim.point(vector([pivot_right.e(1), 0]))
    # 時間增量
    if direction == True:
        t += 0.08
    else:
        t += -0.08

# 先畫出 t = 0 的連桿機構
draw()

# 將 anim 設為 None
anim = None

def launchAnimation(ev):
    global anim
    # 初始啟動, anim 為 None
    if anim is None:
        # 每 0.08 秒執行一次 draw 函式繪圖
        anim = timer.set_interval(draw, 80)
        # 初始啟動後, 按鈕文字轉為"暫停"
        doc['power'].text = '暫停'
    elif anim == 'hold':
        # 當 anim 為 'hold' 表示曾經暫停後的啟動, 因此持續以 set_interval() 持續旋轉, 且將 power 文字轉為"暫停"
        anim = timer.set_interval(draw, 80)
        doc['power'].text = '暫停'
    else:
        # 初始啟動後, 使用者再按 power, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停
        # 且將 anim 變數設為 'hold', 且 power 文字轉為"繼續"
        timer.clear_interval(anim)
        anim = 'hold'
        doc['power'].text = '繼續'

def reverse(ev):
    global anim, direction
    # 當 anim 為 hold 時, 按鈕無效
    if anim != "hold":
        if direction == True:
            direction = False
        else:
            direction = True

doc["power"].bind("click", launchAnimation)
doc["reverse"].bind("click", reverse)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['link_run'].bind('click', Ace.run)
doc['link_show_console'].bind('click', Ace.show_console)
doc['link_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="link_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="link_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('link_py_src', 'link_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="link_run"&gt;Run&lt;/button&gt;
&lt;button id="link_show_console"&gt;Output&lt;/button&gt;
&lt;button id="link_clear_console"&gt;清除&lt;/button&gt;
&lt;button id="power"&gt;啟動&lt;/button&gt;
&lt;button id="reverse"&gt;反向&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="link_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;
&lt;canvas id="fourbar" width="250" height="250"&gt;&lt;/canvas&gt;&lt;/p&gt;
&lt;h2&gt;平面機構運動模擬&lt;/h2&gt;
&lt;p&gt;以下為 Jansen's 八連桿機構的基本 Kinematic 運算, 先採用 Sympy 以符號式推導出機構端點的運動軌跡方程式後, 利用 Python 執行數值分析運算, 列出機構端點的座標.&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
# 表示要導入 data/py/ace.py
import ace

Ace = ace.Editor(editor_id="jansen_editor", console_id="jansen_console", container_id="jansen_container", storage_id="jansen_py_src" )

Ace.editor.setValue('''#jansen 多連桿機構驗算
from math import pi, cos, sin, sqrt, acos

radian = 180/pi
degree = pi/180

#PLAP
def plap(ax, ay, ac, bac, bx, by, ccw):
    if ccw == 1:
        cx= ac*cos(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac - acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    else:
        cx= ac*cos(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ax 
        cy= ac*sin(bac + acos((ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 + abs(ax - bx)**2 - abs(ay - by)**2)/(2*sqrt(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2)*abs(ax - bx)))) + ay
    return cx, cy

#PLLP
def pllp(ax, ay, ac, cb, bx, by, cw):
    if cw == 1:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 - sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(-ax + bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    else:
        cx =  -((ay - by)*(-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx)) + (ac**2 - ax**2 - ay**2 + bx**2 + by**2 - cb**2)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))/(2*(ax - bx)*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
        cy =  (-ac**2*ay + ac**2*by + ax**2*ay + ax**2*by - 2*ax*ay*bx - 2*ax*bx*by + ay**3 - ay**2*by + ay*bx**2 - ay*by**2 + ay*cb**2 + bx**2*by + by**3 - by*cb**2 + sqrt((-ac**2 + 2*ac*cb + ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2 - cb**2)*(ac**2 + 2*ac*cb - ax**2 + 2*ax*bx - ay**2 + 2*ay*by - bx**2 - by**2 + cb**2))*(ax - bx))/(2*(ax**2 - 2*ax*bx + ay**2 - 2*ay*by + bx**2 + by**2))
    return cx, cy

ax = -38
ay = 0
# b 為原點
bx = 0
by = 0
cx = 0
cy = 7.8
# m 為配合 PLAP 新增固定點
mx = 30
my = 7.8
# dcm ccw 方向角度
dcm = 30*degree
cd = 15
# 三角形 dcm 為 ccw plap d=(a, cd, dcm, m)
dx, dy = plap(cx, cy, cd, dcm, mx, my, ccw=1)
print("dx=", dx, "dy=", dy)
# 三角形 aed 為 cw pllp e=(a, ae, ed, d)
ae = 41.5
ed = 50
ex, ey = pllp(ax, ay, ae, ed, dx, dy, cw=1)
print("ex=", ex, "ey=", ey)
# 三角形 afe 為 cw pllp f=(a, af, fe, e)
af = 40.1
fe = 55.8
fx, fy = pllp(ax, ay, af, fe, ex, ey, cw=1)
print("fx=", fx, "fy=", fy)
# 三角形 dha 為 cw pllp h=(d, dh, ha, a)
dh = 61.9
ha = 39.3
hx, hy = pllp(dx, dy, dh, ha, ax, ay, cw=1)
print("hx=", hx, "hy=", hy)
# 三角形 hgf 為 cw pllp g=(h, hg, gf, f)
hg = 36.7
gf = 39.4
gx, gy = pllp(hx, hy, hg, gf, fx, fy, cw=1)
print("gx=", gx, "gy=", gy)
# 三角形 hkg 為 cw pllp k=(h, hk, kg, g)
hk = 49
kg = 65.7
kx, ky = pllp(hx, hy, hk, kg, gx, gy, cw=1)
print("kx=", kx, "ky=", ky)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['jansen_run'].bind('click', Ace.run)
doc['jansen_show_console'].bind('click', Ace.show_console)
doc['jansen_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="jansen_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="jansen_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('jansen_py_src', 'jansen_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="jansen_run"&gt;Run&lt;/button&gt;
&lt;button id="jansen_show_console"&gt;Output&lt;/button&gt;
&lt;button id="jansen_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="jansen_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;以下為與上述 Jansen's 八連桿機構對應的座標驗證圖, 機構端點座標 kx= -30.81 ky= -84.02:&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/images/jansen_sympy.png" width="800" height="600"&gt;&lt;/img&gt;&lt;/p&gt;
&lt;h2&gt;平面機構數目合成&lt;/h2&gt;
&lt;p&gt;itertools module implements a number of iterator building blocks.&lt;/p&gt;
&lt;p&gt;itertools.product(*iterables, repeat=1) - Cartesian product of input iterables.&lt;/p&gt;
&lt;p&gt;根據 &lt;a href="http://www.iftomm2015.tw/IFToMM2015CD/PDF/OS2-048.pdf"&gt;http://www.iftomm2015.tw/IFToMM2015CD/PDF/OS2-048.pdf&lt;/a&gt; (or &lt;a href="./../data/pdf/An_Algorithm_for_the_Automatic_Sketching_of_Generalized_Kinematic_Chains.pdf"&gt;local download&lt;/a&gt;)&lt;/p&gt;
&lt;script type="text/python3"&gt;
from browser import document as doc
# 表示要導入 data/py/ace.py
import ace

Ace = ace.Editor(editor_id="numsyn_editor", console_id="numsyn_console", container_id="numsyn_container", storage_id="numsyn_py_src" )

Ace.editor.setValue('''#數目合成
from itertools import product

# NL links and NJ joints as inputs
class NumberSynthesis:
    def __init__(self, NL, NJ):
        self.NL = NL
        self.NJ = NJ

    @property
    def Mmax(self):
        if self.NL &lt;= self.NJ and self.NJ &lt;= (2*self.NL-3):
            return self.NJ - self.NL + 2
        elif (2*self.NL-3) &lt;= self.NJ and self.NJ &lt;= (self.NL*(self.NL-1)/2):
            return self.NL - 1
        else:
            raise ValueError("incorrect number.")

    @property
    def NLm(self):
        result = []
        correction = lambda l: sum((i+2)*l[i] for i in range(len(l))) == 2*self.NJ
        for symbols in product(range(self.NL+1), repeat=self.Mmax-2):
            NLMmax = self.NL - sum(symbols)
            answer = symbols+(NLMmax,)
            if correction(answer) and NLMmax&gt;=0:
                result.append(answer)
        return tuple(result)

a = NumberSynthesis(9, 11)
print("the maximum number of joints incident to a link: ", a.Mmax)
print("link assortments of the generalized kinematic chains: ", a.NLm)
''')
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['numsyn_run'].bind('click', Ace.run)
doc['numsyn_show_console'].bind('click', Ace.show_console)
doc['numsyn_clear_console'].bind('click', Ace.clear_console)
&lt;/script&gt;

&lt;!-- 用來顯示程式碼的 editor 區域 --&gt;

&lt;div id="numsyn_editor" style="width:600px;height:300px;"&gt;&lt;/div&gt;

&lt;!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --&gt;

&lt;form&gt;
    &lt;label&gt;Filename: &lt;input type="text" id="numsyn_filename" placeholder="input file name"/&gt;.py&lt;/label&gt;
    &lt;input type="submit" value="Save" onclick="doSave('numsyn_py_src', 'numsyn_filename');"/&gt;
&lt;/form&gt;

&lt;p&gt;&lt;button id="numsyn_run"&gt;Run&lt;/button&gt;
&lt;button id="numsyn_show_console"&gt;Output&lt;/button&gt;
&lt;button id="numsyn_clear_console"&gt;清除&lt;/button&gt;
&lt;div style="width:100%;height:100%;"&gt;
&lt;textarea id="numsyn_console" autocomplete="off"&gt;&lt;/textarea&gt;
&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;目前所在頁面, 分別利用 &lt;a href="http://brython.info/"&gt;Brython&lt;/a&gt; 與 &lt;a href="https://ace.c9.io/"&gt;Ace&lt;/a&gt; 編輯器, 可直接在網誌中執行 Python3 程式, 基本架構為將 &lt;a href="http://brython.info/"&gt;Brython&lt;/a&gt; 的標準輸出轉到特定 div 標註, 而 &lt;a href="https://ace.c9.io/"&gt;Ace&lt;/a&gt; 編輯器則設為與其內的程式碼相同長度, 但至多只會在頁面中顯示 20 行, 且編輯器內的程式碼使用 12 號字元.&lt;/p&gt;
&lt;p&gt;ace.py 原始碼, 位於 data/py 目錄中, 將原先只能單一呼叫的函式改為物件, 可以在同一頁面中產生案例時, 透過各標註的 id 字串區分各段程式碼, 是本課程 Python3 物件導向程式的實際應用範例, 謹提供參考.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import sys
import time
import traceback
import javascript

from browser import document as doc, window, alert

if hasattr(window, 'localStorage'):
    from browser.local_storage import storage
else:
    storage = None

class cOutput:

    def __init__(self, target):
        self.target = doc[target]

    def write(self, data):
        self.target.value += str(data)

class Editor():

    def __init__(self, editor_id, console_id, container_id, storage_id):
        self.editor_id = editor_id
        self.console_id = console_id
        self.container_id = container_id
        self.storage_id = storage_id
        self.output = ''

        try:
            self.editor = window.ace.edit(self.editor_id)
            session = self.editor.getSession()
            session.setMode("ace/mode/python")

            self.editor.setOptions({
             'enableLiveAutocompletion': True,
             'enableSnippets': True,
             'highlightActiveLine': False,
             'highlightSelectedWord': True,
             'autoScrollEditorIntoView': True,
             # 'maxLines': session.getLength() 可以根據程式長度設定 editor 列數
             # 設定讓使用者最多可以在畫面中顯示 20 行程式碼
             'maxLines': 20,
             'fontSize': '12pt'
            })
        except:
            from browser import html
            self.editor = html.TEXTAREA(rows=20, cols=70)
            doc[self.editor_id] &amp;lt;= self.editor
            def get_value(): return self.editor.value
            def set_value(x): self.editor.value = x
            self.editor.getValue = get_value
            self.editor.setValue = set_value

    def run(self, *args):
        sys.stdout = cOutput(self.console_id)
        sys.stderr = cOutput(self.console_id)
        doc[self.console_id].value = ''
        src = self.editor.getValue()
        if storage is not None:
           storage[self.storage_id] = src

        t0 = time.perf_counter()
        try:
            #ns = {'__name__':'__main__'}
            # 以 self.editor_id 名稱執行程式
            ns = {'__name__': self.editor_id}
            exec(src, ns)
            state = 1
        except Exception as exc:
            traceback.print_exc(file=sys.stderr)
            state = 0
        self.output = doc[self.console_id].value

        print('&amp;lt;completed in %6.2f ms&amp;gt;' % ((time.perf_counter() - t0) * 1000.0))
        return state

    def show_console(self, ev):
        doc[self.console_id].value = self.output
        doc[self.console_id].cols = 60
        doc[self.console_id].rows = 10

    def clear_console(self, ev):
        doc[self.console_id].value = ""

    def clear_container(self, ev):
        doc[self.container_id].clear()

    # load a Python script
    def load_script(self, evt):
        _name = evt.target.value + '?foo=%s' % time.time()
        self.editor.setValue(open(_name).read())
&lt;/pre&gt;</content><category term="Brython"></category></entry><entry><title>CMSimfly 與 Fossil SCM</title><link href="https://kmolab.github.io/blog/cmsimfly-and-fossil-on-same-machine.html" rel="alternate"></link><published>2017-10-01T11:00:00+08:00</published><updated>2017-10-01T11:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-10-01:/blog/cmsimfly-and-fossil-on-same-machine.html</id><summary type="html">&lt;p&gt;&lt;a href="https://github.com/chiamingyen/cmsimfly"&gt;CMSimfly&lt;/a&gt; 是一套採用 Flask 應用程式框架編寫的網際內容管理系統 (Content Management System),  &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 則是以 ANSI C 編寫的軟體組態管理 (Software Configuration Management) 系統, 兩套程式各有不同的特色, CMSimfly 適合用來管理無版次的大型檔案, 而 Fossil SCM 則可用來記錄詳細的軟體設計開發歷程.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;a href="https://github.com/chiamingyen/cmsimfly"&gt;CMSimfly&lt;/a&gt; 是一套採用 Flask 應用程式框架編寫的網際內容管理系統 (Content Management System),  &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 則是以 ANSI C 編寫的軟體組態管理 (Software Configuration Management) 系統, 兩套程式各有不同的特色, CMSimfly 適合用來管理無版次的大型檔案, 而 Fossil SCM 則可用來記錄詳細的軟體設計開發歷程.&lt;/p&gt;


&lt;h2&gt;CMSimfly 與 Fossil SCM 安裝規劃&lt;/h2&gt;
&lt;p&gt;CMSimfly 採用 Python3 與 Flask 編寫, 可以採用 &lt;a href="https://github.com/unbit/uwsgi"&gt;uwsgi&lt;/a&gt; 模組啟動, 預計網際前端透過 Nginx https 埠號 8443 承接來自瀏覽器的請求, 而 Fossil SCM 的 http port 80 前端則由 Nginx 承接後, 直接跳轉 Stunnel 所代理的 https 服務. 因此當使用者以瀏覽器 http 連線, 伺服器會馬上跳轉 https 的 Fossil SCM, 假如要連結 CMSimfly, 則必須以 https 8443 連線.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/unbit/uwsgi"&gt;uwsgi&lt;/a&gt; 有多種啟動方式, 在此希望透過 Emperor 的多應用程式的模式啟動, 基本架構是,  uwsgi 指令在 /etc/rc.local 中以 exec 執行, 可以在伺服器開機時執行, 而 uwsgi Emperor  中指定以一般用戶身分執行, 實際封包在內部網路的 8081 啟動, 之後透過 /etc/nginx/sites-available/default 中的 server 設定, 只接受 8443 埠號的 IPv4 與 IPv6 網際瀏覽器請求.&lt;/p&gt;
&lt;h2&gt;CMSimfly 安裝設定&lt;/h2&gt;
&lt;p&gt;根據 uwsgi 與 Emperor 的啟動, 伺服器所需模組, 包括 pip3, Flask, python3 開發環境, uwsgi, nginx 與 uwsgi-plugin-python3 模組:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
sudo apt install python3-pip
sudo pip3 install Flask
sudo apt install build-essential python3-dev
sudo pip3 install uwsgi
sudo apt install nginx uwsgi-plugin-python3
&lt;/pre&gt;

&lt;p&gt;而 /etc/nginx/sites-available/default 的設定&lt;/p&gt;
&lt;pre class="brush:python"&gt;
server {
    listen 80 default_server;
    listen [::]:80 default_server;

    server_name _;
        return 301 https://my.server.host.name;
}

server {
    listen 8443 ssl;
    listen [::]:8443 ssl;

    location /static {
        alias /home/user/cmsimfly/static/;
    }

    location / {
        include uwsgi_params;
        uwsgi_pass  127.0.0.1:8081;
    }

    server_name my.server.host.name;
    ssl on;
    ssl_certificate /etc/nginx/ssl/nginx.crt;
    ssl_certificate_key /etc/nginx/ssl/nginx.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}
&lt;/pre&gt;

&lt;p&gt;位於 /home/user/uwsgi_ini/ 目錄下的 uwsgi.ini 檔案設定:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
[uwsgi]
socket = 127.0.0.1:8081 
uid = user
gid = user
plugins-dir = /usr/lib/uwsgi/plugins/
plugin = python3
master = true
process = 4
threads = 2
chdir = /home/user/cmsimfly
wsgi-file = /home/user/cmsimfly/wsgi.py
&lt;/pre&gt;

&lt;p&gt;假如希望額外啟動其他的 uwsgi 程式, 例如第二組 CMSimfly 或其他對應的 Flask 應用程式, 則需要在 /etc/nginx/sites-available/default 增加另外一組 server 設定, 主要在選定內部網路的特定埠號, 例如: 127.0.0.1:8082, 編寫 default 設定檔案成為:&lt;/p&gt;
&lt;pre class="brush:python"&gt;
server {
    listen 80 default_server;
    listen [::]:80 default_server;

    server_name _;
        return 301 https://my.server.host.name;
}

server {
    listen 8443 ssl;
    listen [::]:8443 ssl;

    location /static {
        alias /home/user/cmsimfly/static/;
    }

    location / {
        include uwsgi_params;
        uwsgi_pass  127.0.0.1:8081;
    }

    server_name my.server.host.name;
    ssl on;
    ssl_certificate /etc/nginx/ssl/nginx.crt;
    ssl_certificate_key /etc/nginx/ssl/nginx.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}

server {
    listen 9443 ssl;
    listen [::]:9443 ssl;

    location /static {
        alias /home/user/cmsimfly2/static/;
    }

    location / {
        include uwsgi_params;
        uwsgi_pass  127.0.0.1:8082;
    }

    server_name my.server.host.name;
    ssl on;
    ssl_certificate /etc/nginx/ssl/nginx.crt;
    ssl_certificate_key /etc/nginx/ssl/nginx.key;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}
&lt;/pre&gt;

&lt;p&gt;然後在 /home/user/uwsgi_ini 目錄中, 再配合增加一組 uwsgi2.ini, 內容為:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
[uwsgi]
socket = 127.0.0.1:8082
uid = user
gid = user
plugins-dir = /usr/lib/uwsgi/plugins/
plugin = python3
process = 4
threads = 2
chdir = /home/user/cmsimfly2
wsgi-file = /home/user/cmsimfly2/wsgi.py
&lt;/pre&gt;

&lt;p&gt;/etc/nginx/sites-available/default 與 /home/user/uwsgi_ini/uwsgi2.ini 設定修改後, 只要透過 /etc/init.d/nginx restart 重新啟動 Nginx, 並且重新執行 uwsgi 指令, 意即, uwsgi --emperor /home/user/uwsgi_ini, 納入 /home/user/uwsgi_ini/uwsgi.ini 與 /home/user/uwsgi_ini/uwsgi2.ini 的多 uwsgi Emperor 架構應用程式即可在 https://my.sever.host.name:9443 多一組 CMSimply 網際內容管理的伺服.&lt;/p&gt;
&lt;p&gt;若要讓伺服器在開機時執行 uwsgi, 則需要在/etc/rc.local 加入:&lt;/p&gt;
&lt;p&gt;exec uwsgi --emperor /home/user/uwsgi_ini&lt;/p&gt;
&lt;p&gt;過程中若需要重新啟動 nginx, 以 /etc/init.d/nginx restart 執行.&lt;/p&gt;
&lt;h2&gt;Fossil SCM 與 Stunnel 聯合啟動&lt;/h2&gt;
&lt;p&gt;因為在 Nginx /etc/nginx/sites-available/default 中已經將 port 80 的回應處理直接透過 http 301 狀態碼的宣告, 永久轉接到 https://my.server.host.name, 因此只要透過 Stunnel 代理在標準的 IPv4 與 IPv6 網路協定中, 以 https 啟動 Fossil SCM 即可.&lt;/p&gt;
&lt;p&gt;首先要安裝 Stunnel 與 Fossil SCM:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
sudo apt update
sudo apt install stunnel4 -y
sudo apt install fossil
&lt;/pre&gt;

&lt;p&gt;讓 Stunnel 開機時啟動:&lt;/p&gt;
&lt;p&gt;/etc/default/stunnel4 檔案設定, 將原先內定的 ENABLED=0 改為 1:&lt;/p&gt;
&lt;p&gt;ENABLED=1&lt;/p&gt;
&lt;p&gt;因為要以 https 設定 /etc/stunnel/stunnel.conf, 因此 /etc/stunnel 目錄中需要 stunnel.crt 與 stunnel.key.&lt;/p&gt;
&lt;p&gt;在 /etc/stunnel 目錄中執行 openssl 指令:&lt;/p&gt;
&lt;p&gt;sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout stunnel.key -out stunnel.crt&lt;/p&gt;
&lt;p&gt;然後設定 /etc/stunnel/stunnel.conf:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
[https]
accept = your.ipv4.ip:443
accept = :::443
cert = /etc/stunnel/localhost.crt
key = /etc/stunnel/localhost.key
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/user/ --https --nojail --notfound default
&lt;/pre&gt;

&lt;p&gt;重新啟動 stunnel 時, 執行 /etc/init.d/stunnel4&lt;/p&gt;</content><category term="2017fall"></category></entry><entry><title>2017 Fall 主機設定</title><link href="https://kmolab.github.io/blog/2017fall-srver-setup.html" rel="alternate"></link><published>2017-09-16T12:00:00+08:00</published><updated>2017-09-16T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-09-16:/blog/2017fall-srver-setup.html</id><summary type="html">&lt;p&gt;在 2017 年 Spring, 電腦輔助設計室購入兩台 HP 伺服器, 分別是 &lt;a href="https://www.hpe.com/h20195/v2/GetPDF.aspx/c04922941.pdf"&gt;HPE ProLiant ML10 Gen9 Server&lt;/a&gt; 與 &lt;a href="https://www.hpe.com/h20195/v2/getpdf.aspx/c04375628.pdf"&gt;HPE ProLiant ML350 Gen9 Server&lt;/a&gt;, 操作系統為 Ubuntu 16.04, 根據 &lt;a href="https://www.ubuntu.com/info/release-end-of-life"&gt;Ubuntu LTS 通告&lt;/a&gt;, 使用週期可至 2021 年, 預計在 2019 年 Spring 由新伺服器接手提供服務.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;在 2017 年 Spring, 電腦輔助設計室購入兩台 HP 伺服器, 分別是 &lt;a href="https://www.hpe.com/h20195/v2/GetPDF.aspx/c04922941.pdf"&gt;HPE ProLiant ML10 Gen9 Server&lt;/a&gt; 與 &lt;a href="https://www.hpe.com/h20195/v2/getpdf.aspx/c04375628.pdf"&gt;HPE ProLiant ML350 Gen9 Server&lt;/a&gt;, 操作系統為 Ubuntu 16.04, 根據 &lt;a href="https://www.ubuntu.com/info/release-end-of-life"&gt;Ubuntu LTS 通告&lt;/a&gt;, 使用週期可至 2021 年, 預計在 2019 年 Spring 由新伺服器接手提供服務.&lt;/p&gt;


&lt;h2&gt;近端、區網與雲端其實是同一端&lt;/h2&gt;
&lt;p&gt;自 2017 年 10 月起, 已經沒有免費的 OpenShift 雲端服務可以使用, 遠端較穩定的 html + javascript hosting 只剩下 Github Pages, 但是就課程與研究所需的近端、區網與雲端上的各項服務而言, 雲端的免費套餐終將越來越縮水的情況下, 強化近端與區網上的軟硬體服務, 將會更加重要.&lt;/p&gt;
&lt;p&gt;這個學期工作站室的伺服器, 將全面使用 &lt;a href="https://www.fossil-scm.org"&gt;Fossil SCM&lt;/a&gt; 管理所有的課程與研究專案, 每一位上課的學員都將在近端與區網擁有一個 Fossil 倉儲, 用來存放與課程相關的所有內容.&lt;/p&gt;
&lt;p&gt;Github 與 Bitbuckert 等雲端免費方案仍然扮演重要角色, 只是在無廣域網路連線與區域網路連線的情況下, 各學員的各項課程內容演練與操作資料提交, 將能在隨身的可攜系統上完成, 之後再配合區網與雲端網路的連線, 設法在分組協同的模式下, 將近端資料同步到區網與雲端主機. 因此 2017 Fall 起, 如何在近端、區網與雲端不同硬體環境下, 保持倉儲資料版本的同步, 就是另外一個重點.&lt;/p&gt;
&lt;h2&gt;主機設定&lt;/h2&gt;
&lt;p&gt;接下來, 我們透過 &lt;a href="https://cadpb.kmol.info/40523201"&gt;https://cadpb.kmol.info/40523201&lt;/a&gt; 學員倉儲, 來說明提供 Fossil SCM 服務的主機如何設定.&lt;/p&gt;
&lt;p&gt;首先當然是要先掌握 kmol.info 網域的主導權, 透過網域 DNS 的控管, 讓區域網路中的主機可以在 A 與 AAA 設定下的 IPv4 與 IPv6 網址呼應, 例如: cadpb.kmol.info 指的就是 cadp 電腦輔助設計實習課程中的 b 班所使用的伺服器名稱.&lt;/p&gt;
&lt;p&gt;如前所述, 這些伺服器都是安裝 Ubuntu 16.04 Server 操作系統 + OpenSSH, 目的是希望在 Self-signed Certificate 的模式下運作.&lt;/p&gt;
&lt;p&gt;接著必須根據 &lt;a href="create-a-multi-repository-fossil-scm-server.html"&gt;多 Fossil SCM 倉儲主機&lt;/a&gt; 的架構, 分別安裝 Fossil SCM 與 Stunnel.&lt;/p&gt;
&lt;p&gt;其中, 特別將 Fossil SCM 伺服的目錄指向 /home/cadpa2017, 表示各操作系統帳號所有人, 可以自行利用 fossil 指令, 建立多個倉儲, 此一模式就是同一台主機可以透過網域來界定上課班級, 操作系統帳號可以界定大分組名稱, 而採用學號的倉儲名稱則可以用來界定參與協同的所有者.&lt;/p&gt;
&lt;p&gt;因此, 一旦各倉儲所有者掌握管理該 .fossil 檔案的總管理權之後, 可以將其他學員納入自己所掌控的 .fossil users 中, 視實際需求賦於各帳號不同權限. 且可透過制式的 URL, 在得知各班各分組的成員學號情況下, 連結至各學員的倉儲中進行資料檢視.&lt;/p&gt;
&lt;h2&gt;機械設計專案的資料格式&lt;/h2&gt;
&lt;p&gt;由於設計是一種利用口語、文字、2D、3D、數學與實體等形式, 所完成的明確與具體表達, 過程中必須仔細思考、多方考量, 而且在不同時段與多人協同合作的結果, 將會產生許多不同的資料版本.&lt;/p&gt;
&lt;p&gt;加上二十一世紀的機械可說是各種固體、流體與軟體元件精巧組合而成, 能達成特定功能之器物. 因此機械設計專案過程所產生的各種資料及版本, 更需要特別關注並竭力保存, 以便讓新舊學員在自學、執行與想像的創造力發揮階段, 擁有可持續改進的工具之外, 也能有保有多元開放的完整學習資料.&lt;/p&gt;
&lt;p&gt;在這樣對於機械設計表達、內容物與創造流程的認知下, 我們會希望學員在口語表達階段除了錄音之外, 能夠利用 Reveal.js 投影片寫下文字資料, 能儘量採用開放的設計格式, 在 Fossil SCM 倉儲中保留可以持續追蹤的文字資料格式, 2D/3D 的末端二位元檔案, 並非版次管理系統所關注並保留的重點, 學員該紀錄的是, 各種末端檔案是在何種情況下, 根據哪些約束條件, 用甚麼方法產生, 隨後的使用者在檢視歷史資料的同時, 應該可以根據這些較能持續改進的文字資料, 配合不同的情況, 使用不同的工具, 建立其所需的二位元末端檔案.&lt;/p&gt;
&lt;p&gt;換言之, 一個多元開放的機械設計專案, 在導入各種軟硬體組態管理的時間點, 必須全面檢視所用的工具, 所處的環境, 盡量採用能持續改進的專案資料格式, 而非只儲存不知前因與狀況下所產生的封閉格式檔案.&lt;/p&gt;
&lt;h2&gt;文字、大綱與程式&lt;/h2&gt;
&lt;p&gt;當上述 Fossil SCM 主機的設定, 可以讓各學員個別管理 .fossil 倉儲檔案之後, 
利用瀏覽器介面可以控管 users, 可以利用  wiki 建立快寫網頁, 可以將各種影片檔案以 attach 方式附加在 wiki 頁面中, 也可以在專案進行過程利用 tickets 追蹤設計問題, 並在專案階段性任務完成時, 以 technote 紀錄成果.&lt;/p&gt;
&lt;p&gt;除了利用瀏覽器介面維護的協同內容之外, 機械設計過程中採 Pelican Blog 紀錄的網誌, 採 Reveal.js 格式的簡報網頁, 以及各種計算機程式檔案, 則必須在文字、大綱與程式架構下來進行管理.&lt;/p&gt;
&lt;p&gt;在此我們所採用的管理工具為 Leo Editor, SciTE 與 Eric6.&lt;/p&gt;
&lt;p&gt;Leo Editor 是一套採用 Python3 + PyQt5 所編寫的大綱管理套件, 其任務是負責利用大綱架構管理鬆散的 Pelican Blog, 並且利用 button 執行操作系統指令, 還肩負透過 Python3 程式碼所組成的 button, 在近端啟動 IPv4 與 IPv6 WWW 伺服模擬環境, 能讓學員在近端檢視所有之後要推送到區網與雲端中的網誌與投影片內容.&lt;/p&gt;
&lt;p&gt;SciTE 則提供文字編輯以及 Python3 與 ANSI C 程式執行環境, 而 Eric6 則用於 PyQt5 程式的開發.&lt;/p&gt;
&lt;h2&gt;純 IPv6 主機設定&lt;/h2&gt;
&lt;p&gt;目前在系主幹上的電腦已經可以選擇透過 IPv6 DHCP 或自行設定 IPv6 位址連線上網. &lt;/p&gt;
&lt;p&gt;在安裝  Ubuntu 16.04 Server 時, 選擇安裝 OpenSSH 模組, 之後則必須透過 IPv4/IPv6 雙支援的 Squid Proxy Server 才可以利用 apt 維護系統所安裝的套件.&lt;/p&gt;
&lt;p&gt;apt Proxy 的設定必須在 /etc/apt/atp.conf 中納入:&lt;/p&gt;
&lt;p&gt;Acquire::http::Proxy "http://[2001:288:6004:17::87]:3128";&lt;/p&gt;
&lt;p&gt;直接存檔後, apt 指令就可以透過 Proxy Server 連接到只支援 IPv4 網路協定的電腦.&lt;/p&gt;
&lt;p&gt;Ubuntu Server 安裝後, 若希望安裝 ubuntu-desktop:&lt;/p&gt;
&lt;p&gt;sudo apt install ubuntu-desktop&lt;/p&gt;
&lt;p&gt;接著必須在 Firefox 瀏覽中設定 Proxy Server 代理主機, 否則無法連到只支援 IPv4 網路協定的網站. 其中 Firefox 的 Proxy Server 設定, Proxy Server 的 IPv6 網址無需中括號.&lt;/p&gt;
&lt;p&gt;其次若希望採用自訂的 IPv6 網路設定, 可以修改 /etc/network/interfaces 檔案&lt;/p&gt;
&lt;p&gt;啟用 inet6 static or auto &lt;/p&gt;
&lt;pre class="brush: python"&gt;
address 2001... 
netmask 64 
gateway 2001... 
dns-nameservers 2001:b000:168::1
&lt;/pre&gt;

&lt;p&gt;最後則安裝設定中文輸入法:&lt;/p&gt;
&lt;p&gt;sudo apt install fcitx fcitx-chewing&lt;/p&gt;
&lt;p&gt;然後修改系統的 language support 將輸入法改為 fcitx 設定後, 必須登出再登入, 讓設定生效, input method 則選擇 chewing.&lt;/p&gt;
&lt;h2&gt;各階段設定檔案&lt;/h2&gt;
&lt;p&gt;Stunnel 的設定, 目的在與 Fossil SCM 結合, 提供 https 的連線代理.&lt;/p&gt;
&lt;p&gt;/etc/stunnel/stunnel.conf&lt;/p&gt;
&lt;pre class="brush: python"&gt;
[https]
accept = your_IPv4_ip:443
accept = :::443
cert = /etc/stunnel/localhost.crt
key = /etc/stunnel/localhost.key
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/ --https --nojail --notfound user/default
&lt;/pre&gt;

&lt;p&gt;因為 Fossil SCM 加上 Stunnel 設定時, 已經將連線協定設為 HTTPS, 因此 http 伺服則交由 nginx 回應:&lt;/p&gt;
&lt;p&gt;sudo apt install nginx&lt;/p&gt;
&lt;p&gt;之後再些改 /etc/ nginx/site-available/default&lt;/p&gt;
&lt;p&gt;nginx return 301 設定:&lt;/p&gt;
&lt;pre class="brush:python"&gt;
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    return 301 https://hp.kmol.info;
}
&lt;/pre&gt;</content><category term="2017fall"></category></entry><entry><title>2017 Fall 即將開學</title><link href="https://kmolab.github.io/blog/2017fall-semester-starts.html" rel="alternate"></link><published>2017-09-01T12:00:00+08:00</published><updated>2017-09-01T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-09-01:/blog/2017fall-semester-starts.html</id><summary type="html">&lt;p&gt;再過幾天, 2017 Fall 學期即將開始, 去年 copy.com 免費雲端磁碟停止提供服務, 這個月底 OpenShift 的 online 2 免費帳號也將走入歷史, 可以預期, 之後 Github 與 Bitbucket 的免費方案也將會越來越限縮, 或許就連 Onshape 與 V-rep 目前所提供的免費教育授權, 也會步上相同後塵.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;再過幾天, 2017 Fall 學期即將開始, 去年 copy.com 免費雲端磁碟停止提供服務, 這個月底 OpenShift 的 online 2 免費帳號也將走入歷史, 可以預期, 之後 Github 與 Bitbucket 的免費方案也將會越來越限縮, 或許就連 Onshape 與 V-rep 目前所提供的免費教育授權, 也會步上相同後塵.&lt;/p&gt;


&lt;h2&gt;課程工具檢討&lt;/h2&gt;
&lt;p&gt;以機械設計工程師的培訓角度而言, 除了第三方的雲端系統外, 還有自建的廣域網路上的伺服器, 區域網路上的伺服器, 以及單機隨身系統上的伺服器. 其中自建的三種伺服器都能從 &lt;a href="http://service.mde.tw/public/python2017fall_36.7z"&gt;http://service.mde.tw/public/python2017fall_36.7z&lt;/a&gt; 隨身系統中所提供的工具進行配置與模擬.&lt;/p&gt;
&lt;p&gt;可攜隨身系統中最重要的工具為 Python3 程式環境, 搭配 SCiTE, TinyC, Leo Editor, Pelican, Reveal.js, Eric6 IDE, 以及 Flask 與 Brython, 使用者可以編寫 PyQt5 套件, 可以練習以 ANSI C 建立簡單的動態連結程式庫, 配合 Python3 主程式使用. 也能建立整合網際前後端的 Python3 程式, 同時納入網誌與網際投影片系統.&lt;/p&gt;
&lt;p&gt;這些工具在從事各種機械設計產品開發時, 所產生的資料版本, 自 2017 Spring 起, 已經同時採用 Github 與 Fossil SCM 進行管理, 2017 Fall 將會更側重 Fossil SCM 的運用, 除了讓同一倉儲, 在兩套遠端不同分散式資料版次管理系統保持同步外, 近端也會擁有一套備份, 可以簡單地利用 fossil ui 進行檢視, 或者結合 Stunnel, 讓近端的倉儲管理與遠端模式相同.&lt;/p&gt;
&lt;p&gt;至於用來執行 Fossil SCM 伺服器的主機, 目前使用的是接近淘汰的機種, 這學期將要測試一台電腦能夠承受幾名學員同步提交推送資料,  最終, 學員必須要學會如何將 Pelican Blog, Reveal.js 投影片版本資料, 同時放到 Github 與區域網路上的 Fossil SCM 伺服器.&lt;/p&gt;
&lt;p&gt;CAD 的工具目前採用單機上輕量的 Solvespace 與雲端上的 OnShape, Solvespace 是一套採 C++11 編寫的 GPL 授權參數式電腦輔助設計套件, 永續使用較無問題, OnShape 在協同產品上的設計功能, 有其獨特性, 因此將繼續採用.&lt;/p&gt;
&lt;p&gt;V-rep 也提供 GPL 使用授權, 2017 Fall 起將要自行編譯使用.&lt;/p&gt;
&lt;h2&gt;2017 Fall 區網主機&lt;/h2&gt;
&lt;p&gt;主要伺服器可以從 &lt;a href="http://mde.tw"&gt;http://mde.tw&lt;/a&gt; 進入.&lt;/p&gt;
&lt;p&gt;2017 Fall 區網課程網頁: &lt;a href="https://mde1a1.kmol.info/2017fall"&gt;https://mde1a1.kmol.info/2017fall&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github 與 Fossil SCM 同步倉儲: &lt;a href="https://mde1a1.kmol.info/pymcadp"&gt;https://mde1a1.kmol.info/pymcadp&lt;/a&gt;&lt;/p&gt;</content><category term="2017fall"></category></entry><entry><title>Sunset of OpenShift Online 2 Platform</title><link href="https://kmolab.github.io/blog/sunset-of-openshift-online2.html" rel="alternate"></link><published>2017-08-26T12:00:00+08:00</published><updated>2017-08-26T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-08-26:/blog/sunset-of-openshift-online2.html</id><summary type="html">&lt;p&gt;OpenShift 在 2017.08.25 於 &lt;a href="https://blog.openshift.com/migrate-to-v3-v2-eol/"&gt;https://blog.openshift.com/migrate-to-v3-v2-eol/&lt;/a&gt; 宣布, 先前所推出的 Online 2 Platform, 將要在 2017.09.30 走入歷史.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;OpenShift 在 2017.08.25 於 &lt;a href="https://blog.openshift.com/migrate-to-v3-v2-eol/"&gt;https://blog.openshift.com/migrate-to-v3-v2-eol/&lt;/a&gt; 宣布, 先前所推出的 Online 2 Platform, 將要在 2017.09.30 走入歷史.&lt;/p&gt;


&lt;p&gt;為了因應這個變化, 許多過去所建立的網站資料將要轉到 Github 與 Fossil SCM.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wordpress-2015course.rhcloud.com/"&gt;https://wordpress-2015course.rhcloud.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;有用的連結&lt;/h2&gt;
&lt;p&gt;Free Math Books&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.openculture.com/free-math-textbooks"&gt;http://www.openculture.com/free-math-textbooks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kinematic Synthesis of Linkage&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ebooks.library.cornell.edu/k/kmoddl/toc_hartenberg1.html"&gt;http://ebooks.library.cornell.edu/k/kmoddl/toc_hartenberg1.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;the kinematic models for design&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ebooks.library.cornell.edu/k/kmoddl/about.html"&gt;http://ebooks.library.cornell.edu/k/kmoddl/about.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CSS 與 Div 取代 Table&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sofree.cc/css-table/"&gt;https://sofree.cc/css-table/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.flycan.com/article/css/css-float-442.html"&gt;http://www.flycan.com/article/css/css-float-442.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以 http://2016spring-cadlab.rhcloud.com 取出舊版程式? cadlab At mde&lt;/p&gt;
&lt;p&gt;備份: https://wordpress-2015course.rhcloud.com/?p=4579&lt;/p&gt;
&lt;p&gt;Product Design Modeling using CAD/CAE &lt;/p&gt;
&lt;p&gt;How to be a star engineer&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ieeexplore.ieee.org/document/795608/"&gt;http://ieeexplore.ieee.org/document/795608/&lt;/a&gt;&lt;/p&gt;</content><category term="OpenShift"></category></entry><entry><title>Calculator in PyQt5 and Eric6</title><link href="https://kmolab.github.io/blog/calculator-pyqt5-eric6.html" rel="alternate"></link><published>2017-07-31T12:00:00+08:00</published><updated>2017-07-31T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-07-31:/blog/calculator-pyqt5-eric6.html</id><summary type="html">&lt;p&gt;根據 &lt;a href="http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html"&gt;http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html&lt;/a&gt; 的說明, 利用 Eric6 與 PyQt5 開發簡單的計算器視窗程式.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;根據 &lt;a href="http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html"&gt;http://doc.qt.io/qt-5/qtwidgets-widgets-calculator-example.html&lt;/a&gt; 的說明, 利用 Eric6 與 PyQt5 開發簡單的計算器視窗程式.&lt;/p&gt;


&lt;p&gt;Flask 與 Javascript 建立簡單計算器: &lt;a href='https://github.com/helloflask/calculator"&gt;https://github.com/helloflask/calculator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前在 KMOL 的計算機程式, 主要寫成三種格式, 1) 採用 PyQt5 寫單機視窗應用程式, 2) 以 Flask 及 Javascript 寫成瀏覽器程式, 3) 最後則是寫成 Android 平台上的 Apps.&lt;/p&gt;
&lt;p&gt;PyQt5 單機應用程式與 Android Apps 的用途主要在即時與周遭的軟硬體互動, 執行虛實模擬或操作控制, 或者用來管理其他與近端軟硬體有關的主程式, 而 Flask Server Based 程式則以網際模式提供, 主要用於多人同步或非同步協同之用.&lt;/p&gt;
&lt;h2&gt;計算器原始碼&lt;/h2&gt;
&lt;p&gt;與 Qt5 加上 C++ 實現的簡單視窗計算器程式對應的 PyQt5 程式,  &lt;a href="https://github.com/baoboa/pyqt5/blob/master/examples/widgets/calculator.py"&gt;https://github.com/baoboa/pyqt5/blob/master/examples/widgets/calculator.py&lt;/a&gt;. 若使用本學期所使用的 Python 3.6 可攜程是環境 &lt;a href="http://service.mde.tw/public/python2017fall_36.7z"&gt;http://service.mde.tw/public/python2017fall_36.7z&lt;/a&gt;, 直接利用 SciTE 開啟 calculator.py 後按下 Tools - Go 就可以執行.&lt;/p&gt;
&lt;h2&gt;waitingForOperand 變數&lt;/h2&gt;
&lt;p&gt;self.waitingForOperand 成員變數, 用來記錄計算器的輸入流程中, 是否處於等待使用者輸入處理數值. 一開始 self.waitingForOperand 為 True. 當首次按下數字鍵則系統清除顯示區, 然後 self.waitingForOperand 轉為 False. 表示已經進入處理數值的輸入程序中, 這時若使用者再按其他數字按鈕, 則 if self.waitingForOperand 區段將不會執行, 也就不會刷新顯示區, 而是執行其下方的顯示區數字附加的程式段.&lt;/p&gt;
&lt;p&gt;self.display.setText(self.display.text() + str(digitValue))&lt;/p&gt;
&lt;p&gt;至於 self.waitingForOperand 再次轉為 True 的時機, 分別在 unaryOperatorClicked、additiveOperatorClicked、multiplicativeOperatorClicked、pointclicked 或 equalClicked 等成員函式執行後, 輸入流程又轉回等待使用者輸入運算數值的階段.&lt;/p&gt;
&lt;p&gt;其他 self.waitingForOperand 出現在 backspaceClicked、clear 與 clearAll 函式時, 也必須確定 self.waitingForOperand 會再次轉為 True.&lt;/p&gt;
&lt;h2&gt;pendingAdditiveOperator 變數&lt;/h2&gt;
&lt;p&gt;若 pendingAdditiveOperator 為 True, 優先運算階段完成後顯示區換成 self.factorSoFar. 若 pendingAdditiveOperator 為 False, 則將目前顯示區中的數值對應成 self.factorSoFar.&lt;/p&gt;
&lt;p&gt;The private calculate() function performs a binary operation. The right operand is given by rightOperand. For additive operators, the left operand is sumSoFar; for multiplicative operators, the left operand is factorSoFar. The function return false if a division by zero occurs.&lt;/p&gt;
&lt;h2&gt;sumSofFar 與 factorSoFar 變數&lt;/h2&gt;
&lt;p&gt;執行 calculate  函式時, 若運算子為加或減, 則左運算數為 sumSoFar, 若運算子為乘或除, 則左運算數為 factorSoFar. 右運算數則取自 rightOperand 變數.&lt;/p&gt;
&lt;p&gt;The example consists of two classes:&lt;/p&gt;
&lt;p&gt;Calculator is the calculator widget, with all the calculator functionality.&lt;/p&gt;
&lt;p&gt;Button is the widget used for each of the calculator button. It derives from QToolButton.&lt;/p&gt;
&lt;p&gt;The Calculator class provides a simple calculator widget. It inherits from QDialog and has several private slots associated with the calculator's buttons. QObject::eventFilter() is reimplemented to handle mouse events on the calculator's display.&lt;/p&gt;
&lt;p&gt;Buttons are grouped in categories according to their behavior. For example, all the digit buttons (labeled 0 to 9) append a digit to the current operand. For these, we connect multiple buttons to the same slot (e.g., digitClicked()). The categories are digits, unary operators (Sqrt, x², 1/x), additive operators (+, -), and multiplicative operators (×, ÷). The other buttons have their own slots.&lt;/p&gt;
&lt;p&gt;The private createButton() function is used as part of the widget construction. abortOperation() is called whenever a division by zero occurs or when a square root operation is applied to a negative number. calculate() applies a binary operator (+, -, ×, or ÷).&lt;/p&gt;
&lt;p&gt;These variables, together with the contents of the calculator display (a QLineEdit), encode the state of the calculator:&lt;/p&gt;
&lt;p&gt;sumInMemory contains the value stored in the calculator's memory (using MS, M+, or MC).&lt;/p&gt;
&lt;p&gt;sumSoFar stores the value accumulated so far. When the user clicks =, sumSoFar is recomputed and shown on the display. Clear All resets sumSoFar to zero.&lt;/p&gt;
&lt;p&gt;factorSoFar stores a temporary value when doing multiplications and divisions.&lt;/p&gt;
&lt;p&gt;pendingAdditiveOperator stores the last additive operator clicked by the user.&lt;/p&gt;
&lt;p&gt;pendingMultiplicativeOperator stores the last multiplicative operator clicked by the user.&lt;/p&gt;
&lt;p&gt;waitingForOperand is true when the calculator is expecting the user to start typing an operand.&lt;/p&gt;
&lt;p&gt;Additive and multiplicative operators are treated differently because they have different precedences. For example, 1 + 2 ÷ 3 is interpreted as 1 + (2 ÷ 3) because ÷ has higher precedence than +.&lt;/p&gt;
&lt;p&gt;The table below shows the evolution of the calculator state as the user enters a mathematical expression.&lt;/p&gt;
&lt;p&gt;Waiting for Operand? 等待運算處理對象?&lt;/p&gt;
&lt;p&gt;Add. Op. - 加或減運算元,若隨後無乘與除等優先運算元, 且按下等於或接著按加或減運算元, 則前段隨即完成運算後列在 Sum so Far 欄位.&lt;/p&gt;
&lt;p&gt;Mul. Op. - 乘或除運算元, 屬於優先運算元, 因此若輸入已經滿足運算數接優先運算元, 再接其他運算元則 將局部優先運算所需的前方運算數, 放入 Factor so Far, 而前面未處理的加或減運算數, 則放入 Sum so Far.&lt;/p&gt;
&lt;!-- 這裡在測試 template 中 base.html head 標註中所加入的 style 標註用法 --&gt;

&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;User Input&lt;/th&gt; &lt;th&gt;Display&lt;/th&gt;    &lt;th&gt;Sum so Far&lt;/th&gt; &lt;th&gt;Add. Op.&lt;/ht&gt;   &lt;th&gt;Factor so Far&lt;/th&gt;  &lt;th&gt;Mult. Op.&lt;/th&gt;  &lt;th&gt;Waiting for Operand?&lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt; &lt;td&gt;0&lt;/td&gt;    &lt;td&gt;0&lt;/td&gt;  &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;           &lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;0&lt;/td&gt;  &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;           &lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 +&lt;/td&gt;    &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;+&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;          &lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2&lt;/td&gt;  &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;+&lt;/td&gt;  &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;     &lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2 ÷&lt;/td&gt;    &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;+&lt;/td&gt;  &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;÷&lt;/td&gt; &lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2 ÷ 3&lt;/td&gt;  &lt;td&gt;3&lt;/td&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td&gt;+&lt;/td&gt;  &lt;td&gt;2&lt;/td&gt;  &lt;td&gt;÷&lt;/td&gt;  &lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2 ÷ 3 -&lt;/td&gt;    &lt;td&gt;1.66667&lt;/td&gt;    &lt;td&gt;1.66667&lt;/td&gt;    &lt;td&gt;-&lt;/td&gt;  &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt;     &lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2 ÷ 3 - 4&lt;/td&gt;  &lt;td&gt;4&lt;/td&gt;  &lt;td&gt;1.66667&lt;/td&gt;    &lt;td&gt;-&lt;/td&gt;      &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1 + 2 ÷ 3 - 4 =&lt;/td&gt;    &lt;td&gt;-2.33333&lt;/td&gt;   &lt;td&gt;0&lt;/td&gt;      &lt;td&gt;&lt;/td&gt;   &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
Unary operators, such as Sqrt, require no special handling; they can be applied immediately since the operand is already known when the operator button is clicked.&lt;/p&gt;
&lt;p&gt;Finally, we declare the variables associated with the display and the buttons used to display numerals.&lt;/p&gt;
&lt;p&gt;In the constructor, we initialize the calculator's state. The pendingAdditiveOperator and pendingMultiplicativeOperator variables don't need to be initialized explicitly, because the QString constructor initializes them to empty strings.&lt;/p&gt;
&lt;p&gt;We create the QLineEdit representing the calculator's display and set up some of its properties. In particular, we set it to be read-only.&lt;/p&gt;
&lt;p&gt;We also enlarge display's font by 8 points.&lt;/p&gt;
&lt;p&gt;For each button, we call the private createButton() function with the proper text label and a slot to connect to the button.&lt;/p&gt;
&lt;p&gt;The layout is handled by a single QGridLayout. The QLayout::setSizeConstraint() call ensures that the Calculator widget is always shown as its optimal size (its size hint), preventing the user from resizing the calculator. The size hint is determined by the size and size policy of the child widgets.&lt;/p&gt;
&lt;p&gt;Most child widgets occupy only one cell in the grid layout. For these, we only need to pass a row and a column to QGridLayout::addWidget(). The display, backspaceButton, clearButton, and clearAllButton widgets occupy more than one column; for these we must also pass a row span and a column span.&lt;/p&gt;
&lt;p&gt;Pressing one of the calculator's digit buttons will emit the button's clicked() signal, which will trigger the digitClicked() slot.&lt;/p&gt;
&lt;p&gt;First, we find out which button sent the signal using QObject::sender(). This function returns the sender as a QObject pointer. Since we know that the sender is a Button object, we can safely cast the QObject. We could have used a C-style cast or a C++ static_cast&amp;lt;&amp;gt;(), but as a defensive programming technique we use a qobject_cast(). The advantage is that if the object has the wrong type, a null pointer is returned. Crashes due to null pointers are much easier to diagnose than crashes due to unsafe casts. Once we have the button, we extract the operator using QToolButton::text().&lt;/p&gt;
&lt;p&gt;The slot needs to consider two situations in particular. If display contains "0" and the user clicks the 0 button, it would be silly to show "00". And if the calculator is in a state where it is waiting for a new operand, the new digit is the first digit of that new operand; in that case, any result of a previous calculation must be cleared first.&lt;/p&gt;
&lt;p&gt;At the end, we append the new digit to the value in the display.&lt;/p&gt;
&lt;p&gt;The unaryOperatorClicked() slot is called whenever one of the unary operator buttons is clicked. Again a pointer to the clicked button is retrieved using QObject::sender(). The operator is extracted from the button's text and stored in clickedOperator. The operand is obtained from display.&lt;/p&gt;
&lt;p&gt;Then we perform the operation. If Sqrt is applied to a negative number or 1/x to zero, we call abortOperation(). If everything goes well, we display the result of the operation in the line edit and we set waitingForOperand to true. This ensures that if the user types a new digit, the digit will be considered as a new operand, instead of being appended to the current value.&lt;/p&gt;
&lt;p&gt;The additiveOperatorClicked() slot is called when the user clicks the + or - button.&lt;/p&gt;
&lt;p&gt;Before we can actually do something about the clicked operator, we must handle any pending operations. We start with the multiplicative operators, since these have higher precedence than additive operators:&lt;/p&gt;
&lt;p&gt;If × or ÷ has been clicked earlier, without clicking = afterward, the current value in the display is the right operand of the × or ÷ operator and we can finally perform the operation and update the display.&lt;/p&gt;
&lt;p&gt;If + or - has been clicked earlier, sumSoFar is the left operand and the current value in the display is the right operand of the operator. If there is no pending additive operator, sumSoFar is simply set to be the text in the display.&lt;/p&gt;
&lt;p&gt;Finally, we can take care of the operator that was just clicked. Since we don't have the right-hand operand yet, we store the clicked operator in the pendingAdditiveOperator variable. We will apply the operation later, when we have a right operand, with sumSoFar as the left operand.&lt;/p&gt;
&lt;p&gt;The multiplicativeOperatorClicked() slot is similar to additiveOperatorClicked(). We don't need to worry about pending additive operators here, because multiplicative operators have precedence over additive operators.&lt;/p&gt;
&lt;p&gt;Like in additiveOperatorClicked(), we start by handling any pending multiplicative and additive operators. Then we display sumSoFar and reset the variable to zero. Resetting the variable to zero is necessary to avoid counting the value twice.&lt;/p&gt;
&lt;p&gt;The pointClicked() slot adds a decimal point to the content in display.&lt;/p&gt;
&lt;p&gt;The changeSignClicked() slot changes the sign of the value in display. If the current value is positive, we prepend a minus sign; if the current value is negative, we remove the first character from the value (the minus sign).&lt;/p&gt;
&lt;p&gt;The backspaceClicked() removes the rightmost character in the display. If we get an empty string, we show "0" and set waitingForOperand to true.&lt;/p&gt;
&lt;p&gt;The clear() slot resets the current operand to zero. It is equivalent to clicking Backspace enough times to erase the entire operand.&lt;/p&gt;
&lt;p&gt;The clearAll() slot resets the calculator to its initial state.&lt;/p&gt;
&lt;p&gt;The clearMemory() slot erases the sum kept in memory, readMemory() displays the sum as an operand, setMemory() replace the sum in memory with the current sum, and addToMemory() adds the current value to the value in memory. For setMemory() and addToMemory(), we start by calling equalClicked() to update sumSoFar and the value in the display.&lt;/p&gt;
&lt;p&gt;The private createButton() function is called from the constructor to create calculator buttons.&lt;/p&gt;
&lt;p&gt;The private abortOperation() function is called whenever a calculation fails. It resets the calculator state and displays "####".&lt;/p&gt;
&lt;p&gt;The private calculate() function performs a binary operation. The right operand is given by rightOperand. For additive operators, the left operand is sumSoFar; for multiplicative operators, the left operand is factorSoFar. The function return false if a division by zero occurs.&lt;/p&gt;</content><category term="計算機程式"></category><category term="PyQt5"></category></entry><entry><title>Create a Multi-repository Fossil SCM Server</title><link href="https://kmolab.github.io/blog/create-a-multi-repository-fossil-scm-server.html" rel="alternate"></link><published>2017-07-14T12:00:00+08:00</published><updated>2017-07-14T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-07-14:/blog/create-a-multi-repository-fossil-scm-server.html</id><summary type="html">&lt;p&gt;In order to create a multi-repository Fossil SCM server on Ubuntu 16.04 environment, three steps are needed.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;In order to create a multi-repository Fossil SCM server on Ubuntu 16.04 environment, three steps are needed.&lt;/p&gt;


&lt;h2&gt;Step 1: install Stunnel and Fossil SCM&lt;/h2&gt;
&lt;p&gt;sudo apt update&lt;/p&gt;
&lt;p&gt;sudo apt install stunnel4 -y&lt;/p&gt;
&lt;p&gt;sudo apt install fossil&lt;/p&gt;
&lt;p&gt;Edit /etc/environment file and add the following setup to allow only the https connections:&lt;/p&gt;
&lt;p&gt;HTTPS=on&lt;/p&gt;
&lt;p&gt;Edit /etc/default/stunnel4 file and modified the ENABLED value from 0 to 1 to get stunnel service running when the computer startup:&lt;/p&gt;
&lt;p&gt;ENABLED=1&lt;/p&gt;
&lt;h2&gt;Step 2: Stunnel setup&lt;/h2&gt;
&lt;p&gt;Change directory to /etc/stunnel/ and use the following command to generate localhost.key and localhost.crt files.&lt;/p&gt;
&lt;p&gt;sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt&lt;/p&gt;
&lt;p&gt;edit stunnel.conf configuration file under /etc/stunnel/ as follows:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
[https]
accept = your_IPv4_ip:443
accept = :::443
cert = /etc/stunnel/localhost.crt
key = /etc/stunnel/localhost.key
exec = /usr/bin/fossil
execargs = /usr/bin/fossil http /home/user/repository/ --https --nojail --notfound default
&lt;/pre&gt;

&lt;p&gt;which means the IPv4 and IPv6 requests are both accepted under port 443. And /home/user/repository/ is used to store the Fossil SCM repo files. The default repo file is /home/user/repository/default.fossil&lt;/p&gt;
&lt;p&gt;The setting of "--notfound default" means if the repository file is not specified, connection URL is default which is a relative directory associated with the server main URL.&lt;/p&gt;
&lt;h2&gt;Step 3: create Fossil SCM repositories&lt;/h2&gt;
&lt;p&gt;Change directory to /home/user/repository and use "fossil init default.fossil" command to create the default repository. If more repository is needed, also use "fossil init other.fossil" to create other.fossil repository under /home/user/repository.&lt;/p&gt;
&lt;p&gt;After the setup use "/etc/init.d/stunnel4 restart" command to restart the Stunnel service.&lt;/p&gt;
&lt;p&gt;Use https://site-url:443/ to connect to default.fossil and use https://site-url:443/other to connect to other.fossil.&lt;/p&gt;</content><category term="Fossil SCM"></category><category term="Ubuntu"></category></entry><entry><title>2015 Fall CADP W16</title><link href="https://kmolab.github.io/blog/2015-cadp-w16.html" rel="alternate"></link><published>2017-07-10T12:00:00+08:00</published><updated>2017-07-10T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-07-10:/blog/2015-cadp-w16.html</id><summary type="html">&lt;p&gt;根據 &lt;a href="./../data/nutcracker/ProEMechanism.pdf"&gt;Nutcracker 機構&lt;/a&gt;的尺寸規格, 請設法算出 Piston 零件的有效運動範圍.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;根據 &lt;a href="./../data/nutcracker/ProEMechanism.pdf"&gt;Nutcracker 機構&lt;/a&gt;的尺寸規格, 請設法算出 Piston 零件的有效運動範圍.&lt;/p&gt;


&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_left_limit.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_right_limit.png" width="600" /&gt;&lt;/p&gt;
&lt;p&gt;計算 Piston 不發生干涉的有效行程, 可採如下方法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;實際利用 Onshape 中的組立, 移動 piston 零件, 靠目測概略決定 piston 的有效行程. (目測法, 只能得到大概的行程範圍)&lt;/li&gt;
&lt;li&gt;利用 Solvespace 繪製 2D 約束圖, 然後利用約束點在線或圓上的方式, 以圖解法解出有效行程, 如下圖一, 圖二與圖三所示. (圖解法, 利用 Solvespace 既有的約束條件設定完成計算)&lt;/li&gt;
&lt;li&gt;利用 Jupyter 與 Python3 的 sympy 模組, 先進行符號式推導, 然後再利用數值分析解出 piston 的有效行程, 機構各點標示如下圖四所示, &lt;a href="./../data/nutcracker/cadp_nutcracker.ipynb"&gt;計算出&lt;/a&gt;的 theta 轉角為 105.7, 如下圖五所示. (以自行編寫的 sympy 程式解題, 透過 Jupyterhub 可以有效進行協同設計運算)&lt;/li&gt;
&lt;li&gt;除了上述的目測, 圖解與符號式結合數值分析法之外, 也可以採用&lt;a href="./../data/nutcracker/ga_nutcracker1.py"&gt;基因演算法解題&lt;/a&gt;, 計算出的 theta 轉角為 105.7, 如下圖六所示. (利用演化法解題, 可以在單機運算, 也可以在 &lt;a href="./../data/nutcracker//cadp_nutcracker.ipynb"&gt;Jupyterhub 平台&lt;/a&gt;上進行運算)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_solvespace1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖一: 利用 Solvespace 中的繪圖約束條件找出右邊的極限點距離 Onshape Piston 組立原點 0.5&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_solvespace2.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖二: 利用 Solvespace 中的繪圖約束條件找出左邊的極限點距離 Onshape Piston 組立原點 2.23&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_solvespace3.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖三: 當 piston 位於左邊極限點時, AB 轉角為 105.37 度&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_analysis1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖四: Jupyter 計算分析時機構各點標示圖&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_jupyter_result1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖五: 利用 Jupyter 符號式結合數值分析法所得結果&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/nutcracker/nutcracker_ga_result1.png" width=600 /&gt;&lt;/p&gt;
&lt;p&gt;圖六: 利用基因演算解題, 所得到的結果, 當 piston 位於左邊極限點時, AB 轉角為 105.7 度&lt;/p&gt;
&lt;p&gt;若採用 &lt;a href="https://github.com/deap/deap"&gt;deap&lt;/a&gt; 與 numpy 解題 (AB 轉角極限為 105.71 度):&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# 這裡採用 numpy 與 deap 模組解題, 使用 Genetic Algorithm 模式
# 解的問題為 Nutcracker 左邊 connect 轉角極限
import random
import array
from deap import base
from deap import creator
from deap import tools
import numpy
# for evalIntersect 函式中的 sqrt, sin, cos, pi
from math import *

# 1/4 最小化題目 type of problem
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", array.array, typecode='d', \
               fitness=creator.FitnessMin)
# 2/4 initilization
# 兩個變數題目
NDIM = 2
toolbox = base.Toolbox()
toolbox.register("attr_float", random.uniform, 0, 5)
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_float, NDIM)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# 3/4 選擇 operator step3/4
toolbox.register("select", tools.selRandom, k=3)

# 也可以採用下列設定
#toolbox.register("mate", tools.cxTwoPoint)
#toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.1)
#toolbox.register("select", tools.selTournament, tournsize=3, k=3)

def evalIntersect(individual):
    t = individual[0]
    deg = pi/180
    theta = individual[1]*deg
    xtarget = 0.75/2
    ytarget = 0.5
    x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 \
        + 529)/92 + 3*cos(theta)/2
    y = (-3*t/2 + 123/92)*sin(theta)
    # 適應值
    fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8)

    # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰
    if t &gt; 1:
        fitness_value += 1000
    if t &lt; 0:
        fitness_value += 1000
    # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰
    if theta &gt; 2*pi:
        fitness_value += 1000
    if theta &lt; 0:
        fitness_value += 1000
    return fitness_value,

toolbox.register("evaluate", evalIntersect)
# 以上到 evaluate 為止, 為定義 operators

# 4/4 以下則為 Algorithms
def main():
    # Differential evolution parameters
    CR = 0.25
    F = 1 
    MU = 300
    NGEN = 200   

    pop = toolbox.population(n=MU);
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", numpy.mean)
    stats.register("std", numpy.std)
    stats.register("min", numpy.min)
    stats.register("max", numpy.max)

    # Evaluate the individuals
    fitnesses = toolbox.map(toolbox.evaluate, pop)
    for ind, fit in zip(pop, fitnesses):
        ind.fitness.values = fit

    for g in range(1, NGEN):
        for k, agent in enumerate(pop):
            a,b,c = toolbox.select(pop)
            y = toolbox.clone(agent)
            index = random.randrange(NDIM)
            for i, value in enumerate(agent):
                if i == index or random.random() &lt; CR:
                    y[i] = a[i] + F*(b[i]-c[i])
            y.fitness.values = toolbox.evaluate(y)
            if y.fitness &gt; agent.fitness:
                pop[k] = y
        hof.update(pop)


    print("Best individual is ", hof[0], hof[0].fitness.values[0])

if __name__ == "__main__":
    main()
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;
上述課程資料與 &lt;a href="http://wordpress-2015course.rhcloud.com/?p=4584#more-4584"&gt;Wordpress 網頁&lt;/a&gt;上的資料內容相同, Ｗordpress 網站屬於動態的網誌, 而 &lt;a href="http://chiamingyen.github.io/kmolab/"&gt;http://chiamingyen.github.io/kmolab/&lt;/a&gt; 則是靜態網誌系統, 採用靜態網誌的優點如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比較安全&lt;/li&gt;
&lt;li&gt;比較不會過時&lt;/li&gt;
&lt;li&gt;部署成本比較低&lt;/li&gt;
&lt;li&gt;可在各種平台上使用&lt;/li&gt;
&lt;li&gt;各階段改版資料均有紀錄&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下為參考用的 GA 解 Nutcracker 題目的程式碼:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#encoding=utf8
# genetic.py
#
import random
import operator
# for Intersect
from math import *
MAXIMIZE, MINIMIZE = 11, 22
class Individual:
    chromosome = None
    score = None
    # Here the size of var depends on var_number
    var = []
    var_number = 2
    for i in range(var_number):
        var.append(0)
    alleles = (0,1)
    # 以下為參數可負數時的編碼考量
    #前10為小數,後10為整數,第21則為正負號
    #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號.
    #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號
    #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號
    # -1023 ~ 1023
    #length = 21*var_number,若接受負數參數,則必須同步修改 20-&gt;21
    length = 20*var_number
    seperator = ''
    optimization = MINIMIZE
    def __init__(self, chromosome=None):
        self.chromosome = chromosome or self._makechromosome()
        self.score = None  # set during evaluation
    def _getvar(self,chromosome=None):
        x = 0
        for i in range(0,self.var_number):
            for j in range(i*20,i*20+10):
                x +=self.chromosome[j]&lt;&lt;(j-(i*20))
            if (x&gt;999):
                x=999
            x/=1000.
            for j in range(i*20+10,i*20+20):
                x +=self.chromosome[j]&lt;&lt;(j-(i*20+10))
            self.var[i] = x
        return self.var
        ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings
#for design variable -1023 ~1023
        for i in range(self.var_number):
            x = 0
            for j in range(i*21,i*21+10):
                x +=self.chromosome[j]&lt;&lt;(j-(i*21))
            if (x&gt;999):
                x=999
            x/=1000.
            for j in range(i*(21)+10,i*(21)+20):
                x +=self.chromosome[j]&lt;&lt;(j-(i*21+10))
            if(self.chromosome[i*(21)+20] == 1):
                self.var[i] = -x
            else:
                self.var[i] = x
            x = 0
        return self.var
        '''
    def _makechromosome(self):
        "makes a chromosome from randomly selected alleles."
        return [random.choice(self.alleles) for gene in range(self.length)]
    def evaluate(self, optimum=None):
        "this method MUST be overridden to evaluate individual fitness score."
        pass
    def crossover(self, other):
        "override this method to use your preferred crossover method."
        return self._twopoint(other)
    def mutate(self, gene):
        "override this method to use your preferred mutation method."
        self._pick(gene)
    # sample mutation method
    def _pick(self, gene):
        "chooses a random allele to replace this gene's allele."
        self.chromosome[gene] = random.choice(self.alleles)
    # sample crossover method
    def _twopoint(self, other):
        "creates offspring via two-point crossover between mates."
        left, right = self._pickpivots()
        def mate(p0, p1):
            chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容
            chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因
            #child = p1.__class__(chromosome) 這是原先的程式,但是應該子代要指向 p0 的內容才對
            child = p0.__class__(chromosome)
            child._repair(p0, p1)
            return child
        return mate(self, other), mate(other, self)
    # some crossover helpers ...
    def _repair(self, parent1, parent2):
        "override this method, if necessary, to fix duplicated genes."
        pass
    def _pickpivots(self):
        left = random.randrange(1, self.length-2)
        right = random.randrange(left, self.length-1)
        return left, right
    #
    # other methods
    #
    def __repr__(self):
        "returns string representation of self"
        '''
        return '&lt;%s chromosome="%s" score=%s var=%s&gt;' % \
               (self.__class__.__name__,
                self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome))
        '''
        return '&lt;%s score=%s var=%s&gt;' % \
               (self.__class__.__name__,self.score,self._getvar(self.chromosome))
    # since the __cmp__ special function is gone  use the __lt__ in stead
    # use the expression (a &gt; b) - (a &lt; b) as the equivalent for cmp(a, b)
    #def __cmp__(self, other):
    # these are for python 3
    def __cmp__(self, other):
        if self.optimization == MINIMIZE:
            #return cmp(self.score, other.score)
            return (self.score &gt; other.score) - (self.score &lt; other.score)
        else: # MAXIMIZE
            #return cmp(other.score, self.score)
            return (other.score &gt; self.score) - (other.score &lt; self.score)

    def __lt__(self, other):
        return self.__cmp__(other) &lt; 0
    def __le__(self, other):
        return self.__cmp__(other) &lt;= 0
    def __gt__(self, other):
        return self.__cmp__(other) &gt; 0
    def __ge__(self, other):
        return self.__cmp__(other) &gt;= 0 
    def copy(self):
        twin = self.__class__(self.chromosome[:])
        twin.score = self.score
        return twin
class Environment(object):
    x = [0]
    y = [0]
    def __init__(self, kind, population=None, size=100, maxgenerations=100,
                 crossover_rate=0.90, mutation_rate=0.07, optimum=None):
        self.kind = kind
        self.size = size
        self.optimum = optimum
        self.population = population or self._makepopulation()
        for individual in self.population:
            individual.evaluate(self.optimum)
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.maxgenerations = maxgenerations
        self.generation = 0
        self.report()
    def _makepopulation(self):
        return [self.kind() for individual in range(self.size)]
    def run(self):
        while not self._goal():
            self.step()
    def _goal(self):
        return self.generation &gt; self.maxgenerations or \
               self.best.score == self.optimum
    def step(self):
        # this sort is not working with python 3.0, modification is needed
        self.population.sort()
        self._crossover()
        self.generation += 1
        self.report()
        self.x.append(self.generation)
        # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值
        if self.best.score &lt;=5:
            self.y.append(self.best.score)
        else:
            self.y.append(5)
    def _crossover(self):
        next_population = [self.best.copy()]
        while len(next_population) &lt; self.size:
            mate1 = self._select()
            if random.random() &lt; self.crossover_rate:
                mate2 = self._select()
                offspring = mate1.crossover(mate2)
            else:
                offspring = [mate1.copy()]
            for individual in offspring:
                self._mutate(individual)
                individual.evaluate(self.optimum)
                next_population.append(individual)
        self.population = next_population[:self.size]
    def _select(self):
        "override this to use your preferred selection method"
        return self._tournament()
    def _mutate(self, individual):
        for gene in range(individual.length):
            if random.random() &lt; self.mutation_rate:
                individual.mutate(gene)
    #
    # sample selection method
    #
    def _tournament(self, size=8, choosebest=0.90):
        competitors = [random.choice(self.population) for i in range(size)]
        competitors.sort()
        if random.random() &lt; choosebest:
            return competitors[0]
        else:
            return random.choice(competitors[1:])
    def best():
        doc = "individual with best fitness score in population."
        def fget(self):
            return self.population[0]
        return locals()
    best = property(**best())
    def report(self):
        print ("="*70)
        print ("generation: ", self.generation)
        print ("best:       ", self.best)

# 以上為 genetic.py 目前將兩者結合在一起
#encoding=utf8
# volume.py - useage example
#
# the fittest individual will have a chromosome consisting of 40 '1's
#
#
#import genetic
#此一加總函式在 volume 最大化中,並未使用
def sum(seq):
    def add(x,y): return x+y
    return reduce(add, seq, 0)
class Volume(Individual):
    optimization = MAXIMIZE
    def evaluate(self, optimum=None):
        SURFACE = 80
        # self.score is the fitness value
        self._getvar(self.chromosome)

        x = self.var[0]
        y = self.var[1]
        z=(SURFACE - x*y)/(2.*(x+y))
        fitness_value = x*y*z

        self.score = fitness_value

    def mutate(self, gene):
        self.chromosome[gene] = not self.chromosome[gene] # bit flip

class Intersect(Individual):
    optimization = MINIMIZE
    def evaluate(self, optimum=None):
        # self.score is the fitness value
        self._getvar(self.chromosome)

        t = self.var[0]
        deg = pi/180
        theta = self.var[1]*deg
        xtarget = 0.75/2
        ytarget = 0.5
        x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2
        y = (-3*t/2 + 123/92)*sin(theta)
        # 適應值
        fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8)

        # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰
        if t &gt; 1:
            fitness_value += 1000
        if t &lt; 0:
            fitness_value += 1000
        # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰
        if theta &gt; 2*pi:
            fitness_value += 1000
        if theta &lt; 0:
            fitness_value += 1000

        self.score = fitness_value

    def mutate(self, gene):
        self.chromosome[gene] = not self.chromosome[gene] # bit flip


if __name__ == "__main__":
    #env = Environment(Volume, size=500, maxgenerations=100)
    env = Environment(Intersect, size=500, maxgenerations=100)
    env.run()
&lt;/pre&gt;</content><category term="電腦輔助設計實習"></category><category term="2015 Fall cadp"></category></entry><entry><title>計算機程式與電腦輔助設計實習</title><link href="https://kmolab.github.io/blog/2017fall-cp-cadp.html" rel="alternate"></link><published>2017-07-06T12:00:00+08:00</published><updated>2017-07-06T12:00:00+08:00</updated><author><name>yen</name></author><id>tag:kmolab.github.io,2017-07-06:/blog/2017fall-cp-cadp.html</id><summary type="html">&lt;p&gt;以下為 Brython 網際程式環境.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;以下為 Brython 網際程式環境.&lt;/p&gt;


&lt;!-- 導入 Brython 標準程式庫 --&gt;

&lt;script src="./../data/Brython-3.3.1/brython.js"&gt;&lt;/script&gt;

&lt;script src="./../data/Brython-3.3.1/brython_stdlib.js"&gt;&lt;/script&gt;

&lt;!-- 啟動 Brython --&gt;

&lt;script&gt;
window.onload=function(){
// 設定 data/py 為共用程式路徑
brython({debug:1, pythonpath:['./../data/py']});
}
&lt;/script&gt;

&lt;p&gt;投影片:&lt;/p&gt;

&lt;div id="container1"&gt;&lt;/div&gt;

&lt;script type="text/python3"&gt;
from browser import document, html
container1 = document['container1']
adata = open("./../data/1a_list.txt").read()
alist = adata.splitlines()
n = 0
for stud_num in alist:
    mlink = html.A(stud_num, href="http://s"+str(stud_num)+".github.io/2017springwcm_hw")
    mlink += " | "
    n = n +1
    if n%8 == 0:
        mlink += html.BR()
    container1 &lt;= mlink
&lt;/script&gt;

&lt;!-- 在 blog 中引用圖檔, 只要往外跳一層即可跳出 blog 目錄 --&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src="./../data/logo/kmol_1172x340_blue_3yrs.png" width="300"&gt;&lt;/img&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;
&lt;a href="./../slides/template_slide.html"&gt;template slide&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;測試 LaTex 方程式寫法與轉換:&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
$$H\frac{d^{2}\theta (t)}{dt^{2}} = gSin\theta(t)+a_2(t)H-a_1(t)Cos\theta(t)$$
&lt;/pre&gt;

&lt;p&gt;經過轉換成為:&lt;/p&gt;
&lt;p&gt;$$H\frac{d^{2}\theta (t)}{dt^{2}} = gSin\theta(t)+a_2(t)H-a_1(t)Cos\theta(t)$$&lt;/p&gt;
&lt;pre class="brush: jscript"&gt;
$$\[L(\mu,\sigma;X)=\sum_i\left[-\frac 1 2 \ln(2\pi)-\ln(\sigma)-\frac{1}{2\sigma^2}(X_i-\mu)^2\right]\]$$
&lt;/pre&gt;

&lt;p&gt;經過轉換成為:&lt;/p&gt;
&lt;p&gt;$$[L(\mu,\sigma;X)=\sum_i\left[-\frac 1 2 \ln(2\pi)-\ln(\sigma)-\frac{1}{2\sigma^2}(X_i-\mu)^2\right]]$$&lt;/p&gt;</content><category term="Final"></category></entry><entry><title>網際內容管理</title><link href="https://kmolab.github.io/blog/wcm-course-1.html" rel="alternate"></link><published>2017-06-18T13:00:00+08:00</published><updated>2017-06-18T13:00:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-18:/blog/wcm-course-1.html</id><summary type="html">&lt;p&gt;網際內容管理課程在教導學生, 利用電腦與網路軟硬體配置, 完成各項與機械設計內容管理有關的任務.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;網際內容管理課程在教導學生, 利用電腦與網路軟硬體配置, 完成各項與機械設計內容管理有關的任務.&lt;/p&gt;


&lt;p&gt;所謂網際指的是 Web-Based, 也就是 World-Wide-Web Based 的簡稱, 中文也可以翻為"植基於全球資訊網" 或 "以全球資訊網為基礎", 其內涵是希望讓使用者在網際網路 (Internet) 的基礎上, 利用 Web Browser (瀏覽器) 操作各種與機械設計內容管理有關的任務.&lt;/p&gt;
&lt;h2&gt;Ubuntu 操作系統&lt;/h2&gt;
&lt;p&gt;根據 https://www.ubuntu.com/info/release-end-of-life 的生命週期年限, 選擇 LTS Server 版本安裝, 安裝過程需要安裝 OpenSSL 模組, 以及 ubuntu-desktop, Windows 客戶端則透過 &lt;a href="https://sourceforge.net/projects/xming/"&gt;xming&lt;/a&gt; 與 &lt;a href="http://www.putty.org/"&gt;http://www.putty.org/&lt;/a&gt; 進行安全的遠端登入.&lt;/p&gt;
&lt;h2&gt;IPv4 與 IPv6 網路設定&lt;/h2&gt;
&lt;p&gt;一般來說, 只有必須擔負特定 WWW Server、DNS Server 與 Proxy Server 的主機需要同時支援 IPv4 與 IPv6 網路協定外, 其餘客戶端都可以只透過 IPv6 網路協定上網.&lt;/p&gt;
&lt;p&gt;WWW Server 使用 Nginx, DNS Serve 使用 Bind, 而 Proxy Server 則使用 Squid.&lt;/p&gt;
&lt;h2&gt;Nginx&lt;/h2&gt;
&lt;p&gt;Nginx WWW 伺服器通常用來伺服靜態文件或者作為其他近端伺服資料傳送的代理主機 (例如, uwsgi 網際服務).&lt;/p&gt;
&lt;h2&gt;Ethercalc&lt;/h2&gt;
&lt;p&gt;Ethercalc 允許多人利用瀏覽器同時維護一份線上試算表, 可以用於協同資料永久存檔前的轉介站.&lt;/p&gt;
&lt;h2&gt;Fossil SCM&lt;/h2&gt;
&lt;p&gt;Fossil SCM 是一套小而美的分散式資料管理系統&lt;/p&gt;
&lt;h2&gt;Squid Proxy Server&lt;/h2&gt;
&lt;p&gt;在 IPv4 轉換到 IPv6 的過程中, 雙網路協定支援的代理主機扮演非常重要的角色, 例如, 從純 IPv4 瀏覽器連線到純 IPv6 WWW 伺服器, 就需要透過雙網路協定的代理主機轉介資料, 其次 putty ssh 遠端登入或 sftp 安全資料傳送, 也都需要雙網路支援的代理主機居中轉換不同協定資料.&lt;/p&gt;
&lt;h2&gt;X-windows&lt;/h2&gt;
&lt;h2&gt;Putty&lt;/h2&gt;
&lt;h2&gt;Leo Editor&lt;/h2&gt;
&lt;h2&gt;Filezilla 與 SFTP&lt;/h2&gt;
&lt;h2&gt;Uwsgi 與 CMSimfly&lt;/h2&gt;</content><category term="網際內容管理"></category><category term="課程"></category></entry><entry><title>協同產品設計實習</title><link href="https://kmolab.github.io/blog/cd-course-1.html" rel="alternate"></link><published>2017-06-18T12:00:00+08:00</published><updated>2017-06-18T12:00:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-18:/blog/cd-course-1.html</id><summary type="html">&lt;p&gt;協同產品設計課程在教導學生, 以同步或非同步協同方式, 利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;協同產品設計課程在教導學生, 以同步或非同步協同方式, 利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.&lt;/p&gt;
</content><category term="協同產品設計實習"></category><category term="課程"></category></entry><entry><title>電腦輔助設計實習</title><link href="https://kmolab.github.io/blog/cadp-course-1.html" rel="alternate"></link><published>2017-06-18T11:00:00+08:00</published><updated>2017-06-18T11:00:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-18:/blog/cadp-course-1.html</id><summary type="html">&lt;p&gt;電腦輔助設計課程在教導學生利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;電腦輔助設計課程在教導學生利用電腦軟體完成各項與機械設計運算與模擬流程有關的任務.&lt;/p&gt;


&lt;p&gt;CAD Book: &lt;a href="http://mde.tw/2016fallcadp/data/CAD_book.pdf"&gt;http://mde.tw/2016fallcadp/data/CAD_book.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://link.springer.com/content/pdf/10.1007%2F978-3-319-03862-9.pdf"&gt;Space Modeling with SolidWorks and NX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://beyondplm.com/2015/03/18/autodesk-and-onshape-disagree-about-cloud-technology-and-focus/"&gt;http://beyondplm.com/2015/03/18/autodesk-and-onshape-disagree-about-cloud-technology-and-focus/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.solidsmack.com/cad/onshape-comes-out-swinging-changes-mcad-pricing-forever/"&gt;https://www.solidsmack.com/cad/onshape-comes-out-swinging-changes-mcad-pricing-forever/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://newscrewdriver.com/category/3d-printing/3d-printing-software/fusion-360-vs-onshape/"&gt;https://newscrewdriver.com/category/3d-printing/3d-printing-software/fusion-360-vs-onshape/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;eBook: State of Product Development / PLM 2016&lt;/p&gt;
&lt;p&gt;&lt;a href="http://image.engineering.com/239575/articles/Nov%202016/Autodesk%20Q615/Autodesk_pdf1R.pdf"&gt;http://image.engineering.com/239575/articles/Nov%202016/Autodesk%20Q615/Autodesk_pdf1R.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CADO: &lt;a href="https://github.com/BGCECSE2015/CADO"&gt;https://github.com/BGCECSE2015/CADO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Electronics made easy: &lt;a href="http://fritzing.org/home/"&gt;http://fritzing.org/home/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SFEPy: &lt;a href="https://github.com/sfepy/sfepy"&gt;https://github.com/sfepy/sfepy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://nbviewer.jupyter.org/github/sukhbinder/sfepy-simple_tutorial/blob/master/Getting_Started_With_SFEPY_using_a_simpleplate_example.ipynb"&gt;http://nbviewer.jupyter.org/github/sukhbinder/sfepy-simple_tutorial/blob/master/Getting_Started_With_SFEPY_using_a_simpleplate_example.ipynb&lt;/a&gt;&lt;/p&gt;</content><category term="電腦輔助設計實習"></category><category term="課程"></category></entry><entry><title>計算機程式</title><link href="https://kmolab.github.io/blog/cp-course-1.html" rel="alternate"></link><published>2017-06-12T11:00:00+08:00</published><updated>2017-06-12T11:00:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-12:/blog/cp-course-1.html</id><summary type="html">&lt;p&gt;計算機程式課程在教導學生利用電腦完成各項與機械設計流程有關的任務.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;計算機程式課程在教導學生利用電腦完成各項與機械設計流程有關的任務.&lt;/p&gt;


&lt;h2&gt;為什麼非學不可?&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://cacm.acm.org/blogs/blog-cacm/166115-why-scientists-and-engineers-must-learn-programming/fulltext"&gt;https://cacm.acm.org/blogs/blog-cacm/166115-why-scientists-and-engineers-must-learn-programming/fulltext&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先, 看看機械設計流程會牽涉哪些任務, 所謂機械設計, 就是歷經詳細思慮考量, 完成互動元件間之精巧配置, 使其展現特定功能之具體規劃表達.&lt;/p&gt;
&lt;p&gt;換言之, 機械設計是一種具體規劃的表達 (presentation), 其內容是經過一系列詳細的思慮與考量所得到的結果, 而此項結果通常有具體的功能, 並且包含許多互動 (interaction) 元件之間的彈性與精巧配置 (flexible and sophisticated configuration).&lt;/p&gt;
&lt;p&gt;我們將上述與機械設計有關的關鍵字引列如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;機械設計是一種表達, 此種表達可以利用文字、口語、2D 靜態圖像、3D 或影音動態圖像、理論分析或實體呈現.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;機械設計的過程所需要的各種思慮與考量牽涉許多定性與定量的分析, 包含許多工程原理原則與實務經驗, 這些分析除了必須利用數學建立模型, 透過演算預先模擬外, 還需要使用有效率可協同的方式紀錄過程中所產生的各種資料.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;機械設計產品中所包含的各種互動元件, 包括硬體元件、流體元件、軟體元件與管理元件等.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;機械設計過程中, 為了在實體化之前能預先針對各種互動元件間的組成與配置進行最佳化, 因此需要使用各種逼真的模擬方法加以呈現.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;如何進行文字、2D&amp;amp;3D表達&lt;/h2&gt;
&lt;p&gt;有沒有一種方法可以讓多名使用者協同管理一份文件, 其中包含各種互動式圖文與影音資料, 各使用者在編修內容過程可以有效對資料進行保全, 可以有效分散備份, 可以紀錄各編修者所增刪的內容, 可以透過有效率的方法散佈此份文件的內容?&lt;/p&gt;
&lt;h2&gt;使用工具的評量方法&lt;/h2&gt;
&lt;p&gt;機械設計工程師為了有效完成具體規劃內容的表達, 過程中必須使用各種類型的工具, 其中包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文字資料構建、管理與呈現的工具 (text)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2  口語資料構建、管理與呈現的工具 (oral)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;2D 靜態圖像資料構建、管理與呈現的工具 (2d)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3D 或影音動態圖像資料構建、管理與呈現的工具 (3d)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理論分析資料構建、管理與呈現的工具 (analytical)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;實體構建、管理與呈現的工具 (physical)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;工具取得、維護使用成本與其他工具整合效能成本等&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;工具取得成本 (now and how)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;維護更新與永續使用成本 (update and sustainable)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工具掌握度與整合效能成本 (integration)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;一定要學 C&lt;/h2&gt;
&lt;p&gt;C 是為建立 Unix 操作系統而生的程式語言, 也是近代許多高階程式語言建構的基礎, 例如, 最早的 C 程式編譯器雖然採用組合語言編寫, 但是隨後的 C 程式編譯器則可以採用舊版的 C 來編譯, 而 Python 解譯器在 1980 年代晚期出現時, 就是以 C 程式編寫, 之後雖然有採用 Java 編寫的 Jython (2001), 以 C# 編寫的 IronPython (2006), 以 RPython 編寫的 PyPy (2007), 以 Javascript 編寫的 Brython (2012), 但是 CPython 仍然是最通用的版本.&lt;/p&gt;
&lt;p&gt;儘管 C 程式語言對於工程師而言非常重要, 但是 C 或更進階的 C++ 程式語言的學習並不容易, 並不只是因為 C/C++ 擁有指標, 能夠控制電腦的底層記憶體, 而是因為 C/C++ 程式語言所涵蓋的應用非常廣.&lt;/p&gt;
&lt;p&gt;但是無論如何, 工程師一定要學會基本的  C 程式語言, 倒是毋庸置疑.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.asme.org/career-education/articles/teachers-academics/c-as-part-of-a-mechanical-engineering-curriculum"&gt;https://www.asme.org/career-education/articles/teachers-academics/c-as-part-of-a-mechanical-engineering-curriculum&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;C 的指標與陣列導引&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html"&gt;http://cad-lab.github.io/manual/post/c-cheng-shi-yu-yan-de-zhi-biao-yu-zhen-lie-dao-yin-zhong-wen-fan-yi.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;CP to CADP&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/2015fallhw/cptocadp"&gt;https://github.com/2015fallhw/cptocadp&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;如何完成下列工作?&lt;/h2&gt;
&lt;p&gt;1) 從一本英文書的文字檔中, 算出總字數, 並按照英文字母排列, 列出書中所使用的單字, 並查出各單字的中文解釋.&lt;/p&gt;
&lt;p&gt;2) 從網站中擷取當天台幣與美金及英鎊的匯率, 並根據某一列有台幣、美金與英鎊的檔案進行各幣值的總結算.&lt;/p&gt;
&lt;p&gt;3) 每組有六人, 某一任務需要完成六項工作, 每人負責一項, 但各工作間必須互相配合, 任務進行中需要完整呈現各組員每一階段所完成的內容細節, 請問該如何完成.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/dustinrohde/python-rpn"&gt;https://github.com/dustinrohde/python-rpn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4) 如何將材料特性 2D 圖表轉為電腦可以套用的文字檔或資料庫檔案?&lt;/p&gt;
&lt;p&gt;漸開線正齒輪齒面寬運算 - 選擇正齒輪對所要傳遞的功率大小, 選擇所要使用的正齒輪齒數、模數與壓力角, 選擇齒輪的材質, 選擇小齒輪的齒數, 選擇安全係數, 從上述資料中算出齒輪齒面寬, 以便能在安全的範圍中, 不致產生過大噪音條件下完成所需功率的傳遞.&lt;/p&gt;
&lt;p&gt;漸開線正齒輪&lt;/p&gt;
&lt;p&gt;功率&lt;/p&gt;
&lt;p&gt;齒數、模數與壓力角&lt;/p&gt;
&lt;p&gt;齒輪的材質與強度&lt;/p&gt;
&lt;p&gt;安全係數&lt;/p&gt;
&lt;p&gt;振動與噪音&lt;/p&gt;
&lt;p&gt;齒輪的鍵銷設計&lt;/p&gt;
&lt;p&gt;齒輪的軸尺寸、強度與耐用度設計&lt;/p&gt;
&lt;p&gt;軸承的選用設計&lt;/p&gt;
&lt;p&gt;齒輪箱的設計&lt;/p&gt;
&lt;p&gt;齒輪的潤滑與散熱設計&lt;/p&gt;
&lt;p&gt;其他相關的設計分析、製造規劃與後勤維修等議題&lt;/p&gt;
&lt;p&gt;5) 文字檔與數位檔案的差別與運用, 各種 2D 與 3D 零組件檔格式的讀取與轉換&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/AutoCAD_DXF"&gt;https://en.wikipedia.org/wiki/AutoCAD_DXF&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf"&gt;http://images.autodesk.com/adsk/files/autocad_2012_pdf_dxf-reference_enu.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASCII DXF File Format&lt;/p&gt;
&lt;p&gt;Binary DXF File Format&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/STL_(file_format)"&gt;https://en.wikipedia.org/wiki/STL_(file_format)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.fabbers.com/tech/STL_Format"&gt;http://www.fabbers.com/tech/STL_Format&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASCII STL File Format&lt;/p&gt;
&lt;p&gt;Binary STL File Format&lt;/p&gt;
&lt;p&gt;IGES Version 5.3: &lt;a href="http://paulbourke.net/dataformats/iges/IGES.pdf"&gt;http://paulbourke.net/dataformats/iges/IGES.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IGES Version 6: &lt;a href="https://filemonger.com/specs/igs/devdept.com/version6.pdf"&gt;https://filemonger.com/specs/igs/devdept.com/version6.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/IGES"&gt;https://en.wikipedia.org/wiki/IGES&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DXF, IGES and STEP: &lt;a href="http://homepages.cae.wisc.edu/~me232/info/dxf_iges_step.pdf"&gt;http://homepages.cae.wisc.edu/~me232/info/dxf_iges_step.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Python3 學習&lt;/h2&gt;
&lt;p&gt;Official Tutorial: &lt;a href="https://docs.python.org/3/tutorial/"&gt;https://docs.python.org/3/tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.stavros.io/tutorials/python/"&gt; 10 min Python Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;help(), dir(), print(), &lt;a href="https://docs.python.org/3/tutorial/controlflow.html#the-range-function"&gt;range()&lt;/a&gt;, &lt;a href="https://docs.python.org/3/library/stdtypes.html"&gt;built-in types&lt;/a&gt;,&lt;/p&gt;
&lt;p&gt;看影片自學: &lt;a href="https://www.youtube.com/watch?v=D48iCw3WWpI"&gt;https://www.youtube.com/watch?v=D48iCw3WWpI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.spronck.net/pythonbook"&gt;http://www.spronck.net/pythonbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coodict/python3-in-one-pic/blob/master/notebooks/py3-in-one-pic.ipynb"&gt;https://github.com/coodict/python3-in-one-pic/blob/master/notebooks/py3-in-one-pic.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;資料分析: &lt;a href="https://lectures.quantecon.org/py/"&gt;https://lectures.quantecon.org/py/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Python 很慢?&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=8hHOxfXcWsg"&gt;https://www.youtube.com/watch?v=8hHOxfXcWsg&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=a8LsdodGoWQ"&gt;https://www.youtube.com/watch?v=a8LsdodGoWQ&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;PyQT&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://kuanyui.github.io/2014/09/13/learn-python-via-pyqt/"&gt;https://kuanyui.github.io/2014/09/13/learn-python-via-pyqt/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;網際程式繪圖&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://2015fallhw.github.io/2015fallcpa/g99_w15.html"http://2015fallhw.github.io/2015fallcpa/g99_w15.html&lt;/a&gt;&lt;/p&gt;</content><category term="計算機程式"></category><category term="課程"></category></entry><entry><title>大學生為何不來上課?</title><link href="https://kmolab.github.io/blog/first-discussion-blog.html" rel="alternate"></link><published>2017-06-05T05:29:00+08:00</published><updated>2017-06-05T05:29:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-05:/blog/first-discussion-blog.html</id><summary type="html">&lt;p&gt;大學生不願進教室上課的原因很多, 學費太低? 學不到東西? 完全跟不上進度? 老師太混? 上與不上都差不多? 實在爬不起來? 沒有人叫我起床? &lt;/p&gt;
</summary><content type="html">&lt;p&gt;大學生不願進教室上課的原因很多, 學費太低? 學不到東西? 完全跟不上進度? 老師太混? 上與不上都差不多? 實在爬不起來? 沒有人叫我起床? &lt;/p&gt;


&lt;h2&gt;大學生為何不來上課?&lt;/h2&gt;
&lt;p&gt;首先就大學生上課, 有幾項基本組成: 時段、課程內容、教師與學生等. 因此, 大學生之所以不想來上課, 可能是因為時段太早, 學生爬不起來而翹課; 也可能是課程內容不能讓學生認同, 內容太過簡單, 內容太過困難等原因, 讓學生視上課為畏途, 一有機會就不願意到課; 另外也可能是老師的教學方式得不到學生認同, 因此不願意上課; 最後則是學生本身的心態, 完全不知道為何要上這門課, 或者如何克服課程中所碰到的困難等問題, 導致學生一逮到機會就斷然翹課.&lt;/p&gt;
&lt;h2&gt;時段太早爬不起床&lt;/h2&gt;
&lt;p&gt;因時段太早而翹課, 大家都知道這絕對是藉口, 也就是說, 這不是學生翹課的主要原因, 而是因為其他主要原因的影響下, 讓學生拿時段太早當作翹課的藉口.&lt;/p&gt;
&lt;h2&gt;內容太淺, 內容太深&lt;/h2&gt;
&lt;p&gt;接著來談談因為課程內容無法得到學生認同而翹課的因素, 一般而說, 過去循序漸進, 以靜態課本內容為主的教學, 較能得到學生的認同, 因為所有會涵蓋的教學內容, 都已經鉅細靡遺列在教科書中, 因此針對此類型的課程, 學生到課的主要動機在於能以較高效益理解教科書內容, 但是針對主題已定但內容會隨學習成效而加以取捨的課程, 若學生的學習動機不夠強, 就會覺得無法掌握課程教學的主軸而失焦, 導致認為課程內容太過無聊或太過複雜而中途放棄, 造成學生不願意到課.&lt;/p&gt;
&lt;h2&gt;打工賺錢太忙, 沒時間上課&lt;/h2&gt;
&lt;p&gt;有部分學生因為經濟問題, 而必須邊上課邊工作賺錢, 大多數情況下, 由於大學尚未畢業, 無法根據專業找到報酬較高的工作, 因此大多在以時數累積賺錢的第一線服務業工作為主.&lt;/p&gt;
&lt;p&gt;當學生日以繼夜打工賺取學費或生活費的同時, 經常以此為藉口而弄得沒時間上課時, 最後在大學註冊的最終目的, 就只剩下拿學位一件事, 一般情況下, 非但無法專心在自己所學的專業上日日進步, 反而在自己的學業成績單上留下許多不良紀錄, 嚴重影響畢業後的發展.&lt;/p&gt;
&lt;p&gt;針對此類學生, 我們的建議是, 可以向學校的科系辦公室或職涯規劃單位求助, 尋求與本身專業有關的打工機會, 並且試著利用學校各專業科目所學內容, 在專業公司協助解決實務問題, 假若, 我們是說假若, 事實證明學校所傳授的知識, 完全無法在打工的過程中解決任何實務問題, 那麼表示念這書甚至拿這學位, 根本無助於往後的發展, 這時這些學生就可大步離開學校, 全力投入自己設想更有意義的工作上, 最後也就不會再有沒時間上課的問題了.&lt;/p&gt;
&lt;h2&gt;不知老師在教什麼?&lt;/h2&gt;
&lt;p&gt;老師的教學方式確實會影響學生的學習意願, 但是當學生從頭到尾都沒能到課的情形下, 還大聲疾呼說不知老師在教什麼? 就有些說不過去.&lt;/p&gt;
&lt;h2&gt;學這些東西沒有用&lt;/h2&gt;
&lt;p&gt;假如學生與家長真的認為在學校所學, 甚至拿學位無助往後發展, 建議應該及早離開學校, 從事更有意義的事, 尋求更好的發展機會.&lt;/p&gt;
&lt;h2&gt;其他思考&lt;/h2&gt;
&lt;p&gt;學生為何而讀, 為何而學, 為何而問?&lt;/p&gt;
&lt;p&gt;老師如何弄懂學生處境&lt;/p&gt;
&lt;p&gt;設法與學生共同學習&lt;/p&gt;
&lt;p&gt;鼓勵自學、執行與想像&lt;/p&gt;
&lt;p&gt;設法與表現好的學生一起協助跟不上進度的同學&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.ptt.cc/bbs/Gossiping/M.1392611157.A.D09.html"&gt;https://www.ptt.cc/bbs/Gossiping/M.1392611157.A.D09.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://kknews.cc/education/bxbg34n.html"&gt;https://kknews.cc/education/bxbg34n.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.cheers.com.tw/blog/blogTopic.action?id=425&amp;amp;nid=5513"&gt;https://www.cheers.com.tw/blog/blogTopic.action?id=425&amp;amp;nid=5513&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.thenewslens.com/article/664"&gt;https://www.thenewslens.com/article/664&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://shinphotos.com/2014-03-08-297/"&gt;https://shinphotos.com/2014-03-08-297/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.businessweekly.com.tw/article.aspx?id=1124&amp;amp;type=Blog"&gt;http://www.businessweekly.com.tw/article.aspx?id=1124&amp;amp;type=Blog&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;大學生應有的學習態度&lt;/h2&gt;
&lt;p&gt;面對全球協同的知識經濟環境, 身為一個大學生, 至少必須:&lt;/p&gt;
&lt;p&gt;不要怕困難 (基本信念) – 因為幾乎處於網路時代的所有人, 在享受高度科技發展所帶來的便利性之後, 都必須隨時獨力或合力克服各種困難.
不要失去熱忱 (強化動力) – 許多人在生活周遭都會碰到非常多不盡如人意的各種挑戰, 持續保持個人與團隊的處事熱忱, 是堅持克服困難的必備動力.
不要以為不可能 (終究達陣) – 只要個人不斷提升待人處事能力, 持續接觸人文養分, 並且在團隊機制的架構下, 以轉知為智的精神來解決各式問題, 假以時日, 便可實現團隊理想, 化不可能為可能!&lt;/p&gt;
&lt;p&gt;培養新世紀大學生的關鍵能力: &lt;/p&gt;
&lt;p&gt;http://www.tpea.org.tw/uploads/TPEA_2013112021132.pdf&lt;/p&gt;</content><category term="機械設計"></category><category term="課程"></category></entry><entry><title>其他</title><link href="https://kmolab.github.io/blog/first-misc-blog.html" rel="alternate"></link><published>2017-06-05T04:29:00+08:00</published><updated>2017-06-05T04:29:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-05:/blog/first-misc-blog.html</id><summary type="html">&lt;p&gt;不在設置, 模擬, 實作與論述類別的內容, 則放入雜項其他類別&lt;/p&gt;
</summary><content type="html">&lt;p&gt;不在設置, 模擬, 實作與論述類別的內容, 則放入雜項其他類別&lt;/p&gt;
</content><category term="機械設計"></category><category term="課程"></category></entry><entry><title>實作</title><link href="https://kmolab.github.io/blog/first-realization-blog.html" rel="alternate"></link><published>2017-06-05T03:29:00+08:00</published><updated>2017-06-05T03:29:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-05:/blog/first-realization-blog.html</id><summary type="html">&lt;p&gt;紀錄與實作有關的內容, 實體製作&lt;/p&gt;
</summary><content type="html">&lt;p&gt;紀錄與實作有關的內容, 實體製作&lt;/p&gt;


&lt;h2&gt;操作流程拍攝&lt;/h2&gt;
&lt;p&gt;有關實作, 包含拍攝實際操作的照片與影片. 在 Windows 環境建議使用 &lt;a href="https://getsharex.com/"&gt;ShareX&lt;/a&gt; 拍攝, Ubuntu 則建議使用 &lt;a href="https:// .net/kazam"&gt;Kazam&lt;/a&gt;. 另外一個值得研究的 PyQt5 + FFMpeg 工具位於: &lt;a href="https://github.com/codeshard/videomorph"&gt;https://github.com/codeshard/videomorph&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;理想的課程網頁&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://lectures.quantecon.org/"&gt;https://lectures.quantecon.org/&lt;/a&gt; 是一門教授數學與計量經濟學的課程, 分別使用 Python 與 Julia 程式語言, 採用 Python3 的課程教材 pdf 位於: &lt;a href="https://lectures.quantecon.org/_static/pdfs/QuantEconlectures-python3.pdf"&gt;https://lectures.quantecon.org/_static/pdfs/QuantEconlectures-python3.pdf&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;這門課程的網頁不僅有 &lt;a href="https://quantecon.org/news"&gt;News&lt;/a&gt;, 有&lt;a href="http://discourse.quantecon.org/"&gt;論壇&lt;/a&gt;, 並使用 Jupyter 建立網際 &lt;a href="https://quantecon.org/notebooks.html"&gt;Notebook&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;其中, 互動討論程式: &lt;a href="https://github.com/discourse/discourse"&gt;https://github.com/discourse/discourse&lt;/a&gt;, 為 discourse, 採用 Ruby 建立.&lt;/p&gt;
&lt;p&gt;Docker for Discourse: &lt;a href="https://github.com/discourse/discourse_docker"&gt;https://github.com/discourse/discourse_docker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安裝: &lt;a href="https://blog.fntsr.tw/articles/2014/11/07/how-to-build-discourse-with-docker-1/"&gt;https://blog.fntsr.tw/articles/2014/11/07/how-to-build-discourse-with-docker-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Discourse 中文: &lt;a href="https://meta.discoursecn.org/"&gt;https://meta.discoursecn.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;網際程式框架: &lt;a href="https://github.com/emberjs/ember.js"&gt;https://github.com/emberjs/ember.js&lt;/a&gt;&lt;/p&gt;</content><category term="機械設計"></category><category term="課程"></category></entry><entry><title>電腦模擬</title><link href="https://kmolab.github.io/blog/first-simulation-blog.html" rel="alternate"></link><published>2017-06-05T02:29:00+08:00</published><updated>2017-06-05T02:29:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-05:/blog/first-simulation-blog.html</id><summary type="html">&lt;p&gt;紀錄與電腦模擬相關內容與紀錄， 使用工具 Python3, &lt;a href="http://www.robodk.com/download"&gt;RoboDK&lt;/a&gt; (&lt;a href="https://robodk.com/doc/en/RoboDK-API.html"&gt;RoboDK API&lt;/a&gt;)&lt;/p&gt;
</summary><content type="html">&lt;p&gt;紀錄與電腦模擬相關內容與紀錄， 使用工具 Python3, &lt;a href="http://www.robodk.com/download"&gt;RoboDK&lt;/a&gt; (&lt;a href="https://robodk.com/doc/en/RoboDK-API.html"&gt;RoboDK API&lt;/a&gt;)&lt;/p&gt;


&lt;h2&gt;PyQt5&lt;/h2&gt;
&lt;p&gt;pyqt5 程式 &lt;a href="http://projects.skylogic.ca/blog/how-to-install-pyqt5-and-build-your-first-gui-in-python-3-4/"&gt;http://projects.skylogic.ca/blog/how-to-install-pyqt5-and-build-your-first-gui-in-python-3-4/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;run.py, 自行編寫用從 core/main.py 中導入 MainWindow 類別建立案例後執行&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if __name__ == "__main__":
    import sys
    from PyQt5.QtWidgets import QApplication

    from core.main import MainWindow

    app = QApplication(sys.argv)

    main = MainWindow()
    main.show()

    sys.exit(app.exec_())
&lt;/pre&gt;

&lt;p&gt;core/main.py, 以 main.ui 滑鼠右鍵 generate Dialog Code 產生&lt;/p&gt;
&lt;pre class="brush: python"&gt;
# -*- coding: utf-8 -*-

"""
Module implementing MainWindow.
"""

from PyQt5.QtCore import pyqtSlot
from PyQt5.QtWidgets import QMainWindow

from PyQt5.QtCore import QLineF
from PyQt5.QtWidgets import QFrame
from PyQt5.QtWidgets import QGraphicsScene,  QGraphicsView,  QGraphicsEllipseItem

from .Ui_main import Ui_MainWindow


class MainWindow(QMainWindow, Ui_MainWindow):
    """
    Class documentation goes here.
    """
    def __init__(self, parent=None):
        """
        Constructor

        @param parent reference to the parent widget
        @type QWidget
        """
        super(MainWindow, self).__init__(parent)
        self.setupUi(self)

    @pyqtSlot()
    def on_actionAbout_triggered(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        #raise NotImplementedError
        #建立景物
        scene = QGraphicsScene(-200, -200, 400, 400)
        # Create Ellipse Item
        item = QGraphicsEllipseItem(-150, -100, 300, 300)
        # Add item
        scene.addItem(item)
        # 納入繪圖物件
        scene.addText("終於可以!")
        scene.addLine(QLineF(0, 0, 200, 200))
        # set no frame to graphicsView
        self.graphicsView.setFrameShape(QFrame.NoFrame)
        # 在既有的 graphicsView 中設定景物
        # graphicsView in a layout and set layout to the grid to fit the size of window
        self.graphicsView.setScene(scene)

        # 顯示
        self.graphicsView.show()

    @pyqtSlot()
    def on_actionQuit_triggered(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        #raise NotImplementedError
        self.close()
&lt;/pre&gt;

&lt;p&gt;core/Ui_main.py, 利用 main.ui 以 compile form 產生&lt;/p&gt;
&lt;pre class="brush: python"&gt;

# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Y:\tmp\pyqt5_vault\ex3\core\main.ui'
#
# Created by: PyQt5 UI code generator 5.8.2
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralWidget = QtWidgets.QWidget(MainWindow)
        self.centralWidget.setObjectName("centralWidget")
        self.graphicsView = QtWidgets.QGraphicsView(self.centralWidget)
        self.graphicsView.setGeometry(QtCore.QRect(-15, -29, 871, 581))
        self.graphicsView.setObjectName("graphicsView")
        MainWindow.setCentralWidget(self.centralWidget)
        self.menuBar = QtWidgets.QMenuBar(MainWindow)
        self.menuBar.setGeometry(QtCore.QRect(0, 0, 800, 22))
        self.menuBar.setObjectName("menuBar")
        self.menuFile = QtWidgets.QMenu(self.menuBar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menuBar)
        self.actionAbout = QtWidgets.QAction(MainWindow)
        self.actionAbout.setObjectName("actionAbout")
        self.actionQuit = QtWidgets.QAction(MainWindow)
        self.actionQuit.setObjectName("actionQuit")
        self.menuFile.addAction(self.actionAbout)
        self.menuFile.addAction(self.actionQuit)
        self.menuBar.addAction(self.menuFile.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.actionAbout.setText(_translate("MainWindow", "About"))
        self.actionQuit.setText(_translate("MainWindow", "Quit"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
&lt;/pre&gt;

&lt;p&gt;main.ui&lt;/p&gt;
&lt;pre class="brush: xml"&gt;
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ui version="4.0"&gt;
 &lt;class&gt;MainWindow&lt;/class&gt;
 &lt;widget class="QMainWindow" name="MainWindow"&gt;
  &lt;property name="geometry"&gt;
   &lt;rect&gt;
    &lt;x&gt;0&lt;/x&gt;
    &lt;y&gt;0&lt;/y&gt;
    &lt;width&gt;800&lt;/width&gt;
    &lt;height&gt;600&lt;/height&gt;
   &lt;/rect&gt;
  &lt;/property&gt;
  &lt;property name="windowTitle"&gt;
   &lt;string&gt;MainWindow&lt;/string&gt;
  &lt;/property&gt;
  &lt;widget class="QWidget" name="centralWidget"&gt;
   &lt;widget class="QGraphicsView" name="graphicsView"&gt;
    &lt;property name="geometry"&gt;
     &lt;rect&gt;
      &lt;x&gt;-15&lt;/x&gt;
      &lt;y&gt;-29&lt;/y&gt;
      &lt;width&gt;871&lt;/width&gt;
      &lt;height&gt;581&lt;/height&gt;
     &lt;/rect&gt;
    &lt;/property&gt;
   &lt;/widget&gt;
  &lt;/widget&gt;
  &lt;widget class="QMenuBar" name="menuBar"&gt;
   &lt;property name="geometry"&gt;
    &lt;rect&gt;
     &lt;x&gt;0&lt;/x&gt;
     &lt;y&gt;0&lt;/y&gt;
     &lt;width&gt;800&lt;/width&gt;
     &lt;height&gt;22&lt;/height&gt;
    &lt;/rect&gt;
   &lt;/property&gt;
   &lt;widget class="QMenu" name="menuFile"&gt;
    &lt;property name="title"&gt;
     &lt;string&gt;File&lt;/string&gt;
    &lt;/property&gt;
    &lt;addaction name="actionAbout"/&gt;
    &lt;addaction name="actionQuit"/&gt;
   &lt;/widget&gt;
   &lt;addaction name="menuFile"/&gt;
  &lt;/widget&gt;
  &lt;action name="actionAbout"&gt;
   &lt;property name="text"&gt;
    &lt;string&gt;About&lt;/string&gt;
   &lt;/property&gt;
  &lt;/action&gt;
  &lt;action name="actionQuit"&gt;
   &lt;property name="text"&gt;
    &lt;string&gt;Quit&lt;/string&gt;
   &lt;/property&gt;
  &lt;/action&gt;
 &lt;/widget&gt;
 &lt;resources/&gt;
 &lt;connections/&gt;
&lt;/ui&gt;
&lt;/pre&gt;

&lt;h2&gt;Binary Genetic Algorithm&lt;/h2&gt;
&lt;pre class="brush: python"&gt;
#encoding=utf8
# genetic.py
#
import random
import operator
# for Intersect
from math import *
MAXIMIZE, MINIMIZE = 11, 22
class Individual:
    # 染色體先設為 None
    chromosome = None
    # 得分也先設為 None
    score = None
    # Here the size of var depends on var_number print
    # var 變數的元素個數取決於 var_number 的個數 (即變數個數)
    var = []
    # 表示適應值變數個數有兩個
    var_number = 2
    #先將 var 數列中元素都設為 0
    for i in range(var_number):
        var.append(0)
    # 等位基因表示各基因可選的內容, 這裡表示不是 0 就是 1
    alleles = (0,1)
    # 2**10 = 32*32 = 1024, 表示若用十個 binary 位數來表示整數, 可以表示從 0 到 1023 的數值大小
    # 若也用另外 十個 binary 位數來表示小數值, 則也是 0 到 1023 的數值表示能力, 
    # 而再加一個表示正負的代表 binary 位數, 每一個變數需要 21 個 binary numbers 
    # 以下為參數可負數時的編碼考量
    #前10為小數,後10為整數,第21則為正負號
    #0~9表示小數,10~19表示整數,而指標第20則表示第一數的正號或負號,若為0則表示正,若為1表示負號.
    #21~30表示第二數的小數部分,31~40則表示第二數的整數部分,第41指標則表示第二數的正號或負號
    #42~51表示第三數的小數部分,52~61則表示第二數的整數部分,第62指標則表示第三數的正號或負號
    # -1023 ~ 1023
    #length = 21*var_number,若接受負數參數,則必須同步修改 20-&gt;21
    # 因為這裡只接受正的變數值, 所以每一個變數需要 20 個 binary 位數
    length = 20*var_number
    seperator = ''
    optimization = MINIMIZE

    def __init__(self, chromosome=None):
        self.chromosome = chromosome or self._makechromosome()
        self.score = None  # set during evaluation

    '''
    bitwise operators (binary left shift): The left operands value is moved left by the number of bits specified by the right operand.
    x &lt;&lt; y
    Returns x with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is the same as multiplying x by 2**y.
    '''
    # 根據染色體各位元的值轉為 10 進位值
    def _getvar(self, chromosome=None):
        # x 起始值設為 0
        x = 0
        for i in range(0, self.var_number):
            # 先根據前 20 個位元值, 透過 binary left shift 轉為 10 進位之後, 再轉為對應小數
            for j in range(i*20, i*20+10):
                x += self.chromosome[j]&lt;&lt;(j-(i*20))
            # 因為前 20 個 binary 數, 負責 10 進位數的小數點後 3 個位數, 只要轉為 10 進位值之後, 若大於 999, 則僅取 999,
            # 再除以 1000, 可以得到 .999 表示 .999 為最大的小數表示數, 不要因為大於 1000 後若除以 1000 將進位到整數, 會與整數有交互影響
            if (x&gt;999):
                x = 999
            x /= 1000.
            # 整數部份 0 ~ 1023 的表示範圍則沒有問題, 利用 bitwise 轉換後, 直接取整數值
            for j in range(i*20+10, i*20+20):
                x += self.chromosome[j]&lt;&lt;(j-(i*20+10))
            self.var[i] = x
        return self.var

    ''' for -1023 ~ 1023,當設計變數可以接受負值時使用,每一變數使用21個 bit strings
    #for design variable -1023 ~1023
        for i in range(self.var_number):
            x = 0
            for j in range(i*21, i*21+10):
                x += self.chromosome[j]&lt;&lt;(j-(i*21))
            if (x&gt;999):
                x = 999
            x /= 1000.
            for j in range(i*(21)+10, i*(21)+20):
                x += self.chromosome[j]&lt;&lt;(j-(i*21+10))
            # 各變數範圍第 21 位數若為 1, 則表示該數為負數
            if(self.chromosome[i*(21)+20] == 1):
                self.var[i] = -x
            else:
                self.var[i] = x
            # 讓 x 再設回原值 0 表示內定各變數為正數
            x = 0
        return self.var
    '''
    # 建立染色體
    def _makechromosome(self):
        "makes a chromosome from randomly selected alleles."
        return [random.choice(self.alleles) for gene in range(self.length)]

    # 計算適應值
    def evaluate(self, optimum=None):
        "this method MUST be overridden to evaluate individual fitness score."
        pass

    # 交配方法
    def crossover(self, other):
        "override this method to use your preferred crossover method."
        return self._twopoint(other)

    # 突變方法
    def mutate(self, gene):
        "override this method to use your preferred mutation method."
        self._pick(gene)

    # sample mutation method
    def _pick(self, gene):
        "chooses a random allele to replace this gene's allele."
        self.chromosome[gene] = random.choice(self.alleles)

    # sample crossover method
    def _twopoint(self, other):
        "creates offspring via two-point crossover between mates."
        left, right = self._pickpivots()

        def mate(p0, p1):
            chromosome = p0.chromosome[:] # 交配時,以p0的基因為基礎(複製整個 p0 的染色體內容
            chromosome[left:right] = p1.chromosome[left:right] # 接續上一個 p0 的染色體內容,將索引 left 至 right 的內容,替換成 p1 的基因
            child = p0.__class__(chromosome)
            child._repair(p0, p1)
            return child
        return mate(self, other), mate(other, self)

    # some crossover helpers ...
    def _repair(self, parent1, parent2):
        "override this method, if necessary, to fix duplicated genes."
        pass

    def _pickpivots(self):
        left = random.randrange(1, self.length-2)
        right = random.randrange(left, self.length-1)
        return left, right
    #
    # other methods
    #
    def __repr__(self):
        "returns string representation of self"
        '''
        return '&lt;%s chromosome="%s" score=%s var=%s&gt;' % \
               (self.__class__.__name__,
                self.seperator.join(map(str,self.chromosome)), self.score,self._getvar(self.chromosome))
        '''
        return '&lt;%s score=%s var=%s&gt;' % \
               (self.__class__.__name__,self.score,self._getvar(self.chromosome))
    # since the __cmp__ special function is gone  use the __lt__ in stead
    # use the expression (a &gt; b) - (a &lt; b) as the equivalent for cmp(a, b)
    #def __cmp__(self, other):
    # these are for python 3
    def __cmp__(self, other):
        if self.optimization == MINIMIZE:
            #return cmp(self.score, other.score)
            return (self.score &gt; other.score) - (self.score &lt; other.score)
        else: # MAXIMIZE
            #return cmp(other.score, self.score)
            return (other.score &gt; self.score) - (other.score &lt; self.score)

    def __lt__(self, other):
        return self.__cmp__(other) &lt; 0
    def __le__(self, other):
        return self.__cmp__(other) &lt;= 0
    def __gt__(self, other):
        return self.__cmp__(other) &gt; 0
    def __ge__(self, other):
        return self.__cmp__(other) &gt;= 0 
    def copy(self):
        twin = self.__class__(self.chromosome[:])
        twin.score = self.score
        return twin
class Environment(object):
    x = [0]
    y = [0]

    def __init__(self, kind, population=None, size=100, maxgenerations=100,
                 crossover_rate=0.90, mutation_rate=0.07, optimum=None):
        self.kind = kind
        self.size = size
        self.optimum = optimum
        self.population = population or self._makepopulation()
        for individual in self.population:
            individual.evaluate(self.optimum)
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.maxgenerations = maxgenerations
        self.generation = 0
        self.report()

    def _makepopulation(self):
        return [self.kind() for individual in range(self.size)]

    def run(self):
        while not self._goal():
            self.step()

    def _goal(self):
        return self.generation &gt; self.maxgenerations or \
               self.best.score == self.optimum

    def step(self):
        # this sort is not working with python 3.0, modification is needed
        self.population.sort()
        self._crossover()
        self.generation += 1
        self.report()
        self.x.append(self.generation)
        # 設定為只附加所選定範圍的值,這裡只取大於或等於 0 的 score 值
        if self.best.score &lt;=5:
            self.y.append(self.best.score)
        else:
            self.y.append(5)

    def _crossover(self):
        next_population = [self.best.copy()]
        while len(next_population) &lt; self.size:
            mate1 = self._select()
            if random.random() &lt; self.crossover_rate:
                mate2 = self._select()
                offspring = mate1.crossover(mate2)
            else:
                offspring = [mate1.copy()]
            for individual in offspring:
                self._mutate(individual)
                individual.evaluate(self.optimum)
                next_population.append(individual)
        self.population = next_population[:self.size]

    def _select(self):
        "override this to use your preferred selection method"
        return self._tournament()

    def _mutate(self, individual):
        for gene in range(individual.length):
            if random.random() &lt; self.mutation_rate:
                individual.mutate(gene)
    #
    # sample selection method
    #
    def _tournament(self, size=8, choosebest=0.90):
        competitors = [random.choice(self.population) for i in range(size)]
        competitors.sort()
        if random.random() &lt; choosebest:
            return competitors[0]
        else:
            return random.choice(competitors[1:])

    def best():
        doc = "individual with best fitness score in population."
        def fget(self):
            return self.population[0]
        return locals()
    best = property(**best())

    def report(self):
        try:
            print ("="*70)
            print ("generation: ", self.generation)
            print ("best:       ", self.best)
        except:
            g.es ("="*70)
            g.es ("generation: ", self.generation)
            g.es ("best:       ", self.best)

# 以上為 genetic.py 目前將兩者結合在一起
#encoding=utf8
# volume.py - useage example
#
# the fittest individual will have a chromosome consisting of 40 '1's
#
#
#import genetic
class Volume(Individual):
    optimization = MAXIMIZE
    def evaluate(self, optimum=None):
        SURFACE = 80
        # self.score is the fitness value
        self._getvar(self.chromosome)

        x = self.var[0]
        y = self.var[1]
        z=(SURFACE - x*y)/(2.*(x+y))
        fitness_value = x*y*z

        self.score = fitness_value

    def mutate(self, gene):
        self.chromosome[gene] = not self.chromosome[gene] # bit flip

class Intersect(Individual):
    optimization = MINIMIZE
    def evaluate(self, optimum=None):
        # self.score is the fitness value
        self._getvar(self.chromosome)

        t = self.var[0]
        deg = pi/180
        theta = self.var[1]*deg
        xtarget = 0.75/2
        ytarget = 0.5
        x = t*sqrt(-225*sin(theta)**2 + 529)/10 - sqrt(-225*sin(theta)**2 + 529)/92 + 3*cos(theta)/2
        y = (-3*t/2 + 123/92)*sin(theta)
        # 適應值
        fitness_value = pow(x-xtarget, 8)+pow(y-ytarget, 8)

        # 指定 t 的範圍, 小於 1 大於 0, 否則給予處罰
        if t &gt; 1:
            fitness_value += 1000
        if t &lt; 0:
            fitness_value += 1000
        # 指定 theta 的範圍, 小於 2pi 大於 0, 否則給予處罰
        if theta &gt; 2*pi:
            fitness_value += 1000
        if theta &lt; 0:
            fitness_value += 1000


        self.score = fitness_value

    def mutate(self, gene):
        self.chromosome[gene] = not self.chromosome[gene] # bit flip


if __name__ == "__main__":
    env = Environment(Volume, size=500, maxgenerations=100)
    #env = Environment(Intersect, size=500, maxgenerations=100)
    env.run()
&lt;/pre&gt;

&lt;h2&gt;Deap 與 Scoop&lt;/h2&gt;
&lt;p&gt;Deap: &lt;a href="https://github.com/DEAP/deap"&gt;https://github.com/DEAP/deap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Scoop: &lt;a href="https://en.wikipedia.org/wiki/Python_SCOOP_(software)"&gt;https://en.wikipedia.org/wiki/Python_SCOOP_(software)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://groups.google.com/forum/#!topic/deap-users/v3wbky0EUf0"&gt;https://groups.google.com/forum/#!topic/deap-users/v3wbky0EUf0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://groups.google.com/forum/m/#!msg/deap-users/P4IkiE-Bvbg/xSoMDphbMR4J"&gt;https://groups.google.com/forum/m/#!msg/deap-users/P4IkiE-Bvbg/xSoMDphbMR4J&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;平行運算&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://research.cs.wisc.edu/htcondor/"&gt;http://research.cs.wisc.edu/htcondor/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/J-Robinson/GridGA"&gt;https://github.com/J-Robinson/GridGA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用 Blender 製作 &lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=WUvTyaaNkzM"&gt;Essence of calculus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=kjBOesZCoqc"&gt;Essence of linear algebra&lt;/a&gt;&lt;/p&gt;</content><category term="機械設計"></category><category term="課程"></category></entry><entry><title>軟硬體設置</title><link href="https://kmolab.github.io/blog/first-setup-blog.html" rel="alternate"></link><published>2017-06-05T01:29:00+08:00</published><updated>2017-06-05T01:29:00+08:00</updated><author><name>kmol</name></author><id>tag:kmolab.github.io,2017-06-05:/blog/first-setup-blog.html</id><summary type="html">&lt;p&gt;紀錄電腦與網路的軟硬體相關設置&lt;/p&gt;
</summary><content type="html">&lt;p&gt;紀錄電腦與網路的軟硬體相關設置&lt;/p&gt;


&lt;h2&gt;Github, Bitbucket 與 Fossil SCM&lt;/h2&gt;
&lt;p&gt;Github 目前提供的免費帳號, 允許多人協同提交推送版本, 唯一的限制就是單一檔案不能大於 50 MB.&lt;/p&gt;
&lt;p&gt;Bitbucket 則允許免費使用非公開的倉儲, 但是至多只允許五個帳號協同.&lt;/p&gt;
&lt;p&gt;Fossil SCM 則適合在近端或區域網路中使用, 目前 KMOLab 希望在區網中導入作為與 Github Pages 配合的工具, 使用者可以將 Fossil SCM 的 working directory 限縮在 Github 近端倉儲的特定目錄下, 且在 .gitignore 中排除 &lt;em&gt;FOSSIL&lt;/em&gt; (under Windows) 的版次管理, 但是相關的 fossil update 與 fossil server 功能仍然必須依照特定的流程進行操作, 以避免兩套版次管理系統內容的不同步導致資料覆蓋流失.&lt;/p&gt;
&lt;p&gt;github 倉儲與 bitbucket 倉儲, 則可以利用 git remote add 同步.&lt;/p&gt;
&lt;h2&gt;Leo Editor, Pelican 與 Reveal.js&lt;/h2&gt;
&lt;p&gt;Leo Editor 是一套能夠以程式方法有效管理多元資料的文字資料編輯器, 以下就是用來管理 KMOLab Pelican 靜態網誌有關內容的畫面, 其中的 @button local-blog 是用來產生靜態網誌的指令按鈕, @button github-blog 則是用來產生嵌入 Disqus 留言系統的 Github Pages 網誌對應指令, 兩個指令的差別在於使用不同的設定檔案, 使用者可以先利用近端的按鈕, 建立網誌後在近端以另一個 https-server 按鈕建立 https 伺服, 用瀏覽器檢查所產生的網誌內容, 一旦要送到 Github 倉儲, 必須再利用遠端按鈕產生另外一組網誌與搜尋用 .json 檔案後, 再提交推送到倉儲.&lt;/p&gt;
&lt;p&gt;在這個過程中, 使用者依照 Pelican 的特定 Markdown 檔案編寫網誌內容外, Leo Editor 專案檔中也可以放入其他有關的註記與設定檔案編輯用的節點. 若需要在 Pelican 的環境中修改設定, 都可以全部在一個 Leo Editor 專案檔中完成.&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/images/leo_editor_kmolab.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;Leo Editor 另外一項有用的特定就是能夠利用從屬節點關係與內文指令來表示複雜的 html 檔案, 如下圖所示, 各段落的超文件標註可以利用節點加以切割, 使用者在編寫 reveal.js 投影片時, 可以只集中在特定簡報內容的編寫, 並且透過節點的複製與搬移, 甚至使用 Leo Editor 的節點 clone 功能, 同步相同內容但是同時出現在不同位置的節點.&lt;/p&gt;
&lt;p&gt;&lt;img src="./../data/images/reveal_slide_on_leo_editor.png" width="800" /&gt;&lt;/p&gt;
&lt;p&gt;Pelican Blog 共用設定檔案:&lt;/p&gt;
&lt;p&gt;pelicanconf.py&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#!/usr/bin/env python
# -*- coding: utf-8 -*- #
from __future__ import unicode_literals

AUTHOR = 'KMOL'
SITENAME = 'KMOLab 機械設計工程'
# 不要用文章所在目錄作為類別
USE_FOLDER_AS_CATEGORY = False

#PATH = 'content'

#OUTPUT_PATH = 'output'

TIMEZONE = 'Asia/Taipei'

DEFAULT_LANG = 'en'

# Feed generation is usually not desired when developing
FEED_ALL_ATOM = None
CATEGORY_FEED_ATOM = None
TRANSLATION_FEED_ATOM = None
AUTHOR_FEED_ATOM = None
AUTHOR_FEED_RSS = None

# Blogroll
LINKS = (('Pelican', 'http://getpelican.com/'),
         ('pelican-bootstrap3', 'https://github.com/DandyDev/pelican-bootstrap3/'),
         ('pelican-plugins', 'https://github.com/getpelican/pelican-plugins'),
         ('Tipue search', 'https://github.com/Tipue/Tipue-Search'),)

# Social widget
#SOCIAL = (('You can add links in your config file', '#'),('Another social link', '#'),)

DEFAULT_PAGINATION = 10

# Uncomment following line if you want document-relative URLs when developing
#RELATIVE_URLS = True

# 必須絕對目錄或相對於設定檔案所在目錄
PLUGIN_PATHS = ['plugin']
PLUGINS = ['summary', 'tipue_search', 'sitemap']

# for sitemap plugin
SITEMAP = {
    'format': 'xml',
    'priorities': {
        'articles': 0.5,
        'indexes': 0.5,
        'pages': 0.5
    },
    'changefreqs': {
        'articles': 'monthly',
        'indexes': 'daily',
        'pages': 'monthly'
    }
}

# search is for Tipue search
DIRECT_TEMPLATES = (('index', 'tags', 'categories', 'authors', 'archives', 'search'))

# for pelican-bootstrap3 theme settings
#TAG_CLOUD_MAX_ITEMS = 50
DISPLAY_CATEGORIES_ON_SIDEBAR = True
DISPLAY_RECENT_POSTS_ON_SIDEBAR = True
DISPLAY_TAGS_ON_SIDEBAR = True
DISPLAY_TAGS_INLINE = True
TAGS_URL = "tags.html"
CATEGORIES_URL = "categories.html"
MENUITEMS = [('About', '/blog/pages/about/')]
#SHOW_ARTICLE_AUTHOR = True

#MENUITEMS = [('Home', '/'), ('Archives', '/archives.html'), ('Search', '/search.html')]
&lt;/pre&gt;

&lt;p&gt;遠端 publishconf.py&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#!/usr/bin/env python
# -*- coding: utf-8 -*- #
from __future__ import unicode_literals

# This file is only used if you use `make publish` or
# explicitly specify it as your config file.

import os
import sys
sys.path.append(os.curdir)
from pelicanconf import *

# 因為 publishconf.py 在 pelicanconf.py 之後, 因此若兩處有相同變數的設定, 將以較後讀入的 publishconf.py 中的設定為主.

# 將所有靜態 html 檔案移到 blog 子目錄
SITEURL = 'https://kmolab.github.io/blog'
# 此設定用於將資料送到 gh-pages, 因此使用絕對 URL 設定
RELATIVE_URLS = False
# 為了要讓 local 與 gh-pages 上都能夠使用 Tipue search, 可能要採用不同的 theme
THEME = 'theme/pelican-bootstrap3'
#BOOTSTRAP_THEME = 'readable'
#BOOTSTRAP_THEME = 'readable-old'
BOOTSTRAP_THEME = 'united'
#PYGMENTS_STYLE = 'paraiso-drak'
#PYGMENTS_STYLE = 'fruity'
# 為了同時兼容 render_math, 必須放棄 fruity
PYGMENTS_STYLE = 'monokai'

FEED_ALL_ATOM = 'feeds/all.atom.xml'
CATEGORY_FEED_ATOM = 'feeds/%s.atom.xml'

DELETE_OUTPUT_DIRECTORY = True

# Following items are often useful when publishing

DISQUS_SITENAME = "kmolabmde"
#GOOGLE_ANALYTICS = ""

# 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定
DEFAULT_DATE = 'fs'

# 遠端的 code hightlight
#MD_EXTENSIONS = ['fenced_code', 'extra', 'codehilite(linenums=True)']
MARKDOWN = {
    'extension_configs': {
        'markdown.extensions.codehilite': {'css_class': 'highlight'},
        'markdown.extensions.extra': {},
        'markdown.extensions.meta': {},
    },
    'output_format': 'html5',
}

# 若要依照日期存檔呼叫
#ARTICLE_URL = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/'
#ARTICLE_SAVE_AS = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html'
PAGE_URL = 'pages/{slug}/'
PAGE_SAVE_AS = 'pages/{slug}/index.html'
SHOW_ARTICLE_AUTHOR = True
&lt;/pre&gt;

&lt;p&gt;local_publishconf.py&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#!/usr/bin/env python
# -*- coding: utf-8 -*- #
from __future__ import unicode_literals

# This file is only used if you use `make publish` or
# explicitly specify it as your config file.

import os
import sys
sys.path.append(os.curdir)
from pelicanconf import *

# 因為 publishconf.py 在 pelicanconf.py 之後, 因此若兩處有相同變數的設定, 將以較後讀入的 publishconf.py 中的設定為主.

# 請注意, 為了在近端讓 Tipue search 傳回的搜尋結果連結正確, 必須使用 ./
SITEURL = './'
# 此設定用於近端靜態網頁查驗, 因此使用相對 URL
RELATIVE_URLS = True
# 為了要讓 local 與 gh-pages 上都能夠使用 Tipue search, 可能要採用不同的 theme
THEME = 'theme/pelican-bootstrap3_local'
#BOOTSTRAP_THEME = 'readable'
#BOOTSTRAP_THEME = 'readable-old'
BOOTSTRAP_THEME = 'united'
#PYGMENTS_STYLE = 'paraiso-drak'
#PYGMENTS_STYLE = 'fruity'
# 為了同時兼容 render_math, 必須放棄 fruity
PYGMENTS_STYLE = 'monokai'

FEED_ALL_ATOM = 'feeds/all.atom.xml'
CATEGORY_FEED_ATOM = 'feeds/%s.atom.xml'

DELETE_OUTPUT_DIRECTORY = True

# Following items are often useful when publishing

#DISQUS_SITENAME = "kmolabmde"
#GOOGLE_ANALYTICS = ""

# 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定
DEFAULT_DATE = 'fs'

# 近端的 code hightlight
#MD_EXTENSIONS = ['fenced_code', 'extra', 'codehilite(linenums=True)']
MARKDOWN = {
    'extension_configs': {
        'markdown.extensions.codehilite': {'css_class': 'highlight'},
        'markdown.extensions.extra': {},
        'markdown.extensions.meta': {},
    },
    'output_format': 'html5',
}

# 若要依照日期存檔呼叫
#ARTICLE_URL = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html'
#ARTICLE_SAVE_AS = 'posts/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html'
PAGE_URL = 'pages/{slug}/'
PAGE_SAVE_AS = 'pages/{slug}/index.html'
SHOW_ARTICLE_AUTHOR = True
&lt;/pre&gt;

&lt;h2&gt;區網中的 IPv4 與 IPv6 WWW Server&lt;/h2&gt;
&lt;p&gt;Pelican 在近端產生 weblog 後, 若要在近端以 https 檢視結果, 就必須同時建立 https Server.&lt;/p&gt;
&lt;p&gt;近端 IPv4 WWW 伺服器程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 5443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print(os.getcwd())
    print("5443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()
&lt;/pre&gt;

&lt;p&gt;近端 IPv6 ＷＷＷ 伺服器程式:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import os
import subprocess
import threading
import socket
import http.server, ssl

class HTTPServerV6(http.server.HTTPServer):
    address_family = socket.AF_INET6

def domake():
    # build directory
    os.chdir("./../")
    ipv6_address = '::1'
    server_address = (ipv6_address, 6443)
    #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("6443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()
&lt;/pre&gt;</content><category term="Github"></category><category term="Bitbucket"></category><category term="Fossil SCM"></category><category term="Leo Editor"></category><category term="Pelican"></category><category term="Reveal.js"></category></entry></feed>